                                                 â–ª 6â–ª                       KonputagailuParaleloenKomunikazioSarea.                       MezuEmatearen bidezkoKomunikazioa.          6.1. SARRERA Sistema paralelo baten osagai nagusiak hiru dira: konputagailuak (prozesadorea, memoria...), komunikazio-sarea eta bion arteko interfazea. Aurreko kapituluetan, memoria eta prozesadoreak komunikatzeko bus bat erabiltzen duten multiprozesadoreak aztertu ditugu (SMP sistemak); sistema horietan, memoria zentralizatuta dago, helbide-espazioa bera eta bakarra da prozesu guztietarako eta, ondorioz, memoriako atzipen-denbora berdina da edozein prozesadoretatik abiatuta. Busa, ordea, ez da sare egokia prozesadore anitzeko sistema paraleloak sortzeko, onartzen duen datu-trafiko maximoa oso handia ez delako, eta datu-trafikoa, tamalez, prozesadore kopuruarekin hazi egiten da, maiz linealki baino azkarrago. Ondorioz, SMP sistemetako prozesadore kopurua txikia da (eskuarki, 4 - 8 prozesadore, eta, gehienez, 16 edo 32), komunikaziorako baliabideak ase egiten baitira. Konputagailu paralelo handiagoak, ehunka edota milaka prozesadorekoak osatzeko, beraz, bestelako egiturak eta konexio-sareak erabili behar ditugu. Ezinbestean, memoria (dela pribatua dela partekatua) banatu egin behar da sistemako prozesadoreen edo nodoen artean, eta, ondorioz, ezin da busa erabili komunikazio-sare gisa. Kapitulu honetan, DSM sistemetan (memoria partekatua) zein MPP sistemetan (memoria pribatua) prozesadoreak konektatzeko erabiltzen diren sareak aztertuko ditugu. Prozesadoreen arteko informazio-trukea ez da konputagailu paraleloen ezaugarri esklusiboa. Izan ere, konputagailuzko sareak "zaharrak" dira informatikako munduan: ARPANET sarea 1969 urtekoa da; badago, beraz, nahikoa historia atzetik. Hala ere, nahiz eta LAN eta WAN (local & wide area network) motako sareekin hainbat kontzeptu eta irtenbide partekatu, MPP sistemetan erabiltzen diren konexio-sareak bereziak dira, komunikazio-beharra askoz handiagoa baita, eta askoz denbora txikiagoan bete behar baita. Argi gera dadin: ezin dira konparatu ekuazio-sistema bat paraleloan ebazten denean sortzen den komunikazio-beharra eta Internet sarean dauden bi erabiltzaile komunikatzeko bidaltzen den posta-mezu bat. Lehenbizikoan, komunikazioa mikrosegundotan bete beharko da, gai kritikoa baita exekuzio azkarra lortzeko; bigarrenean, aldiz, ez. Beste ezaugarri desberdin bat, esaterako, prozesadoreen arteko distantzia da: LAN eta WAN sareetan, metro batzuetakoa edo kilometrotakoa izan daiteke; MPP sistemetan, aldiz, distantzia horrek ez du metro bat (gutxi batzuk) gaindituko. Hala ere, ezin ditugu ahaztu azken aldian asko garatu diren tarteko arkitekturak: cluster-ak eta antzekoak. Izan ere, ez dira eraginkortasun handieneko sistema paraleloak, baina bai "kostu/eraginkortasuna" erlazioa orekatuena dutenak. Sistema paralelo horietan, konputagailu-sareetarako garatu diren abiadura "handiko" sareak erabiltzen dira (esaterako, Gigabit Ethernet), bai eta azkarragoak (eta garestiagoak) diren berariazko sareak ere (InfiniBand edo Myrinet, esaterako). Memoria banatuko sistema paralelo baten komunikazio-sarearen eginkizuna argi eta garbi dago: sistema paraleloan exekutatzen ari den algoritmoaren arabera, informazioa prozesadore batetik bestera garraiatzea. Gainera, komunikazioaren latentzia (denbora) ahalik eta txikien mantendu behar da; komunikazio asko batera onartu behar da; sarearen kostuak txikia izan behar du; eta, neurri batean behintzat, sareak funtzionatu egin behar du matxurak izanda ere. Eta, aukeran, aurreko guztia sarean konektatuta dagoen prozesadore kopuruarekiko independentea izan beharko litzateke. Orain arte aztertu ditugun sistema paraleloen komunikazio-sarea oso sinplea izan da: busa. Kostuaren aldetik, busa oso sare egokia da (merkea), baina ez da oso eraginkorra. Konexio-sare gisa busa erabiltzen denean, busaren banda- zabalera partekatu egin behar da, denboran zehar, prozesadore guztien artean (ezin dira bi mezu batera bidali); hori dela eta, ez da egokia busera prozesadore asko konektatzea, busa erabiltzeko lehia oso handia izango delako, eta, ondorioz, komunikazioen latentzia asko haziko direlako. Nahi izanez gero, bus bat baino gehiago erabil daiteke sistemaren komunikazio-ahalmena handitzeko, eta, esaterako, hierarkia bat osatu, 3. kapituluan ikusi dugun moduan. Beste muturrera bagoaz, prozesadore guztiak guztiekin konektatzen dituen sarea dugu, crossbar izeneko sarea, alegia. Sarerik "onena" da, prozesadore bikote guztiak bide "pribatuen" bidez lotzen baitira; hau da, sareko osagaiak ez dira partekatu behar, eta, beraz, komunikazioen latentzia minimoa izango da. Jakina, sare horren kostua oso handia da, eta, gainera, kostu hori esponentzialki hazten da prozesadore kopuruarekin. Beraz, tarteko soluzioak aurkitu behar ditugu, milaka prozesadore konektatu nahi badugu, behintzat. Bi atal bereiz ditzakegu komunikazio-sare batean. Batetik, hardwarea: kommutagailuak edo mezu-bideragailuak, loturak, eta prozesadorearen eta sarearen arteko interfazea. Eta, bestetik, softwarea: komunikazio-protokoloak (hainbat mailatan). Hurrengo ataletan, sistema paraleloetan gehien erabiltzen diren sareak eta komunikazio-prozesuen ezaugarri nagusiak aztertuko ditugu: sarearen topologia, sare-motak, bideratze-algoritmoak, kommutazio-estrategiak, informazio-jarioaren kontrola, komunikazioaren eraginkortasuna, arazo nagusiak eta abar.   6.2. SAREAREN TOPOLOGIA Komunikazio-sarearen topologiak prozesadoreen arteko konexioak definitzen ditu, grafo baten bidez. Sare baten topologia aztertzeko, grafo-teoria erabili behar da. Grafoaren nodoak prozesadoreak (edo, hobeto esan, komunikazio- kudeatzaileak) dira, eta grafoaren arkuak komunikazio-loturak. Grafoak kontuan hartuz, hainbat parametro topologiko defini daitezke sarearen portaera aztertzeko. Beraz, sare nagusiak aztertzen hasi baino lehen, defini ditzagun parametro horiek. â€¢Batez besteko distantzia, d: nodo bikote guztien arteko batez besteko distantzia da. Distantzia neurtzeko, iturburutik helburura heltzeko iragan behar den tarteko nodo kopurua kontuan hartzen da (bide minimoak erabiltzen direla). Beraz,   â€¢Diametroa, D: edozein nodo bikoteren artean dagoen distantziarik handiena (haien arteko distantzia minimoak kontuan hartuz).   Bi distantzia-parametroak, batez besteko distantzia eta diametroa, prozesuen arteko komunikazioen latentziari (denborari) buruzko hurbilpen edo ideiaren bat eskaintzen dute, kasurik txarrenean (diametroa) eta batez bestean, komunikazioa zorizkoa bada.   â€¢Gradua : nodo (prozesadore) bati dagokion lotura kopurua da. Nodo guztien gradua bera bada, sarea erregularra da. Gradu ez oso handiko sareak dira erabilgarrienak (4 edo 6koak esaterako). Izan ere, gradua handia bada, oso konplexua da sarea eraikitzea (konexio guztiak egitea). Oro har, ona da gradua nodo kopuruarekiko independentea izatea.   â€¢Simetria : edozein prozesadorek sareari buruz duen ikuspegia berdina denean, sarea simetrikoa da. Ezaugarri desiragarria da, komunikaziorako bideak aukeratzea erraztu egiten baitu.   â€¢Zabalgarritasuna edohedagarritasuna (scalability): komunikazio-sare onak zabaltzen erraza izan beharko luke, sistemaren hazkundea ahalbidetzeko.   â€¢Hutsegiteekiko tolerantzia : komunikazio-sareak fidagarria izan behar du; beti prest egon behar du mezuak garraiatzeko, eta mezu guztiek helburuetara heldu behar dute. Horrek esan nahi du sistemak jarraitu egin beharko lukeela funtzionatzen nahiz eta sareko osagai bat(zuk) matxuratuta izan. Ezinbesteko baldintza bihurtzen da hori nodo kopurua handia bada, hutsegite-probabilitatea hazi egiten delako osagai kopuruarekin. Era berean, nahitaezko ezaugarria da, egoera dena delarik, sistemaren funtzionamendua ziurtatu behar denean, eta akatsak konpontzeko lanak zailak edo ezinezkoak direnean. â€¢Konektibitatea : matxuratu behar den nodo edo lotura kopuru minimoa â€”nodo-konektibitatea edo arku-konektibitateaâ€” sarea ez-konexo bihurtzeko, hau da, bi edo zati gehiagotan hausteko. Hutsegiteekiko tolerantziarekin erlazionatuta dagoen ezaugarria da.   â€¢Sarearen erdibiketa : sarea bi parte berdinetan banatzeko kendu behar den lotura kopuru minimoa. Geroxeago ikusiko dugunez, lotura horiek zedarritzen dute sarean izan dezakegun trafiko maximoa (baldintza jakin batzuen pean).   â€¢Lotura mota : nodoen arteko loturak noranzko bakarrekoak izan daitezke â€”hots, Aâ†’Bâ€”, edo noranzko bikoak â€”hau da, Aâ†”Bâ€” Lotura motak eragin nabarmena du sarearen distantzia-parametroetan (komunikazioan, beraz). Loturak direla eta (noranzko bakarrekoak edo bikoak), bi kategoria hauetan banatu ohi dira sareak: directed, noranzko markatu bat dutenak, eta non- directed(edo undirected), bi noranzkoak onartzen dituztenak. Oro har, noranzko biko loturak erabiliko ditugu.   Parametro topologikoak azaldu ondoren, azter ditzagun orain sare nagusiak, hala estatikoak nola dinamikoak. Proposamen asko egin badira ere, gehien erabili edo erabiltzen direnak baino ez ditugu aztertuko.   6.3. KOMMUTAGAILUEN BIDEZKO SAREAK Konputagailu paraleloen komunikazio-sarearen eginkizuna prozesadoreen arteko (edo prozesadoreen eta memoriaren arteko) komunikazioa ahalbidetzea da, hau da, datuak garraiatzea. "Datuak" garraiatzeko sareak, ordea, aspaldi erabili izan dira beste teknologia-arlo batean: telefonoen bidezko komunikazioetan, alegia. Hala, hainbat urtetan metaturiko esperientzia zabal horretatik abiatuta, telefono-sareak osatzeko erabilitako kommutagailuak egokitu, eta multiprozesadoreetarako sare bereziak sortu dira: kommutagailuen bidezko sareak. Sare horiei sare dinamikoak ere deitu ohi zaie, iturburuaren eta helburuaren arteko komunikazio-bidea dinamikoki ezartzen baita komunikazio bat gauzatu behar denean (ez dago lotura finkorik nodoen artean). Azter dezagun konexio-sare horiek nola eratzen eta erabiltzen diren. 6.3.1. Kommutagailua (switch) Lehenik eta behin, ikus dezagun zer den kommutagailua, sare dinamikoak eraikitzeko "adreilua". Kommutagailu sinpleena (k= 2 gradukoa) bi sarrera eta bi irteera konektatzen dituen gailua da. Gailu horren bidez, eta dagozkion kontrol-seinaleen arabera, irudiko lau konexioak egin daitezke26.                   Lehenbiziko bi kasuetan, sarrera batean dagoen informazioa bi irteeretara zabaltzen da (broadcast deritzo komunikazio horri). Baina gehien interesatzen zaizkigun aukerak beste bi konexioak dira, non sarrera eta irteera bana konektatzen diren, jarraian edo gurutzatuta, informazioa garraiatzeko. Beste modu batez ikusita, sarreren "permutazio" bat lortzen da kommutagailuaren irteeran. Adibidez, bi sarrerako kommutagailu baten bidez, honako bi konexio hauek eraiki daitezke: (0, 1) â†’ (0, 1) edo, bestela, (0, 1) â†’ (1, 0), hau da, sarreretako bi permutazioak. Kommutagailuan egiten diren konexioak "dinamikoak" dira, denboran zehar aldatu egingo baitira, komunikazio-beharren arabera.   6.3.2. Crossbar sarea Lehen aipatu dugunez, sare onena Pi â†’ Pj komunikazio guztiak (ï€¢ i, j, hau da, iturburuen eta helburuen arteko edozein permutazio) batera, une oro, eta "urrats" batean ahalbidetzen dituena da. Egin dugun definizioaren arabera, P sarrerako kommutagailu batek funtzio hori betetzen du, P komunikazio-bide gauzatu baititzake, denak aldi berean. Sare horri crossbar ere deritzo. Crossbar-ak modu askotan eraiki daitezke, eskuarki kommutagailu sinpleagoak erabiliz. Irudian, 2 graduko kommutagailuak erabiliz lau prozesadore (edo lau prozesadore eta lau memoria-modulu) elkarren artean konektatzen dituen crossbar bat ageri da. Kommutagailuek errenkada eta zutabe bana konektatzen dituzte, eta aurrera jarraitzeko edo biratzeko aukera ematen dute.                 Irudian ageri denez, sare horrekin P bide desberdin (edozein) eraiki daitezke, aldi berean, iturburuak eta helburuak konektatzeko (jakina, ez da posible aldibereko bi bide helburu berera eraikitzea). Zoritxarrez, sare horren kostua oso handia da, baldin eta prozesadore kopurua handia bada, kommutagailu eta konexio kopurua (konplexutasuna) P2 ordenakoa baita; gainera, kontrol zentralizatua behar du. Eskuarki, crossbar sareak prozesadore kopuru ez oso handiko multiprozesadoreetan erabili izan dira, baina prozesadore kopuru handiko MPP sistemetan ere bai (adibidez, Earth Simulator konputagailua), zenbait kasutan kommutagailuak hainbat urratsetan (etapatan) antolatuta. 6.3.3. Urrats anitzeko sareak(multistage) Kommutagailuen kostua koadratikoki hazten da sarrera/irteera kopuruaren arabera. Hori dela eta, sarearen kostua murriztu ahal izateko (hau da, hardware gutxiago behar izateko), prozesadoreen arteko konexioak gauzatzeko beste egitura bat erabili behar da, nahiz eta, ondorioz, sarearen komunikazio- ahalmena crossbar batena baino txikiagoa izango den, eta paketeen latentzia handiagoa. Hala, sare dinamiko erabilienak "urrats anitzeko sareak" dira. Osagaiak konektatzeko erabiltzen diren kommutagailuak hainbat urratsetan (edo etapatan) antolatzen dira; hau da, konexioek kommutazio-eragiketa bat baino gehiago behar dute. Kommutazio-urrats baten irteerak hurrengo urratsaren sarreretara eramaten dira, tartean konexio-eskema jakin bat, permutazio bat, erabiliz; konexio- eskema horien arabera, sare desberdinak lortzen dira: perfect shuffle, butterfly, cube connection eta abar.                         Oharra. Noranzko bakar bateko sarea marraztu dugu (ezkerretik eskuinera irudian); bi noranzkoak behar badira (esaterako, memoria-moduluekin konexioak egiteko), nahiko da noranzko bateko bi sare gainjartzea.   6.3.3.1. Omega sarea Urrats anitzeko sareetako adibide gisa, ikus dezagun sare erabilienetako bat: Omega sarea. Posagaiko Omega sarean, logkP kommutazio-urrats daude, eta urrats bakoitzean P/k kommutagailu. Beraz, k graduko Omega sareak P/k Ã— logkPkommutagailu ditu, crossbar batek baino askoz gutxiago. Esaterako, 256 nodoko crossbar batek 2562 = 65.536 kommutagailu behar ditu (k = 2), eta tamaina bereko Omega sareak 128 Ã— 8 = 1.024 baino ez; ordainean, konexioen latentzia handiagoa da, 8 kommutazio-urrats gainditu behar direlako (bat bakarrik crossbar-ean). Kommutazio-urratsen arteko konexioak "tartekatze perfektu" (perfect shuffle) delako eskemaren arabera egiten dira, irudian ageri den moduan (bi sarrerako kommutagailuak erabiliz).                     Tartekatze perfektu izeneko konexio-eskema erraza da; 2 graduko Omega sarerako, P sarrerak erdibanatu, eta honela berrordenatu behar dira: bat lehenengo erditik (0), bat bigarren erditik (P/2), bat lehenengo erditik (1), bat bigarrenetik (P/2+1)... Beraz, permutazio hau egiten da:       Sarearen tamaina hazten den neurrian, gatazkarik gabeko komunikazioen ehunekoa oso txikia izaten da (P = 8 â†’ % 10; P = 16 â†’ % 0,02; dena den, balio absolutuak oso handiak dira). Hala ere, aplikazioen komunikazio-beharra ez da, eskuarki, zorizkoa, eta, ondorioz, permutazio batzuk besteak baino ohikoagoak dira (adibidez, Pi â†’ Pi+1 komunikazio mota oso arrunta da hainbat aplikaziotan). Horregatik, permutazio guztiak egin ezin daitezkeen arren, komunikazio-sare egoki batek permutazio erabilienak arazorik gabe egin beharko lituzke. Hori da, hain zuzen ere, Omega sarearen (eta antzeko sareen) kasua. Edonola ere, arazoak sortuko dituen komunikazio-eragiketa bat egin behar dela aurretik jakiten bada (esaterako, SIMD makina batean), komunikazio (permutazio) hori arazorik ez duten bi permutaziotan (bi fasetan) bana daiteke. Lehen aipatu dugun moduan, irtenbide bera erabili behar da sareko matxurei aurre egiteko.   Laburbilduz: Omega sarea "blokeakorra" (blocking network) da, ezin baititu aldi bereko edozein komunikazio "exekutatu", baina, hala ere, oso sare egokia da eta asko erabili da, nodo guztiak elkarren artean komunikatzeko aukera asko eskaintzen dituelako. 6.3.3.4. Beste komunikazio mota bat: broadcast-a Komunikazio mota ohikoak dira permutazioak hainbat aplikaziotan, baina badaude beste komunikazio-eskema arrunt batzuk. Esaterako, asko erabiltzen da broadcast izeneko komunikazioa: prozesadore batetik beste guztietara (i â†’ j, ï€¢j) bidaltzen da mezu bat. Modu sinplean egin daiteke komunikazio mota hori Omega sarean, oinarrizko eragiketa baita hori (sarrera bat bi irteeretara eramatea) kommutagailu bakoitzean. Beraz, nahikoa da aukera hori bide osoan zehar errepikatzea broadcast bat egiteko, hau da, mezu bat nodo batetik besteetara zabaltzeko. Esaterako, honela egiten da broadcast eragiketa P5 prozesadoretik:                 6.3.3.5. Beste zenbait sare Omega sareaz gain, urrats anitzeko sare asko proposatu eta erabili dira konexio-sare gisa multiprozesadoreetan. Erabiliena, agian, butterfly (tximeleta) izenekoa da. Irudian, 16 prozesadoreko butterfly sarearen bi eskema logiko ageri dira, bi graduko zein lau graduko kommutagailuak erabiliz.                 butterflysarea (k= 2)butterflysarea (k= 4) Butterfly eta Omega sareak oso antzekoak dira; esaterako, erraz egiazta daiteke bideratze-algoritmo bera erabil daitekeela bi sareetan, bideratze-erregistroa sortzeko xor funtzioa exekutatzen duena.   Butterfly eta Omega sareak blokeakorrak dira; dakigunez, crossbar sarea ez da inoiz blokeatzen (edozein komunikazio onartzen du, uneoro), baina bere kostua oso handia da. Hala ere, crossbar-ena baino hardware gutxiago behar duten eta blokeatzen ez diren sareak eraiki daitezke. Oro har, sare horiei Clos sareak deritze. Blokeatzen ez diren sareen artean, "birmoldagarriak" (rearrangeable) deitzen diren sareak daude, zeinetan bide bat aukera daitekeen beti komunikazio bat gauzatzeko, zenbait kasutan komunikazio-bideak berrantolatu behar badira ere. Sare horien adibide bat Benes sarea da: edozein permutazio onartzen du, baldin eta egin behar dena aldez aurretik jakiten bada (bide egokiak aukeratu ahal izateko), hainbat bide baitaude iturburu eta helburu bakoitza konektatzeko. Irudian, 16 nodoko Benes sarea ageri da. 7 kommutazio-urrats erabiltzen ditu (Clos motako sareetan, kommutazio-urrats kopurua bakoitia da). Sarean, hainbat bide daude bi nodo konektatzeko; adibidez, P3tik P11ra joateko bi bide desberdin marraztu ditugu. Jakina, sarearen kostua Omega sarearena baino handiagoa da, eta paketeen latentzia ere handiagoa da, kommutazio-urrats gehiago gainditu behar direlako. Benes sarea bitan tolestu egiten badugu, arbola (fat tree) izeneko topologia lortzen da, non paketeek aurrera, erroraino, eta atzera egiten duten helburura heltzeko (hau da, loturak noranzko bikoak dira).                     Benes sarea Arbola (fat tree) 6.3.3.6. Laburpena Busak dituen arazoak gainditzeko, kommutagailuen bidezko sareak egokiak izan daitezke. Sare horiek badute historia luzea dagoeneko paralelismoaren arloan. Hasieran, SIMD sistemetarako erabili ziren, zeinetan kontrol-unitateak programa baten aginduak sinkronoki exekutatzen dituen hainbat prozesadoretan. Zenbait aplikaziotarako â€”esaterako, irudien tratamendurako, matrize-kalkulurako...â€” eskema hori oso egokia da, lan-banaketa eta datu-ematea oso erregularra delako: datuen paralelismoa aprobetxatzen da. Gainera, datu-banaketa dela eta, komunikazio-eskema bereziak exekutatu behar dira maiz: permutazioak (esaterako, iâ†’ i+1), broadcast... MIMD ereduko multiprozesadoreetan ere erabili dira sare horiek, busa ordezkatzeko. Gaur egun, Clos motako sareak dira erabilienak, gehienetan fat tree moduko egituran (ikus hurrengo atala). Hurrengo taulan, konparazio xume bat egiten da bus, crossbar eta Omega sareen artean. Gatazkarik ez badago, komunikazioen latentzia busean konstantea da; Omega sarean, ordea, latentzia handiagoa da, P-ren funtzioa, hainbat kommutazio-urrats gainditu behar direlako. Baina, ordainean, komunikazio gehiago egin daitezke aldi berean: busa partekatu egin behar da prozesadore guztien artean (w/P), baina Omega sarean posible da prozesadore bezainbat komunikazio aldi berean gauzatzea (w) (birtualki, banda-zabalera handiagoa da). Hori bai, konplexutasunaren aldetik, Omega sarea bus soila baino askoz konplexuagoa da.      Pprozesadore /    wbiteko kanalak       kgraduko             Busa            Omega sarea         Crossbar-a    kommutagailuak     (O(x) =x-ren        ordena)            Latentzia    konstantea          O(logkP)           konstantea       Banda-zabalera   O(w/P) â†’ O(w)    O(w) â†’ O(wÃ—P)       O(wÃ—P)        prozesadoreko      Konexio kopurua       O(w)           O(wÃ—PÃ—logkP)         O(wÃ—P2)         Kommutagailu       O(P)           O(P/kÃ—logkP)           O(P2)              kopurua         Komunikazio-    banan-banan        permutazio      permutazio guztiak             ahalmena                   batzuk,broadcast...            Adibideak   Symmetry S-1        BBN TC-2000        Cray Y-MP/816                       Encore Multimax        IBM RP3         Fujitsu VPP500   6.4. MEZU BIDERAGAILUEN BIDEZKO SAREAK Ikusi berri ditugun urrats anitzeko sareetan, kommutagailuen arteko loturak "dinamikoki" ezartzen dira, komunikazio-beharren arabera. Sare horietan, multiprozesadoreko nodoak eta komunikazio-sarea bereizi egiten dira, ez daude nahastuta. Baina badago beste modu bat sarea osatzeko, non sistema paraleloaren nodo bakoitzak gailu berezi bat erabiltzen duen komunikazioa kudeatzeko; sare horiei sare estatikoak deritze. Sarea osatzeko, nodoen komunikazio- kudeatzaileak edo mezu-bideragailuak (router-ak) konektatu behar dira elkarren artean, aurrez definitutako topologia baten arabera. Mota horretako sareak dira erabilienak sistema paraleloetan, prozesadore kopurua handia denean batik bat.               6.4.1. Mezu-bideragailuak Lehen aipatu dugunez, prozesadoreen arteko komunikazioa mezuen bidez egiten da memoria banatuko konputagailuetan. Prozesadore batetik bestera mezu bat bidaltzeko, tokiko bideragailuari pasatzen zaio mezua, eta hortik, bideragailuz bideragailu, helburura bidaliko da.                   Aurreko irudian, mezu-bideragailu arrunt baten eskema logiko sinplifikatua ageri da. Batetik, hainbat sarrera- eta irteera-portu daude, sarea bera osatzeko, eta portu pare bat bertako prozesadorera konektatzeko. Bestetik, automata bat daukagu, sarrera-portu batean hartu den mezuarekin zer egin erabakitzeko: beste bideragailu batera transmititu, bertako prozesadorera pasatu, ilaratan gorde... Bidean zehar, litekeena da mezu bat blokeatuta geratzea, behar duen aterabidea libre ez dagoelako. Geroxeago azalduko ditugu arazo hori konpontzeko hartzen diren irtenbide nagusiak, baina ohikoa da bideragailuan hainbat buffer izatea, halako mezuak gordetzeko. Izan ere, mezu-bideragailua kommutagailu edo switch mota bat baino ez da, zertxobait konplexuagoa. Azken batean, lehen aztertu ditugun kommuta-gailuetan bezala, helburua sarrerak eta irteerak konektatzea da, mezuek aurrera egin ahal dezaten. Sarearen antolaketa dela-eta dira desberdinak bi gailu horien funtzioak. Eskuarki, mezu-bideragailua sarea osatzen duten nodoen beste osagai bat da, ez Omega sarean bezala, non kommutagailuak eta konputagailuak guztiz aparte baitoaz. Ondorio gisa, mezu-bideragailuak erabiltzen diren sareetan, mezuek ez dute distantzia bera korritu behar beti: nodo batzuk hurbil daude eta beste batzuk urrutiago. 6.4.2. Sare-topologia erabilienak Lehen ikusi dugunez, sarerik egokiena denok denekin "pauso" batean konektatzen dituena da, crossbar-a, irudikoa bezalakoa.           Argi eta garbi, topologia hori duen sarea zaila da eraikitzen prozesadore kopurua handia bada: lotura kopurua koadratikoki hazten da, eta nodoen konexio kopurua, gradua, oso handia da (eta ez da konstantea). Analizatu egin behar ditugu, beraz, beste aukera batzuk: oraingo sistema paraleloetan gehien erabiltzen diren sare-topologiak, hain zuzen ere. Gogoratu: nodo bakoitzean, konputagailu bat (edo, agian, sistema paralelo txiki bat) eta mezu-bideragailu bat dago. Kasu guztietan, nodoen arteko loturak bi noranzkokoak dira. 6.4.2.1. Dimentsiobakarrekosareak:kateaetaeraztuna (chain,ring) Makina errealetan erabiltzen ez badira ere, ikus ditzagun, adibide gisa, dimentsio bakarreko bi sare nagusiak: katea eta eraztuna.       katea eraztuna   Bi sareen gradua 2 da (bi lotura nodoko). Eraztuna erregularra (nodo guztien gradua bera da) eta simetrikoa da, baina katea ez. Hutsegiteekiko tolerantzia txikia da: nahikoa da lotura bat matxuratuta izatea katea deskonektatzeko; eraztunean, aldiz, bi lotura matxuratu behar dira. Bestalde, hauek dira sare horien distantzia-parametroak (P, prozesadore kopurua, zenbaki bikoitia; ikus kapituluaren eranskina):                                     diametroa           batez besteko distantzia                    katea â†          Pâ€“ 1          (P+ 1) / 3 â†’P/ 3                 eraztuna â†          P/ 2            P2/ 4(Pâ€“1) â†’P/ 4   Dimentsio bakarreko sareak ez dira egokiak prozesadore asko konektatu behar denean, baina erraz orokortzen dira bi, hiru edo dimentsio gehiagotara.   6.4.2.2. Mailak eta toruak(mesh,torus) Katea eta eraztuna n dimentsiotara zabaltzen badira, mailak eta toruak sortzen dira. Irudian, bi dimentsioko maila eta torua ageri dira. Irudikoak karratuak dira, baina prozesadore kopurua dimentsio bakoitzean edozein izan daiteke. Torua lortzeko, mailako ertzetako nodoak lotu egin behar dira, eraztunak osatzeko (ertzeko nodoak konektatzeko eskema aldatuz gero, topologia desberdinak sortzen dira). Oro har, n dimentsioko mailak edo toruak ditugu (eskuarki, n = 2 edo 3), eta dimentsio bakoitzean k nodo konektatzen dira (k > 2; k= 2 kasua berezia da eta hurrengo atalean analizatuko dugu). Beraz, sare osoaren nodo (prozesadore) kopurua P = kn da. Adibidez, bi dimentsioko kasuan, P = k2 (sarea karratua ez bada, k1 ï‚´ k2).                   Bi sareetako gradua 2n da (dimentsio bakoitzeko bi lotura), txikia eta nodo kopuruarekiko independentea. Torua erregularra eta simetrikoa da27, baina maila ez, nodo guztien gradua berdina ez delako (esaterako, mailako lau erpinetako prozesadoreek n lotura baino ez dituzte) eta, ondorioz, sareari buruzko ikuspuntu desberdinak lortzen dira nodo desberdinetatik. Hutsegiteekiko tolerantzia, bestalde, handia da, bide asko dagoelako nodoak komunikatzeko. Kasurik txarrenean, n lotura kendu behar dira mailan (erpin bateko nodo baten loturak) eta 2n toruan (bi dimentsiotan, edozein nodoren lau loturak) sarea hausteko; beraz, arku-konektibitatea n eta 2n da, hurrenez hurren. Baina, oro har, askoz lotura gehiago kenduta (matxuratuta) ere, sarea "lotuta" mantenduko da. Lotura kopurua dela eta, mailak nÂ Ã— knâ€“1 Ã— (k â€“ 1) lotura erabiltzen ditu, eta toruak, berriz, n Ã— kn. Sarea bi zati berdinetan banatzeko (erdibiketa), k lotura kendu behar dira mailan eta 2k toruan (eraztunak daudelako). Mailen eta toruen distantzia-parametroak honako hauek dira (k bikoitia; ikus eranskina):                                     diametroa           batez besteko distantzia                    maila â†       nÃ— (kâ€“ 1)       â†’                                                      nÃ— (k/ 3)                    torua â†         nÃ—k/ 2          â†’                                                      nÃ— (k/ 4)   Mailaren distantzia maximoa, dimentsio bakoitzean erpin batetik bestera doana da; toruan, ordea, inoiz ez da zeharkatu behar eraztunaren erdia baino pauso gehiago dimentsio bakoitzean. Zenbakiak sinplifikatuz (k handia den kasuetarako), mailaren batez besteko distantzia dimentsio bakoitzeko nodo kopuruaren herena da; toruarena, laurdena.   6.4.2.3. Hiperkuboak(hypercube) Hiperkuboakdimentsio bakoitzean bi nodo baino ez dituzten mailak dira; hori dela eta, n-kubo bitarra ere deitzen zaio. Irudian, 1, 2, 3 eta 4 dimentsioko hiperkuboak ageri dira. n dimentsioko hiperkuboa sortzeko, nâ€“1 dimentsioko bi hiperkubo sortu behar dira, eta bi hiperkubo horietan posizio berdinetan dauden nodoak lotu behar dira, banan-banan.                   Nodo bakoitzak n biteko helbidea du: (xnâ€“1, xnâ€“2, ..., x1, x0), eta helbidearen bit bakoitzak, 0 edo 1, dimentsio horretan nodoak okupatzen duen posizioa adierazten du. (xnâ€“1, xnâ€“2, ..., x1, x0) helbideko nodoa n nodo hauekin konek- tatuta dago: (/xnâ€“1, xnâ€“2, ..., x1, x0), (xnâ€“1, /xnâ€“2, ..., x1, x0), (xnâ€“1, xnâ€“2, ...,/x1, x0), (xnâ€“1, xnâ€“2, ..., x1, /x0) [/ = not]; hots, helbide-bit bakar batean bereizten diren nodoekin. Esaterako, 4 dimentsioko hiperkubo batean, 0000 nodoa 1000, 0100, 0010 eta 0001 nodoekin konektatuta dago. n dimentsioko hiperkuboak 2n nodo ditu; P nodo dituen hiperkuboa, beraz, log2P dimentsiokoa da. Sarearen gradua n da (log2P), dimentsio kopurua hain zuzen; beraz, ez da konstantea. Hiperkuboa simetrikoa eta erregularra da. Lotura kopurua handia da,(P/2) Ã— log2P hain zuzen ere, eta, ondorioz, hutsegiteekiko tolerantzia oso handia da hiperkuboetan; arku-konektibitatea n da (nodo jakin baten n loturak kendu behar dira sarea hausteko). Hiperkuboaren erdibiketan P/2 lotura daude; izan ere, horrela eraikitzen da hiperkuboa, erdi bat beste erdiarekin banan-banan konektatuz. Hauek dira hiperkuboaren distantzia-parametroak (ikus eranskina):                                      diametroa          batez besteko distantzia                 hiperkuboaâ†           n               nÃ— 2nâ€“1/ (2nâ€“1) â†’n/ 2   Distantzia maximoa dimentsio kopurua da, dimentsio bakoitzean gehienez pauso bat eman daitekeelako, eta, prozesadore kopurua handia denean (n handia denean), batez besteko distantzia dimentsio kopuruaren erdia da. Hiperkuboak baditu bi desabantaila nabarmen. Batetik, sarearen gradua ez da konstantea, hazi egiten baita nodo kopuruaren arabera; eta horrek esan nahi du prozesadore (edo, hobeto, mezu-bideragailu) bakoitzaren lotura kopurua ezin dela aldez aurretik zehaztu. Beraz, ez da erraza sarea zabaltzea, aldatu egin behar baitira sareko osagai guztiak (edo aurreikusi, hasieratik, balizko hazkundea). Gainera, tamaina handiko hiperkuboak eraikitzea ez da batere erraza, konexio-multzoa konplexua eta trinkoa delako. Bestetik, ezin da edozein tamainatako hiperkuboa osatu, prozesadore kopuruak 2ren berretura izan behar baitu. Esaterako, 512 edo 1.024 prozesadoreko hiperkuboak eraiki daitezke, baina ez 800ekoa. Mailak, toruak eta hiperkuboak topologia klase orokorrago baten kide gisa interpreta daitezke: k-ary n-cube izenekoa, hain zuzen ere. Sare horiekndimentsiokoak dira, eta dimentsio bakoitzean k nodo dago. Dimentsio bateko nodoak eraztun batez lotzen dira (edo agian kate batez), eta, eskuarki, loturak noranzko bakarrekoak dira; esaterako, 4Ã—4-ko torua 4-ary2-cube sarea izango litzateke.   6.4.2.4. Arbolak eta arbola sendoak(fat tree) MPP sistemetan asko erabiltzen den beste konexio-sare bat arbola da. Aukera bat baino gehiago dago arbola osatzeko, baina hau da erabiliena: prozesadoreak arbolaren hostoetan kokatzen dira, eta mezu-bideragailuak (edo, agian, kommutagailuak) arbolako gainerako adabegietan, hurrengo irudian ageri den moduan. Arbolaren gradua kda, adabegi bakoitzetik sortzen den adabegi kopurua, hain zuzen ere (adi, kasu honetan graduak ez du lotura kopurua adierazten). Beraz, arbola baten sakonera edo maila kopurua logkP izango da. Irudian, arbola bitarrak, k= 2, ageri dira.                   Berez, sarea ez da erregularra; erroko eta beheko bideragailuek bi lotura baino ez dituzte, eta tartekoek, aldiz, hiru. Hala ere, prozesadoreak hostoetan bakarrik badaude, prozesadoreek sareari buruz duten irudia berdina da posizio guztietan, eta, ondorioz, sarea simetrikoa litzateke. Mezu-trafikoa kontuan harturik, arbola oso sare desorekatua da. Adibidez, eskuineko erdiko edozein prozesadore ezkerreko erdiko beste edozein prozesadorerekin komunikatzeko, arbolaren erroan dagoen bideragailua erabili behar da; beraz, trafiko handia izango da inguru horretan. Gainera, goiko lotura matxuratzen bada, sarea deskonektatu egiten da. Arazo hori gainditzeko, MPP sistemetan erabiltzen diren arboletan, lotura zein bideragailu kopurua (komunikazioa kudeatzeko hardwarea, beraz) gero eta handiagoa da arbolan gora, errorantz, mugitzen garen neurrian, aurreko irudian ageri den moduan. Hala, komunikazio-ahalmen edo banda-zabalera handiagoa izango da komunikazio-trafiko handiago espero den tokietan. Arbola-egitura horieiarbola sendoak(fat tree) deritze. Hala, arbola sendo baten erdibiketa P/2 da, erroko adabegiaren lotura kopuruaren erdia (arbolaren erdi batekin konektatzen dituztenak). Azkenik, hauek dira arbolaren distantzia-parametroak (k = gradua; ikus eranskina):                                     diametroa           batez besteko distantzia                    arbolaâ†        2 logkP                                                      â†’ 2 log2Pâ€“ 2 (k= 2)   Kommutagailuen bidezko sareetan, Omega sarean, adibidez, oso garbi bereizi ditugu sarea osatzen duten osagaiak: batetik, prozesadoreak daude, eta, bestetik, kommutagailuak, eta ez dago zuzeneko erlaziorik haien artean. Sare estatikoen kasuan, ordea, prozesadore bakoitzak (edo, agian, multzo txiki batek) mezu-bideragailu pribatu bat erabiltzen du mezuak kudeatzeko. Analizatu ditugun arbolek sare dinamikoen itxura hartzen dute, prozesadoreak hostoetan baino ez daudelako; gainerako nodoak mezuak kudeatzeko bakarrik erabiltzen dira. Izan ere, frogatu daiteke arbola sendoak eta butterfly sareak isomorfoak ("antzekoak") direla (arbola sortzeko, nahikoa da bi butterfly sare kontrako noranzkoan gainjartzea). Ohiko butterfly sareetan beharrezkoa da sare osoa zeharkatzea helburuetara heltzeko (distantzia beti bera da), baina, aipatu dugun egitura dela eta, arboletan ez da beharrezkoa kasu guztietan erroraino joatea, atzera egin daitekeelako tarteko bideragailuetan (eta horrela bidea motzagoa da).   6.4.2.5. Topologien laburpena Aurreko paragrafoetan, oraingo MPP sistemetan gehien erabiltzen diren sare- topologien ezaugarri nagusiak azaldu ditugu. Aztertu ditugun sare guztien, estatikoen zein dinamikoen, ezaugarri topologiko nagusiak laburbildu ditugu hurrengo taulan. Argiago ikusteko, distantzia- parametroak sinplifikatuta daude, prozesadore kopurua handia eta bikoitia den kasurako.     P= prozesadore kopurua;n= dimentsio kopurua;k= kommutagailuen edo arbolaren              gradua, edo dimentsio bakoitzeko prozesadore kopurua.              Prozes. Gradua Erreg./  Loturak(ï‚´w)     dbb      D max  Erdib. Arku-                           Simetr.    [Komm.]                                konek. Crossbar-a    P     Pâ€“1   bai       P(Pâ€“1)        1         1     P2/4   Pâ€“1      Omega    P      k      bai    P(logkP+ 1)      logkP     logkP    --     --                                   [(P/k) logkP]      Maila  P=kn     2n     ez     n knâ€“1(kâ€“1  ~ n k/3   n(kâ€“1) knâ€“1  n      Torua  P=kn     2n     bai        n P         ~ n k/4    n k/2  2knâ€“1  2n Hiperkuboa  P=2n     n      bai     (P/2) logP      ~ n/2       n     P/2     n                    (logP)     Arbola    P      k      bai       PlogkP     ~ 2 logkPâ€“2logkP   P/2     1 (fat tree)                                         2/(kâ€“1)   Aurrerago ikusiko dugunez, komunikazio-sarearen distantzia-parametroak garrantzitsuak izan daitezke komunikazio azkarra lortu ahal izateko. Adibide gisa, hurrengo taulak diametroa eta batez besteko distantziak erakusten ditu, sare jakin batzuetan. Adibidez, 1.024 prozesadoreko makina batean, hiperkuboaren batez besteko distantzia toruarena baino 3 bider eta mailarena baino 4 bider txikiagoa da. Hala ere, arazo larri bat dauka hiperkuboak: gradua (lotura kopurua) handia da oso. Esaterako, 1.024 nodoko hiperkuboan, prozesadoreek 10 lotura erabili behar dituzte beste prozesadoreekin konektatzeko; bi dimentsioko toruan eta mailan, aldiz, nahikoa da 4 lotura izatea.       D/d(b.b.)                    Nodoak(prozesadore kopurua)                     16            64          256         1.024       16.384      2D Maila    6 / 2,7       14 / 5,3    30 / 10,7    62 / 21,3   254 / 85,3      2D Torua    4 / 2,13      8 / 4,06    16 / 8,03     32 / 16     128 / 64    Hiperkuboa    4 / 2,13      6 / 3,05     8 / 4,02     10 / 5       14 / 7        Arbola    8 / 6,53     12 / 10,19   16 / 14,06    20 / 18     28 / 26     (bitarra)   Hainbat kasutan, sarearen topologia "hierarkikoa" da: topologia jakin bat duen sareko nodoak ez dira prozesadore hutsak, baizik eta SMP sistemak edo beste topologia duten MPP sistemak. Esaterako, makina baten sarea hiperkuboa bat izan daiteke 64 prozesadore arte, eta, hortik aurrera, arbola bat, non nodoak hiperkuboak diren. Edonola ere, segur asko sare hierarkiko erabilienak nodoetan 4-8 prozesadoreko SMP sistemak dituztenak dira.   6.4.2.6. Lotura fisikoak Kommutagailu edo mezu-bideragailuez gain, link edo lotura fisikoak behar dira sarea osatzeko. Hainbat motatakoak izan daitezke loturak, makinaren ezaugarrien arabera:   â€¢ Luzeak edo motzak. Kableak luzeak badira, posible izango da balio bat baino gehiago loturetan batera izatea (esaterako, LAN batean). Motzak direnean, balio bakar bat eroango dute une jakin batean. Konexio digital gisa, transmisio- denbora kableko karga-denbora da kable motzetan, bi muturretan balio bera izan artekoa. Denbora hori logaritmikoki hazten da kable-luzerarekin. Kableak luzeak direnean, ordea, transmisio-denbora lineala da luzerarekiko.   â€¢ "Estuak" edo "zabalak". Loturak bit batekoak (seriekoak) edo gehiagokoak izan daitezke: esaterako, 4, 8, 16... bitekoak. Noski, zabalagoak diren neurrian, azkarragoa izango da mezuen transmisioa. Zenbait makinatan, lotura horietako bit batzuk kontrolerako eta beste batzuk datuetarako erabiltzen dira.   Bestalde, komunikazioa sinkronoa (erloju-seinale global bat erabiliz) zein asinkronoa (puntutik punturako protokoloak erabiliz) izan daiteke. Loturenkomunikazio-ahalmenaadierazteko,banda-zabalera (bandwidth) erabiltzen da, eskuarki (Mega) Gigabit/s-tan; esaterako, 10 Gb/s-ko loturak. Azkenik, loturak kobrezko pare bihurritua (arrunta telefonian), kable ardazkidea (arrunta LAN-etan), edo zuntz optikoa (gero eta usuago) erabiliz egin daitezke.   6.5. KOMUNIKAZIOA SAREAN ZEHAR Komunikazioaren euskarri fisikoa da sarea, ez besterik; horren gainetik, logika egokia eraiki behar da mezuak prozesadore batetik bestera eraman ahal izateko. Komunikazio-sare baten portaera analizatzeko, haren topologiaz gain, beste gai asko Aztertu behar dira: nola osatzen da bidea (switching strategy)? nondik heltzen dira mezuak helburura (routing algorithm)? beti bide bera erabili behar da? nola doaz aurrera mezuak? zer egin behar da bidea okupaturik badago (flow control)? Erabaki horiek guztiak hartzean, sistemaren eraginkortasuna kontuan hartu behar da, komunikazio-latentzia txikia eta mezu-emaria handia izan daitezen. 6.5.1. Mezuak Sistema paraleloaren egituraren arabera, prozesadoreen artean bidali behar den informazioa hainbat modutan antola daiteke. Aldagai partekatuak erabiltzen badira, komunikazioa rd/wr eragiketen bidez egiten da; hots, kontrol-mezu txikiak gehi datuak. Komunikazioa mezuen bidez egiten denean, mezuak luzeagoak eta egituratuagoak dira. Bestalde, sareak garraia ditzakeen mezuen tamaina edo luzera mugatua da. Bidali behar den informazioa tamaina hori baino luzeagoa bada, mezua hainbat paketetan banatu beharko da (eskuarki tamaina finkoko paketeak). Hiru eremu hauek bereiz daitezke pakete arruntetan: â€¢ Goiburukoa: paketea identifikatzen duen kontrol-informazioa da, non, informazio gehiagorekin batera â€”paketearen luzera, pakete mota, lehentasuna...â€”, helburu-helbidea edo hara heltzeko hartu beharreko bidea (routing record) adieraziko den.   â€¢ Payload edo datu-karga: berez transmititu behar diren datuak dira.   â€¢ Bukaera: kontrol-informazio gehiago â€”paketearen bukaera, checksum motako kode bat transmisio-erroreak detektatzeko (arruntagoa da LAN-etan MPP-etan baino), eta abarâ€”.          kontrol-inf.                datuak                 kontrol-inf.          bukaera                                           goiburukoa   Beraz, kontrol-informazioa eta datuak bereizten dira paketeetan. Bideragailuen arteko loturak zabalak badira (bit askokoak), kontrol-informazioa eta datuak paraleloan eraman daitezke. Adibidez, Cray T3D makinan, loturak 24 bitekoak dira: 16 bit datuetarako eta 4 kontrolerako (beste laurak jarioa kontrolatzeko). Kontroleko lau biten bidez adierazten da, esaterako, pakete baten transmisioa noiz hasten den, noiz bukatzen, eta abar. Cray T3E makinan, aldiz, bidali behar den informazioa paketetan banatzen da (framing). Paketeak kontrolatzeko sartzen den informazio guztia (goiburukoa, checksum...) gainkarga gisa hartu behar da, eta eraginkortasun-galera ekarriko du; beraz, ahalik eta mugatuena mantendu behar da. Esaterako, 100 byte datu bidaltzeko 128 byteko paketea bidali behar bada, banda-zabaleraren 100 / 128 = % 78 besterik ez da aprobetxatuko (informazio baliagarria transmititzeko). Transmisiorako erabiltzen diren loturen "zabalera" bit batetik (serieko transmisioa, gutxitan erabili dena) 16 biterainokoa izan ohi da (bit gehiagokoak ere badaude); zenbait kasutan, beraz, "transmisio-ziklo" bat baino gehiago beharko da pakete baten "unitate logiko txikiena" hartzeko. Paketeen kontrola kontuan hartuta, transmititzen den informazioa flit-etan banatu ohi da. Testuinguru honetan, honela definitzen da flit-a: esanahia duen informazio kantitate minimoa, eskuarki paketea bideratzeko erabili behar dena. Adibidez, serieko transmisioa erabiltzen bada, pakete baten aurreneko bita hartuta, ezin dugu ezer esan pakete horri buruz; bit gehiago hartu beharko ditugu nora doan jakin ahal izateko. Paketeak, beraz, flit-etan banatzen dira; sareko konexio-loturak 8 edo 16 bitekoak izan ohi direnez, ohikoa da flit bat ere 8 edo 16 bit izatea, paketea bideratzeko nahikoa informazio kodetu daitekeelako 1 edo 2 bytetan; hala izanik, flit bat "ziklo" batean transmitituko da ondoz ondoko bi mezu- bideragailuren artean. 6.5.2. Norekin eta noiz komunikatu behar da? Komunikazio-patroiak. Ezin diogu erantzun zehatzik eman galdera horri, komunikazioaren beharra exekutatzen ari den aplikazioaren araberakoa izango baita. Hala ere, merezi du kontzeptu batzuk argitzea. Lehenik eta behin, kontuan hartu behar da bi gauza desberdin direla aplikazio jakin baten prozesuen arteko komunikazio-eskema logikoa eta sarean benetan gauzatuko dena, tartean prozesuak prozesadoreetara banatzeko estrategia dagoelako. P1 eta P2 prozesuek informazioa trukatu behar badute, egoera oso desberdina izango da bi prozesu horiek alboz alboko bi prozesadoretan edo sareko bi muturretan exekutatzen badira. Beraz, gai asko kontuan hartu behar ditugu: aplikazioaren beharrak, prozesuen banaketa, paralelizatze-maila, eta abar. Aplikazio jakin baten komunikazio-beharrari komunikazio-patroia deitu ohi zaio. Komunikazio-patroia espaziokoa edo denborakoa izan daiteke; hots, paketeak nora doazen edo noiz bidaltzen diren adieraz dezake. Azter ditzagun ohiko kasu batzuk.   1. Zorizko komunikazioa Sare bat analizatzeko asko erabiltzen den komunikazio-patroietako bat zorizko komunikazioa da, hala espazioan nola denboran. Komunikazioa zorizkoa da, baldin eta i-ren eta j-ren arteko komunikazio-probabilitatea â€”KPijâ€” edozein i etaj- tarako berdina bada (pakete-trafikoa homogeneoki banatzen da sarean zehar). Hala gertatzen denean, komunikazio-patroiaren batez besteko distantzia eta sarearena (topologiarena) berdinak dira. Komunikazioaren zoritasuna lor daiteke, neurri batean behintzat, prozesuak prozesadoreetara zoriz banatzen badira. Trafikoa homogeneo bihurtzen denez, hainbat kasutan oso irtenbide egokia da hori sareko baliabideak ahalik eta ongien erabiltzeko.   2. Distantziaren araberako komunikazioa Prozesuen arteko komunikazioak, memoria-atzipenekin gertatzen den legez, ingurutasuna izeneko propietatea du. Prozesuak multzoka komunikatzen dira elkarren artean; multzoen barruan, komunikazioa maiz sortzen da, baina multzoen artean noizbehinka baino ez. Komunikazioaren latentzia laburtzeko asmoz, egokia izan daiteke prozesu multzo horiek hurbil dauden prozesadoreetara banatzea, eta, hala, komunikazioa sarearen eremu jakin baten barruan geratuko da. Halako komunikazio-patroietan, beraz, komunikazio-probabilitatea distantziaren funtzioa da. Denboran zehar, bestalde, zorizkoa izan daiteke komunikazioa. Hurrengo irudian, adibide batzuk ageri dira; Y ardatzean, Pi â†’ Pj komunikazioko probabilitatea ageri da, eta X ardatzean, i â†’ j distantzia.     KP                                       distantzia   3. Broadcast / Multicast / Reporting Komunikazioko beharrak espazioan zein denboran zehar analizatu behar dira. Komunikazio mota ezagun bat broadcast (barreiatze) izenekoa da: i prozesadoretik mezu bat bidali behar da prozesadore guztietara, aldi bertsuan. Komunikazio-eragiketa ez da bukatutzat ematen harik eta mezua toki guztietara barreiatu den arte. Oso eragiketa arrunta da; esaterako, datuak zabaltzeko edo prozesuak sinkronizatzeko. Une jakin batean, beraz, trafiko handia sortzen da. Multicast izeneko kasuan, komunikazioa ez da gainerako prozesadore guztiekin egiten, azpimultzo batekin baizik. Broadcast eta multicast motako komunikazioak modu eraginkorrean betetzeko hainbat algoritmo dago (spanning tree...), baina ez ditugu aztertuko. Reporting izeneko komunikazio-eredua kontrako kasua da; hots, prozesadore guztietatik prozesadore jakin batera bidali behar dira mezuak, aldi bertsuan. Zaila da halako komunikazio-eskaera egoki betetzea, mezu guztien helburua den prozesadorearen inguruan trafiko handia izango dugulako, eta, ondorioz, loturak eta bideragailuak ase egingo direlako. Kasu horretarako ere, badaude algoritmo eraginkorrak (combining messages...) latentziaren eta trafikoaren arazoak gutxiagotzeko.   4. Matrize iraulia, FFT,perfect shuffle... Kalkuluko zenbait aplikazio ezagunek komunikazio-patroi bereziak sortzen dituzte; esaterako, matrizeak iraultzekoa, Fourier-en transformatu diskretua, eta abar. Patroi horietan, komunikazioa une jakin batzuetan kontzentratzen da; une horietan, pakete-trafikoaren dentsitatea hazi egingo da, agian sare-eremu batzuk ase egingo dira, eta, ondorioz, paketeen latentzia handiagoa izango da. Hala ere, asetze-une zehatzak baino ez dira izango (ezin zaio eutsi denboran zehar trafiko-dentsitate handi horri) eta sareak gauza izan beharko du trafikoa jaitsi ahala egoera normala berreskuratzeko.  Mezuen tamaina da aplikazioek sortzen duten komunikazioaren beste ezaugarri bat: luzeak, txikiak, denetarikoak...? Parametro hori kontuan hartuz, bi paralelismo mota bereizi ohi dira. Batetik, ale xeheko paralelismoa dugu: mezuak txikiak dira (10 â€“ 1.000 byte) eta komunikazioak maiz egiten dira. Beste muturrean, ale larriko paralelismoa dugu: mezuak luzeagoak dira (1 kB - 100 kB), baina haien maiztasuna askoz txikiagoa da. Datu-paketeekin batera, kontrol-pakete asko ere izango ditugu sarean (koherentzia mantentzeko, prozesuak sinkronizatzeko...). Aurrekoen aldean, kontroleko paketeak txikiagoak dira eskuarki. Beraz, oro har, tamaina askotariko paketeak izango ditugu batera sarean. Hori dela eta, sarearen baliabideak ahalik eta modurik eraginkorrenean kudeatzeko, zenbait komunikazio-sistematan paketeak bereizi egiten dira hainbat motatan â€”esaterako, txikiak eta handiak, edo datukoak eta kontrolekoakâ€” eta desberdin tratatzen dira; adibidez, pakete txikiek (kontrolekoek) lehentasuna dute tarteko mezu-bideragailuetan aurrera jarraitzeko (are gehiago, zenbait sistemetan, konexio-sare desberdinak erabiltzen dira datuak eta kontrol- informazioa garraiatzeko). 6.5.3. Bidea eraikitzea(switching strategy) Mezu bat transmititu behar da prozesadore batetik beste batera. Iturburutik helburura doan sareko bide bat erabili behar da horretarako; baina, nola osatzen edo "eraikitzen" da bide hori? Bi estrategia erabil daitezke hori egiteko:   1.Zirkuitu-kommutazioa (circuit switching) Datu-komunikazioarekin hasi baino lehen, bi prozesadoreak lotuko dituen bide osoa eraiki behar da. Horretarako, kontrol-mezu berezi bat bidaltzen da helburura, zunda gisa, eta mezu horrek erabiltzen dituen konexioak (bidea) erreserbatu egiten dira. Helburura heltzean, kontrol-mezu bat bidaltzen da atzera, iturbururaino, dagoeneko eraiki den bidetik, transmisioa baieztatzeko. Baieztapen-mezu hori hartu ondoren, datuak bidaliko dira, eraiki berri den bide pribatua erabiliz. Denbora behar da bidea eraikitzeko, baina, bidea eraikita, informazio-ematea azkarra izango da, loturen banda-zabalera osoa mezu horretarako erabiliko da eta. Izan ere, estrategia hori interesgarriagoa da, baldin eta bidea eraikitzeko behar den denbora oso txikia bada, mezua transmititzeko behar den denborarekin alderatuta (telefono-deietan gertatzen den bezala). Zirkuitu-kommutazioa erabiltzen denean, ez da beharrezkoa mezuak paketetan banatzea (esaterako, ez ditugu tarteko bufferrak erabili beharko bidea "okupatuta" dagoelako). Hala ere, egon adi; mezua oso luzea bada, denbora luzez mantenduko dira okupatuta komunikazio-kanalak, eta kanal horiek erabili behar dituzten beste mezuen latentzia asko haziko da; egoera hori ezin da onartu, eskuarki, konputazio paraleloko testuinguruetan. Komunikazio mota horren adibide ezaguna telefoniakoa da. Makina komertzialen batean erabili da (adibidez, Intel iPSC2 multikonputagailuan, edo Meiko CS- 2 eta BBN butterfly multiprozesadoreetan), baina ez da ohiko aukera MPP sistemetan.   2. Pakete-kommutazioa (packet switching) Komunikazioa ez da egiten aldez aurretik erreserbatutako bide pribatu bat erabiliz. Hori egin beharrean, paketeak sarera bidaltzen dira, eta, bideragailuz bideragailu, bide bat aukeratuko dute helburura heldu arte, paketeetan doan kontrol-informazioa erabiliz (postan gertatzen den bezala). Bidean zehar, tarteko mezu-bideragailuek paketeak hartu, helburuari buruzko informazioa prozesatu, eta hurrengo mezu-bideragailura bidaliko dituzte, edo, helburura heldu badira, saretik atera eta bertako prozesadoreari pasatuko dizkiote. Horrela doaz paketeak MPP sistemetan. Helburuari buruzko kontrol-informazioak erraza izan behar du interpretatzen; prozesu horretan ezin da denbora galdu, komunikazio eraginkorra â€”paketeen latentzia txikiaâ€” izatea nahi bada behintzat. Hurrengo atalean aztertuko dugu informazio hori nola adierazi. Bestalde, mezuak paketetan banatzen direnez, gainkargaren bat sortzen da komunikazioan, pakete bakoitzak kontrol-informazio guztia eraman behar baitu. Beraz, arrazoiren bat izan ezean, ez da interesgarria mezuak oso pakete txikitan banatzea. Oro har, paketeen tamaina maximoa bidean zehar paketeak gordetzeko dauden bufferren tamainarekin erlazionatuta dago.  6.5.4. Mezuak bideratzea(routing) Komunikazio-sarea zeharkatu behar dute paketeek helburura heltzeko. Nondik, baina? Bi gai analizatu beharko genituzke. Batetik, nola adierazi pakete baten helburu-helbidea, eta, bestetik, helburura heltzeko egongo diren bide askoren artean nola aukeratu bat. Nolanahi ere, eta tartean beste arazorik ez badago, luzera minimoko bideak erabili behar dituzte paketeek helburura heltzeko (paketeak ez dira inoiz helburutik urrunduko). Ikus dezagun bi arazo horiek nola tratatu.   6.5.4.1. Bideratze-erregistroa Pakete-kommutazioa erabiltzen denean, prozesadoreak bertako mezu-bideragailuari pasatuko dizkio paketeak, sareko baliabideak erabiliz helburuetara hel daitezen (postan, gutunekin egiten dugun moduan). Iturburutik helburura joateko, paketeak berak daraman kontrol-informazioa, goiburukoa, erabili behar da. Nola adierazi behar da zein den paketearen helburua? Nola prozesatu behar da informazio hori sarean zehar? Oro har, paketeak aurreratzeko hartzen diren erabakien multzoari paketeen bideratzea (routing) deritzo. Sare egoki batean, erraza izan behar du paketeak bideratzeak (bide bat aukeratzea). Helburuari buruzko informazioa emateko, bi dira aukera erabilienak:   â€¢ Helburu-helbidea bera adierazten da paketearen goiburukoan; tarteko mezu- bideragailu bakoitzean, informazio hori irakurriko da paketea nondik atera behar den erabakitzeko. Erabaki hori hartzeko, bi aukera daude: (a) taula bat erabiltzea, non adieraziko diren irteera-portu egokiena(k) helburu bakoitzera heltzeko; edo (b) funtzioren bat exekutatzea helburu-helbidearekin, irteera- portu bat esleitzeko.   â€¢ Helburura heltzeko, dimentsio bakoitzean zenbat pauso eman behar diren zehazten da paketearen goiburukoan, bideratze-erregistro (routing record) izeneko atalean. Pauso bakoitzean, paketearen bideratze-erregistroa egokitu behar da (Â±1); paketea helburura heldu da bideratze-erregistroko eremu guztiak 0 direnean.   Modu batera zein bestera, bide-aukeraketak azkarra izan behar du, ezin baita denbora gehiegi galdu sareko tarteko bideragailuetan, paketeen latentzia txikia mantenduko bada. Bideratze-erregistroak erabili ohi dira paketeek hartuko dituzten bideak adierazteko; beraz, ikus dezagun nola kalkulatzen diren paketeen bideratze- erregistroak dagoeneko aztertu ditugun sareetan.   a. Mailak. Pj nodoa identifikatzeko, ohikoa da sareko koordenatuak erabiltzea (dimentsio bakoitzean okupatzen duen posizioa)28. ndimentsioko maila batean (k nodo dimentsioko), X(xnâ€“1, xnâ€“2, ..., x1, x0) nodotik Y(ynâ€“1, ynâ€“2, ..., y1, y0) nodora joateko, yi â€“ xi pauso eman behar dira i dimentsioan(positiboa, noranzko batean; negatiboa, bestean). Hori bera da, bada, paketeen goiburukoan adieraziko dena:   BE = [ynâ€“1 â€“ xnâ€“1, ynâ€“2 â€“ xnâ€“2, ..., y1 â€“ x1, y0 â€“ x0]   Ikus dezagun adibide bat bi dimentsiotan:   (1, 0) nodotik (3, 3) nodora:   BE0= 3 â€“ 0 = 3 BE1= 3 â€“ 1 = 2   BE= [2, 3]   Paketea sarean aurrera doan neurrian, goiburukoan doan bideratze-erregistroa eguneratu behar da tarteko bideragailuetan; esaterako, aurreko adibidean, marra lodiz markatutako bidea aukeratzen bada, honela aldatu beharko da bideratze- erregistroa, pauso bakoitzean:   [2, 3] â†’ [2, 2] â†’ [2, 1] â†’ [2, 0] â†“ [1, 0] â†“ [0, 0]   Beraz, pauso bakoitzean unitate batean eguneratzen da bideratze-erregistroko osagai jakin bat (dimentsio horri dagokiona). Osagai guztiak 0 direnean, paketea helburura heldu da.   b.Toruak. Prozedura berari jarraitu behar zaio, baina orain kontuan hartu behar da sareko dimentsio bakoitzean eraztun bat dugula. Eta eraztun batean beti daude bi bide puntu batetik bestera joateko: aurretik eta atzetik. Jakina, bide motzena aukeratu behar da. Beraz, k nodoko eraztunean ez da inoizd = k/2 pauso baino gehiago eman behar noranzko batean; hala behar denean, hobe da k â€“ d pauso ematea kontrako noranzkoan, bidea motzagoa baita. Beraz, aurreko kasuan bezala kalkulatu behar da bideratze-erregistroa, eta, gero, bide minimoa egokitu. Oro har, X(xnâ€“1, xnâ€“2, ..., x1, x0) nodotik Y(ynâ€“1, ynâ€“2, ..., y1, y0) nodora joan behar bada, honela lortzen da bideratze- erregistroa:   for i = 0 to n-1 do; dimentsio guztietarako begin BE i= Yiâ€“ Xi ; bideratze-erregistrokoiosagaia if (|BE i| > k/2) then; egokitu bidea, luzeegia delako if (BE i> 0) then BE i= BEiâ€“ k else BE i= BEi+ k end  Adibidez, bi dimentsiotan:   (1, 0) nodotik (3, 3) nodora   BE0= 3 â€“ 0 = 3 3 > 2 â†’ 3 â€“ 4 = â€“1 BE1= 3 â€“ 1 = 2   BE= [2, â€“1] Lehen bezala, bideratze-erregistroa eguneratu egin behar da sarean ematen den pauso bakoitzean; adibidean: [2, â€“1] â†’ [2, 0] â†’ [1, 0] â†’ [0, 0].   c. Hiperkuboak. Sare hauetan ere mezuen bideratzea sinplea da. Hiperkuboa kubo bitarra da: dimentsio bakoitzean bi prozesadore baino ez dago, 1 eta 0 etiketadunak. Dimentsio bakoitzean okupatzen dituen posizioekin, prozesadore baten koordenatuak lortzen dira. Definizioz, beraz, i-tik j-ra joateko, dimentsio jakin bat zeharkatu behar da, baldin eta dimentsio horri dagokion bita bi prozesadoreen koordenatuetan desberdina bada. Esaterako, (0001) nodotik (0100) nodora joateko, bi pauso eman behar dira, lehen eta hirugarren dimentsioetan, helbideak bi bit horietan bereizten baitira. Beraz, bideratze-erregistroa kalkulatzeko, iturburuko eta helburuko helbideen arteko xorfuntzioa egin behar da, bitez bit:   BE = [iturburu-helb. xorhelburu-helb.]   Adibidez, (0010) nodotik (1100) nodora joateko:   BE= 0010xor1100 =[1110]   Hau da, hiru pauso eman behar dira, 2, 3 eta 4 dimentsioetan, irudian ageri den moduan. Pauso bakoitzean, dimentsio horri dagokion bita 0 bihurtu behar da bideratze- erregistroan:   [1110]â†’[1100]â†’[1000]â†’[0000]   d. Arbolak. Arboletan ere ez da zaila paketeak bideratzea. Lehenik, arbolan zein mailataraino igo behar den erabaki behar da (iturburu- eta helburu- helbideen konparaketa baten ondorioz), eta, gero, helburura heltzeko zein adarretatik jaitsi behar den (eskuarki helburu-helbide bera erabiliz). Ariketa gisa uzten dugu nola sortu eta erabili behar den paketeen bideratze-erregistroa arboletan.   6.5.4.2. Bide-aukeratzea: estatikoa edo moldakorra Pakete bat tarteko bideragailu batera heltzen denean, haren goiburukoa analizatu behar da, bertako prozesadorera doan edo beste prozesadore batera joan behar duen jakin ahal izateko, eta, horretarako, bideratze-erregistroa aztertu behar da. Bideratze-erregistroaren osagai guztiak 0 direnean, paketea helburuan dago: saretik atera eta bertako prozesadoreari eman behar zaio; bestela, aurrera jarraitu beharko du sarean. Bideratze-erregistroa definituta ere, eskuarki bide asko izango ditugu iturburutik helburura joateko. Esaterako, maila batean bina pauso eman behar badira X eta Y ardatzetan â€”BE = [2, 2]â€”, sei aukera hauek izango ditugu pauso horiek emateko: x-x-y-y, x-y-x-y, x-y-y-x, y-x-x-y, y-x-y-x, eta y-y-x-x. Zein bide aukeratu? Beti bide bera aukeratu behar da?   â–ª Bideratze estatikoa   Paketeen bideratzea estatikoa da, baldin eta i prozesadoretik j prozesadorera doazen pakete guztiek beti bide bera hartzen badute, sareko trafikoaren egoera edozein izanik ere. Aukera erabiliena DOR (dimension order routing) izeneko bideratzea da: eman pauso guztiak dimentsio batean, gero hurrengoan, eta abar (bi dimentsioko kasuan, "lehenik-X-gero-Y" ere deitzen zaio). Beraz, bideratze estatikoak i eta j nodoen artean dauden bide guztietatik bakar bat erabiltzen du. Bide bakar bat erabiltzen denez, behe-mailako hutsegiteekiko tolerantzia galdu egiten da; aurrera jarraitu ezin bada, matxura bat dela medio, beste mailako algoritmoak erabili beharko dira komunikazioa bete ahal izateko.   â–ª Bideratze moldakorra edo dinamikoa   Paketeen bideratzea dinamikoa da, baldin eta iprozesadoretik j prozesadorera doazen paketeek beti bide bera egiten ez badute, eta bidea sareko egoeraren arabera aukeratzen bada. Bideratze dinamikoa malguagoa da, eta aukera ematen du bide gutxi erabiliak hartzeko, trafiko handiko eremuak saihesteko. Adibidez, irudian hiru aukera ageri dira (1,0) nodotik (3,3) nodora joateko (marra lodiz, DOR motako bidea). Hiruetan, bideratze-erregistroa bera da: BE = [2, 3]. Esaterako, (1, 1) prozesadorearen inguruan trafiko handia badago, agian egokiagoa litzateke (b) bidea (a) bidea baino. Ideia bera erabil daiteke sareko matxurak saihesteko: (1, 2) â†’ (1, 3) lotura matxuratzen bada ere, oraindik baditugu aukerak (3, 3)-ra heltzeko, (c) bidea erabiliz.                 Aukera asko dago moldaketa egiteko. Ezagunenetako bat "sigi-saga" izenekoa da: paketeek, aukeran, txandakatu egiten dituzte dimentsio desberdinetako pausoak (ez dituzte agortzen dimentsio bateko pauso guztiak). Hala, bi bide edo gehiagoren artean hautatzeko aukera, trafiko-arazoak saihesteko, bukaera arte mantentzen da. Bi dimentsioko kasuan, honelako algoritmoa erabil daiteke bidea aukeratzeko:   baldin (|BEx|>|BEy|) orduan Segi_X_ardatzetik ;X+,X- bestela Segi_Y_ardatzetik ;Y+,Y-  baldin (aukeratutako_irteera_okupatuta) orduan Saiatu_bestea ; aukera badago   Bideratze moldakorrak abantailak izan ditzake, baina, beti bezala, gal daitekeena ere baloratu behar da. Maiz, bideratze moldakorra apustu baten ondorioa da; esaterako, une jakin batean irteera bat ezin bada erabili, okupatu dagoelako, beste bide batetik aurrera jarraitzea erabakitzen da. Zoritxarrez, erabaki hori hartzeko oso informazio partziala erabiltzen da, tokiko trafikoa bakarrik, eta ez dakigu zer-nolako egoera aurkituko dugun aukeratu den bide berrian (agian txarragoa). Trafikoaren egoera sare osoan homogeneoa bada, segur aski zuhurrena bide jakin bati eustea da. Hala ere, sarea ez-simetrikoa denean edo trafikoa modu homogeneoan banatzen ez denean, erraza da trafiko oso handiko eremuak (hot spots) agertzea, eta kasu horietan eraginkorra izan daiteke bideratze moldakorra. Bestalde, mezu luze bat bidaltzeko osatzen diren paketeak iturburutik helburura bide desberdinetatik badoaz, litekeena da desordenan heltzea, eta, ondorioz, lan gehiago izango da helburuan jatorrizko mezua osatzeko, eta kontrol- informazio gehiago eraman beharko dute paketeek (adibidez, pakete zenbakia). Horrez gain, mezu-bideragailuek konplexuagoak izan behar dute bideratze moldakorra erabili ahal izateko, eta, adi! paketeak prozesatzeko denbora luzeagoa izango dela esan nahi du horrek. Azkenik, laster aztertuko dugunez, bideratze moldakorra erabiltzen denean blokeo-egoerak ager daitezke sarean (deadlock): paketeak ez dira gauza aurrera jarraitzeko, bidea elkarri blokeatzen dietelako. Beraz, bideratze moldakorra erabiltzea eztabaidagarria da.   â–ª Bideratze ez minimoa   Paketeek erabiltzen dituzten bideak luzera minimokoa izan behar badute ere, zenbait kasutan egokia (edo beharrezkoa) izan daiteke bide luzeago bat hartzea, dela trafiko handiko gune bat saihesteko, dela, batik bat, sareko matxurak gainditzeko. Adibidez, pakete bat (1, 0) prozesadoretik (3, 2) prozesadorera doa; (1, 2) mezu-bideragailuan dagoela, ezin duela aurrera jarraitu detektatzen du, (2, 2) nodoko mezu-bideragailuak erantzuten ez duelako (matxuratu egin da). Aukeran, luzeagoa den beste bide bat har daiteke, irudian ageri den moduan, komunikazioa gauzatu ahal izateko.                 Oro har, bide minimoak erabiliko dituzte paketeek iturburutik helburura joateko, eta salbuespen gisa hartuko dugu bide ez minimoak erabiltzea, eskuarki hutsegiteen aurrean irtenbideren bat izateko. 6.5.5. Informazio-jarioaren kontrola (flow control) Bideragailuz bideragailu doaz paketeak, sarean zehar, helburura heldu arte. Baina, nola transmititzen dira paketeak bideragailuen artean? Eta zer egin behar da aurrera jarraitzeko erabili behar den irteera okupatuta badago, beste pakete bat transmititzen ari delako? Bestela esanda, nola kontrolatzen da paketeen (informazioaren) jarioa sarean? 6.5.5.1. Mezuak aurrera joateko teknikak: SF, WH, CT Nola pasatzen da paketea bi mezu-bideragailuren artean? Demagun komunikazio- loturak byte batekoak direla; beraz, "komunikazio-ziklo" batean byte bat igaroko da bideragailu batetik hurrengora. Paketeak, ordea, luzeagoak dira, eta, beraz, transmisio-ziklo asko beharko da pakete osoa (byte guztiak) hurrengo bideragailura transmititzeko. Bitartean, zer egin behar da hartzen ari diren datuekin? Azter ditzagun pakete-jarioa kudeatzeko erabiltzen diren bi aukera nagusiak: store-and-forward etawormhole / cut-through izenekoak.   6.5.5.1.1 Store-and-forward(SF)   Lehen belaunaldiko multikonputagailuetan, store-and-forward deritzon estrategia erabiltzen zen paketeak transmititzeko (teknika arrunta, bestalde, LAN eta WAN sareetan).                           Estrategia hori erabiltzen denean, pakete osoa transmititzen da ondoz ondoko bi bideragailuren artean erabaki bat hartu baino lehen; pakete osoa hartu denean, goiburukoa analizatzen da nora doan jakiteko, eta, horren arabera, bertako prozesadoreari edo hurrengo bideragailuari pasatuko zaio. Paketea hartzen ari den bitartean, bideragailuko buffer batean gordetzen da. Une oro, bi bideragailuk baino ez dute parte hartzen pakete baten transmisioan (ikus hurrengo irudia). Lehenbiziko hurbilpen gisa, pakete baten transmisio-denbora proportzionala izango da pakete-tamainarekiko (L) eta bide-luzerarekiko (d), L flit transmititu behar direlako, d aldiz:   Tsf~ L Ã— d   Zeharkatu behar den distantzia bikoiztu egiten denean, beraz, gauza bera egiten du paketearen latentziak ere.   6.5.5.1.2. Wormhole (WH) eta Cut-through (CT)   SF komunikazio-estrategia ez da oso egokia MPP sistemetarako, komunikazioaren latentzia, zeharkatu behar den distantziaren arabera, handia izan daitekeelako; komunikazioa, ordea, aplikazioen exekuzio paraleloaren parte garrantzitsua da, eta ahalik eta azkarren bete behar da. Hori dela eta, oraingo sistema paraleloetan wormhole (WH) edo cut-through(CT) izeneko komunikazio-teknika erabiltzen da.                   Pakete baten goiburukoaren (kontrola, bideratze-erregistroa...) lehen flit- a bideragailu batera heltzen denean, prozesatu egiten da nora doan jakiteko. Aurrera jarraitu behar badu, dagokion irteera-portua aukeratu eta paketea birbidaltzeari ekiten zaio, pakete osoa bideragailuan izan arte itxaron gabe; paketearen gainerako flit-ak aurrenekoa bidali den bide beretik bidaliko dira, hartu ahala (ikus hurrengo irudia). Hala, paketearen flit-ak sarean zehar zabaltzen dira, bideragailuz bideragailu: komunikazioa "segmentatu" egin da, bideragailu askok parte hartzen baitu, aldi berean, pakete baten transmisioan. Paketearen goiburukoaren aurreneko flit-a helburura heltzeko, d "ziklo" behar dira; gero, zikloz ziklo, mezuaren gainerako flit-ak etorriko dira atzetik. Beraz, sinplifikatuta, honela adieraz daiteke pakete baten transmisio-denbora cut-through / wormhole moduan:   Tct/wh~ L + d   Argi eta garbi, latentzia txikiagoa da modu honetan, L eta d biderkatu beharrean batu egiten direlako; paketeak zeharkatu behar duen distantziaren eragina askoz txikiagoa da CT/WH moduan SF moduan baino.   Wormhole edo cut-throughmoduan, paketeen transmisioa berdin egiten da; baina pakete baten goiburukoak aurrera jarraitu ezin badu, behar duen irteera okupatuta dagoelako (beste pakete bat ari da transmititzen), irtenbidea desberdina da bi kasuetan:   â–ª Wormhole. Geldiarazi egiten da pakete osoaren transmisioa, eta, horrela, paketearen flit guztiak blokeatuta geratzen dira, sarean zehar, hainbat bideragailutan. Behar den irteera askatzen denean, paketearen transmisioari ekingo zaio berriro bideragailu guztietan. Adi; aukera hori erabiltzen denean, paketeen flit-ek sareko baliabide asko mantenduko dute okupatuta aurrera jarraitu ezin badute, eta, ondorioz, trafiko- gatazkak areagotu egingo dira.                       â–ª Cut-through. Paketearen goiburukoa geldituta badago ere, jarraitu egiten da gainerako flit guztiak hartzen, eta bideragailuko buffer batean gordetzen dira, paketeak behar duen irteera libre izan arte. Une horretan, bideragailuak paketea berriro transmititzeari ekingo dio. Hala, aurrera jarraitu ezin dezakeen paketeak ez ditu sareko baliabideak okupatuko, eta ez du beste paketerik geldituko.                     Cut-through erabiltzen denean, mezu-bideragailuek bufferrak izan behar dituzte paketeak aldi batean gorde ahal izateko; wormhole erabiltzen bada, aldiz, memoria-espazio hori ez da beharrezkoa (nahikoa litzateke flit baterako tokiarekin). Makina askotan, WH eta CT komunikazio moduen arteko "nahastea" erabiltzen da: ez dago pakete osoa gordetzeko tokia, baina bai, ordea, flit bat baino gehiago metatzeko bufferrak (esaterako, pakete baten 4 flit gorde daitezke bideragailuan, irteera-portua askatzen den bitartean). Sareko trafiko-mailaren arabera, CT teknika WH eta SF tekniken arteko erdibide gisa interpreta daiteke. Trafikoa oso baxua denean, CT-k WH-k bezala jokatzen du: oso baliabide-gatazka gutxi izango dira, eta, beraz, paketeak ez dira tarteko bideragailuetan metatuko. Aldiz, trafiko handiko egoeretan, CT SF-ra hurbiltzen da: gatazkak ohikoak dira bideragailuetan, paketeek ezin dute aurrera segi eta bertan gorde egin behar dira.   6.5.5.2. Baliabide-gatazkak: paketeetarako bufferrak Baliabide partekatua da komunikazio-sarea, noski, eta hainbat paketek erabiliko du sarea une oro. Beraz, trafiko-maila handia den neurrian, gatazkak izango dira bideragailuetan paketeen artean, aurrera jarraitzeko irteera baten bila. Aipatu dugun bezala, era desberdinetan tratatzen dira gatazka horiek; esaterako, CT moduan, aurrera jarraitu ezin dezakeen paketea bideragailuko buffer batean gordetzen da, baina WH moduan sarean bertan uzten da, blokeatuta. CT (eta, definizioz, SF) kasuetan, beraz, memoria apur bat erabili behar da bideragailuetan paketeak (edo agian pakete baten flit batzuk) aldi batean gordetzeko, harik eta irteera-bidea libre izan arte. Eskuarki, ez dugu espero bideragailuetan memoria asko izatea, ez behintzat edozein trafiko-gatazka konpontzeko adina, baizik eta byte edo pakete batzuk gordetzeko ahalmena soilik. Adibidez, paketeak 64 bytekoak badira, nahikoa izan daiteke kanal bakoitzeko 1 edo 2 kB-ko â€”16 edo 32 paketekoâ€” memoria izatea (agian zerbait gehiago, baina ez, esaterako, 1 MB-ko memoria bat, ezin baita onartu, oro har, 16.000 pakete blokeatuta izatea tarteko bideragailu batean). Gainera, mezu- bideragailuen funtzionamenduak eraginkorra eta azkarra izan behar du, paketeen latentzia ahalik eta txikiena izan dadin, eta, horretarako, bideragailuak ahalik eta sinpleenak izatea da egokiena. Aukera bat baino gehiago dago memoria edo buffer horiek egituratzeko eta kudeatzeko (eskuarki buffer ilara gisa eta FIFO moduan), eta bakoitzak abantailak eta desabantailak ditu. Bestalde, nahi den buffer kopurua izanda ere, litekeena da, aplikazio bat exekutatzean, une jakin batean trafiko handia sortzea eta, tarte baterako bada ere, buffer horiek beteta geratzea; zer egin behar da orduan? Azter ditzagun banan-banan, gaingiroki bada ere, arazo horiek.   â–ª Bufferren egitura: partekatuak edo banatuak   Mezu-bideragailuen memoria-espazioa partekatua izan daiteke, edozein sarreratatik heldu diren paketeetarako, edo sarreren (edo irteeren) artean banatu egin daiteke, sarrera horietatik heltzen diren paketeetarako bakarrik29.           buffer partekatuak buffer banatuak   Memoria-espazioa partekatua bada, paketeak gordetzeko edukiera eraginkorrago erabiltzen da, tokia dagoelako, edozein paketetarako, bideragailuaren memoria guztia agortu arte; bideragailuaren sarreretan banatuta badago, ordea, litekeena da sarrera baten bufferrak beteta geratzea (eta beraz, pakete gehiago ez onartzea) nahiz eta beste sarreretan tokia izan. Baina, bestalde, sarrera eta irteera guztietarako memoria komun bat kudeatzea zailagoa da, hala paketeak kargatzeko nola ateratzeko: sarrera anitzeko memoria behar da, erakusle askorekin, pakete bat baino gehiago (eta luzera desberdinekoak) kargatu beharko ditugulako, aldi berean eta hainbat ziklotan zehar; irteerak ere portu anitzekoa izan behar du, aldi berean pakete bat baino gehiago atera ahal izateko. Beti bezala, eraginkortasunaren eta konplexutasunaren arteko erdibidea bilatu behar da. Hainbat sistematan, paketeek lehentasun desberdinak dituzte; adibidez, komunikazio-sarea partekatu egiten da datuak eta kontrol-informazioa garraiatzeko, eta kontrol-paketeak (edo pakete txikiak) datu-paketeak (edo pakete luzeak) baino lehentasun handiagokoak dira. Kasu horietan, bideragailuko bufferrak ez dira FIFO moduan kudeatzen, edo, baliokidea dena, ilara desberdinak erabiltzen dira lehentasun-maila desberdineko paketeetarako.   â–ª Bufferrak sarreretan edo irteeretan   Paketeak gordetzeko bufferrak bideragailuen sarreretan edo irteeretan koka daitezke, hau da, bideratze-funtzioa exekutatu baino lehen edo exekutatu eta gero. Sarreretan kokatuta badaude, paketeak bufferretan gordetzen dira heldu ahala, behar duten irteera libre ez badago edo beste pakete batzuk zain badaude. Aldiz, irteeretan badaude, lehenik, paketeari dagokion irteera erabakitzen da (bideratzea edo routing-a egiten da), eta, gero, beharrezkoa bada, bufferretan gordetzen da.           bufferrak sarreretan bufferrak irteeretan   Abantailak eta desabantailak argi daude. Sarreretan badaude, bufferren kudeaketa errazagoa da, baina paketeen kudeaketa ez da oso eraginkorra (sarrera bakoitzean, pakete batek atzetik etorri direnak blokea ditzake, nahiz eta horiek behar duten bidea libre izan). Irteeran badaude, ordea, paketeen kudeaketa eraginkorragoa da, blokeatu baino lehen dagozkien irteeretara bideratu direlako, baina, ordainean, buffer ilaren egitura konplexuagoa da, sarrera asko eduki behar baitituzte (sarrera askotatik etor daitezke paketeak irteera jakin batera).   â–ª Eta buffer ilarak betetzen badira?   Nahiz eta ohiko egoera izan behar ez duen, trafiko handiko uneak ager daitezke aplikazio baten exekuzio paraleloan; une horietan, paketeen arteko gatazkak areagotu egingo dira bideragailuetan, eta litekeena da bufferrak agortzea: ezin izango da pakete gehiago onartu. Nola kontrolatu egoera hori? Oro har, kontrol-protokolo arrunt bat erabiltzen da ondoz ondoko bideragailuen artean (link flow control). Pakete bat bideragailu batetik bestera pasatu nahi denean, lehenik baimena eskatzen da; onarpena heltzen denean, paketearen flit- en transmisioari ekingo zaio. Hartzaileak paketea gordetzeko tokirik ez badu, ordea, ez du transmisioa baimenduko, eta paketeak ezin izango du aurrera jarraitu (bidenabar, antzeko komunikazio-protokoloren bat gauzatu behar da paketeak WH moduan transmititzeko).           Hala, back-pressure izenaz ezagutzen den egoera sortzen da: ezin dira paketeak transmititu, bufferrak bete egingo dira, eta atzera zabalduko da paketeak transmititzeko ezintasuna; azkenik, prozesadoreek utzi egin beharko diote pakete gehiago sarean injektatzeari, sarearen egora "normala" (trafiko gutxiago) berreskuratu arte. Ildo berean, zenbait makinatan, mugatu egiten da prozesadoreek bidal dezaketen pakete kopurua, pakete-uholdeak gertatuko ez direla ziur izateko. Onartutako pakete kopuru hori helburura heldu denean, helburuko prozesadoreak baimen-mezu bat bidaliko dio igorleari, pakete gehiago bidali ahal dezan (handshake global bat). Antzeko ideia erabiltzen da, esaterako,token ring (eraztun lekukoduna) protokolo ezaguneko kasuan: paketeak sarera injektatu ahal izateko, prozesadoreak lekukoa eduki behar du. Kontrol-mezu berezia da lekukoa, eta sarea ziklikoki zeharkatzen du, prozesadore guztiek paketeak bidaltzeko aukera izan dezaten. Badaude beste teknika batzuk ere datuen jarioa kontrolatzeko eta gainezkatzeak saihesteko30. Esaterako, pakete bat bideragailu batera heltzen bada eta paketea hartzeko tokirik ez badago, dagokion buffer ilara beteta dagoelako, atera egiten da buffer ilaratik pakete bat eta beste bideragailu batera desbideratzen da, heldu den paketerako tokia uzteko. Estrategia hori erabiliz, jakina, beti "dago" paketeak hartzeko tokia, baina zenbait pakete atzera bidaliko dira, bide luzeagoa egin beharko dute, eta, beraz, latentzia handiagoa nozituko dute. Hainbat estrategia erabil daitezke desbideratuko den paketea hautatzeko; esaterako, zoriz, edo agian sarean daramaten denboraren arabera, edo helbururako distantziaren arabera, etab. Adibidez, chaos router izeneko mezu- bideragailuak erabili du teknika hori.  Laburrean: bideragailuak â€”sarrera- eta irteera-portuak, bufferrak, bideratze- automataren logika, jarioaren kontrola, lehentasunak...â€” funtsezkoak dira multikonputagailuen komunikazio-sisteman; paketeak latentzia minimoarekin garraiatu behar direlako, eta sareak gauza izan behar duelako pakete asko prozesatzeko. Oro har, arlo honetan ere erabilgarria da arau ezaguna: sinpleena da azkarrena.   6.5.6. Komunikazioaren eraginkortasuna: mezuen latentzia eta mezu-emaria. Sistema paralelo baten komunikazio-baliabideak â€”sarea, mezu-bideragailuak, sare-interfazeak, protokoloak...â€” bitartekoak baino ez dira prozesadoreen arteko komunikazioa gauzatu ahal izateko. Komunikazioa prozesuen exekuzioaren beste atal bat denez, multikonputagailuen komunikazio-azpisistemak ahalik era eraginkorrena izan behar du. Bi dira komunikazio-sistemen kalitate-parametro nagusiak: paketeen latentzia (latency) eta mezu-emaria (throughput). Latentziak pakete baten komunikazio- denbora definitzen du: behar den denbora igorletik hartzailera heltzeko. Mezu- emaria, berriz, sareak kudea dezakeen pakete kopurua da (helburuetara garraiatzen dituenak, ase egin gabe). Sarea egokia da, baldin eta mezu kopuru handia latentzia txikiaz kudeatzeko gauza bada. Eraginkortasuna analizatu baino lehen, zehaztu ditzagun definizio batzuk: â€¢ Loturen_zabalera: lotura batek paraleloan transmiti dezakeen bit kopurua da; esaterako, 8 bit edo 16 bit (edo, beste muturrean, bit bat, serieko loturetan). Bit kopuru horri phit (physical unit) ere deritzo.   â€¢ Transmisio-zikloa: phit bat transmititzeko behar den denbora da. Sistema sinkronoetan, eskuarki ziklo bat da (erloju-ziklo bat).   â€¢ Loturen_banda-zabalera: segundo batean transmiti daitekeen informazio kopurua da,eskuarki(Mega) Gigabit/s-tan(109bit/s). Adibidez, 10 Gb/s-ko loturak.   â€¢ Banda-zabalera_erabilgarria: bidali behar den informazioa paketetan egituratzen da, eta pakete horietan badugu gainkarga bat, datuez gain goiburuko eta abarreko kontrola sartu behar baita. Beraz, n datu-bit transmititzeko, n + nk bit transmititu behar dira. Hala, erabilgarria den banda-zabalera n/ (n+ nk) izango da. Jakina, nk ahalik eta txikiena izatea interesgarria da.   â€¢ Bideratze-denbora (routing time, tr): bideragailuetan, pakete baten goiburukoa prozesatzeko behar den denbora da (nondik atera behar den jakiteko). Nabarmen, ahalik eta txikiena izan beharko luke.   Ikus dezagun nola modela daitekeen paketeen transmisio-denbora.   6.5.6.1. Sareko komunikazio-denbora Paketeak bideragailuz bideragailu doaz helburura heldu arte. Pakete baten transmisio-denbora parametro askoren araberakoa izango da: sareko topologia, aukeratutako bidea, paketeak aurreratzeko metodoa, jarioaren kontrola..., eta, jakina, mezu-trafikoa. Lehenik eta behin, trafikorik gabeko kasua analizatuko dugu. Sinplifikatzeko, demagun flit = phit = byte dela. Parametro hauek kontuan hartuko ditugu:   â€¢ L: pakete baten tamaina, bytetan â€¢ d: iturburutik helburura doan bidearen luzera â€¢ tr: bideragailuetan goiburukoa prozesatzeko behar den denbora â€¢ B: loturen banda-zabalera   Pakete baten transmisio-denboraâ€”latentziaâ€”paketeakaurrera eramateko erabiltzen den teknikaren araberakoa da, SF edo CT/WH.   6.5.6.1.1. Store-and-forward Aipatu dugunez, transmisioa store-and-forward moduan egiten bada, tarteko bideragailuetan pakete osoa hartu behar da birtransmititu baino lehen. Hori dela eta, bideko pauso bakoitzean, paketea transmititzeko edo hartzeko denbora â€”L/Bâ€” eta paketearen goiburukoa prozesatzeko denbora â€”trâ€” behar dira. Honela eman daiteke, beraz, pakete baten latentzia31:   Tsf = d Ã— (L/B + tr)   Latentzia proportzionala da zeharkatu behar den distantziarekiko eta paketearen tamainarekiko (d Ã— L): distantzia bikoizten bada, latentzia ere bikoiztu egingo da.   6.5.6.1.2. Cut-through/ Wormhole Transmisio modu honetan, paketearen goiburukoa aurrera doa, bideragailuz bideragailu, helbururaino, eta atzetik paketearen gainerako byteak (flit-ak) datoz. Honela adieraz daiteke, beraz, pakete baten latentzia:   Tct = d Ã— (1/B + tr) + (Lâ€“1)/B  hau da, goiburukoa (flit= byte bat) d aldiz transmititu eta prozesatu behar da, eta, azken bideragailuan, paketearen gainerako byteak (Lâ€“1) hartu behar dira32. Kasu honetan, beraz, latentzia d + L motakoa da: distantzia bikoizten bada, latentzia ez da bikoiztuko.  Paketea aurrera eramateko SF erabili behar bada, biziki interesatzen zaizkigu distantzia-parametro txikiko sareak. Horixe zen aurreneko belaunaldiko multikonputagailuen kasua. Oraindik SF erabiltzen zenez, hiperkuboa izan zen aukeratutako sarea. Zoritxarrez, hiperkuboak desabantaila nabarmenak ditu. Gradua handia da eta sarearen tamainaren arabera hazten da, eta, ondorioz, zailagoa da edozein saretarako baliagarria izango den komunikazio-modulua diseinatzea (zenbat sarrera- eta irteera-portu izan behar ditu?). Horrez gain, kable-dentsitatea oso handia da hiperkuboan, eta asko zailtzen du horrek sarea plano batean eraikitzea. Azkenik, ezin da edozein tamainatako hiperkuboak eraiki, prozesadore kopuruak biren berretura izan behar baitu (256, 512, 1.024...). Zailtasunak zailtasun, topologia hori aukeratu zen, haren distantzia-parametroak oso onak direlako. Teknologia eta esperientzia aurrera joan ziren neurrian, SF teknika utzi egin zen eta CT/WH jario mota eraginkorragoak inposatu ziren; hala, pakete batek egin behar duen bidearen luzera ez da hain kritikoa. Hori dela eta, topologikoki sinpleak eta dimentsio baxukoak (2 edo 3) diren sareak dira erabilienak gaur egun. Konparazio baterako, 256 byteko pakete baten latentzia maximoa eta batez bestekoa ageri dira hurrengo taulan, ziklotan, 1.024 nodoko 3 saretan (sarea hutsik dagoenean), CT eta SF moduan. Goiburukoaren aurreneko flit- a prozesatzeko denbora, tr, ziklo bat da (ziklo bat = 1/B, byte (flit) bat transmititzeko denbora).                              Hiperkuboa(210)    Torua(32 Ã— 32)  Maila(32 Ã— 32)                 diametroa         10                32               62         batez best. dist.         5                 16               22                       Tmax       2.570        8.224            15.934  SF                   Tbb       1.285        (+ % 289)        (+ % 520)                                              4.112            5.654                                              (+ % 220)        (+ % 340)                      Tmax        275         319              379  CT/WH                Tbb        265         (+ % 16)         (+ % 38)                                              287              299                                              (+ % 8)          (+ % 13)   Garbi azaltzen denez, CT jario mota erabiltzen bada, latentzia maximoa 275etik 379raino baino ez da igotzen hiperkubotik mailara, % 38 hain zuzen ere, maila baten diametroa hiperkuboarena baino sei aldiz handiagoa den arren. Gehikuntza txikiagoa da batez besteko latentzian, % 13 bakarrik, 265etik 299raino igo baita. Toruaren kasuan, gehikuntzak txikiagoak dira: %Â 16 maximoan, eta % 8 batez bestean).   6.5.6.2. Trafikoa kontuan hartuz Sareko baliabideak prozesadore guztien artean partekatzen direnez, trafikoa hazten denean, paketeek ez dituzte beti libre aurkituko behar dituzten baliabideak, eta, ondorioz, gelditu egingo dira, eskuarki bideragailuetako bufferretan, harik eta baliabidea (irteera-portua, lotura...) askatzen den arte; beraz, paketeen latentziak hazi egingo dira. Ezin da modelatu modu sinplean sare baten portaera trafikoa dagoenean. Oro har, komunikazio-sareak modelatzeko, ilara-teoria eta bezero/zerbitzari eredua erabiltzen dira. Modelo horien emaitza gisa paketeek bufferretan itxaron behar duten denbora, bufferren okupazioa, eta abar lortzen dira. Hala ere, MPP baten komunikazio-sarearen ohiko portaera, latentzia eta mezu- emaria direla eta, hurrengo irudietan ageri da (batez besteko distantziak).                   Hasieran, trafiko gutxi dagoenean, paketeak dagokien denboran heltzen dira helburuetara, atzerapenik gabe; bideragailuen bufferrak hutsik daude. Trafikoa hazten den neurrian, komunikazioaren latentzia ere hazi egiten da, pixkanaka, gatazka bakan batzuk gertatzen direlako: pakete batzuk bideragailuen bufferretan gorde egingo dira ziklo batzuetan (hortaz aparte, bufferrak ia hutsik daude). Baina trafikoa gehiegi hazten bada, gatazkak areagotu egiten dira eta sarea ase egiten da: ezin du mezu kopuru handi hori kudeatu, bufferrak bete egiten dira, eta paketeen latentzia mugagabe hazten da. Egoera horri ezin zaio luzaro eutsi eta, aukeran, saihestu egin behar da. Mezu-emaria, hau da, sareak segundoko "prozesatzen" duen mezu kopurua analizatzen bada, aurreko irudiko portaera ikusten da. Trafikoa kudeatzeko arazorik ez dagoenean, sareari pasatzen zaizkion mezu guztiak heltzen dira haien helburuetara (portaera lineala da). Baina, trafiko-maila jakin bat gaindituz gero, sareak ezin izango du pakete gehiago garraiatu: throughput maximoan gaude, asetze-mailan, paketeetarako bufferrak beteta daude, eta paketeen latentzia mugarik gabe haziko da. Zenbait saretan, trafiko-eskaerak asetze-maila gainditzen duenean, garraiatzea lortzen den pakete kopurua jaitsi egiten da; hau da, sarea ez da gauza trafiko maximoa mantentzeko. Portaera hori oso txarra da: une jakin batean trafiko- maila oso handia bada, eta sarea paketez betetzen bada, asko kostatuko da egoera normala berreskuratzea, trafiko jaitsitakoan. Komunikazio-sarea diseinatzen denean, garrantzitsua da onar daitekeen trafiko maximoa aurreikustea. Izan ere, sarea asetze-puntutik urrun egoteko dimentsionatu behar da. Hala ere, beti gerta daiteke aplikazio jakin batek mezu kopuru oso handia sortzea une jakin batean. Trafiko-maila hori ezin da denbora asko mantendu sarea gainezkatu gabe(sarearen ahalmena gainditzen du), baina, hala ere, sareak gauza izan beharko luke uneko uholde horiek kudeatzeko (agian, latentzia handiagorekin) eta, trafiko-maila bere onera datorrenean, ahalik eta azkarren egoera normalera itzultzeko (une jakin batean trafiko-maila handia izan arren, sareak ez du betiko blokeatuta geratu behar).   6.5.6.2.1. WH versus CT Ikusi dugunez, wormhole eta cut-through komunikazio-moduen artean dagoen desberdintasun bakarra gatazken tratamenduan datza: pakete batek aurrera jarraitu ezin badu, sarean geratzen da luze-luze (WH), edo bildu egiten da, zikloz ziklo, goiburukoa gelditu den tarteko bideragailuan (CT). Portaera horiek paketeen latentzian zein sarearen mezu-emarian islatzen dira. WH moduko komunikazioan, logikoa denez, latentzia lehenago hazten da trafikoarekin, blokeatuta dauden paketeek sareko baliabide asko okupatuta mantentzen dutelako eta, ondorioz, paketeen arteko gatazkak areagotu egiten direlako. Beraz, sareak kudea dezakeen pakete kopuru maximoa txikiagoa da: sarea lehenago asetzen da.                 6.5.6.3. Mezu-emari maximoa Aipatu dugunez, sare bati eskatu behar zaion kalitate-parametro nagusietako bat mezu-emaria da: sareak pakete kopuru ahalik eta handiena onartu beharko luke. Izan ere, kudeatu behar den batez besteko mezu kopurua txikia izanda ere, litekeena da une jakin batzuetan paketeak transmititzeko eskaera asko izatea, eta sareak gauza izan beharko luke eskaera horiei erantzun egokia emateko. Sare batek ase gabe kudea dezakeen mezu kopurua edo throughput-a parametro askoren araberakoa da: komunikazio-patroiak, sarearen topologia, mezu- bideragailuen egitura, jarioaren kontrola... Hala ere, topologiaren ikuspuntua bakarrik kontuan hartuz, mezu-emari maximoaren "hurbilpen" bat kalkula daiteke. Demagun prozesuen arteko komunikazioa zorizkoa dela, hala denboran nola espazioan: prozesadore batetik bidaltzen diren paketeak homogeneoki banatzen dira gainerako prozesadoreetara. Kapituluaren hasieran azaldu dugunez, sareen ezaugarri topologiko bat erdibiketaren banda-zabalera da, hots, kendu behar den lotura kopurua (haien banda-zabalera) sarea bi zati berdinetan banatzeko. Batez bestean, prozesadore guztiekiko komunikazio-probabilitatea bera bada, sarearen erdi batean sortzen diren paketeen erdi bat sare-erdi horretako helburuetara joango da, baina beste erdia sarearen bigarren erdira bidali beharko da; eta hori egiteko, sarea bitan banatzen duten loturak erabili behar dira.           Ondorioz, erdibiketaren banda-zabalerak muga bat markatzen du, ezin baita lotura horiek garraia dezaketena baino mezu gehiago onartu sarean. Hau da:   P/2 Ã— (PaK Ã— L) Ã— 1/2 = EBZ   non  P/2 â†’ sare erdiko prozesadore kopurua PaKâ†’ prozesadore batek sortzen duen pakete kopurua zikloko Lâ†’ paketeen tamaina edo luzera 1/2 â†’ erdi batetik bestera igaro behar duten paketeen frakzioa EBZâ†’ sarea bitan banatzen duten loturen (erdibiketaren) banda- zabalera Beraz, trafikoa zorizkoa bada33, hau da prozesadore batek sarera segundoko injekta dezakeen pakete kopuru maximoa:  PaK = 4Ã—EBZ / (PÃ—L) (edoflitkopurua = 4 Ã—EBZ/P)   Hurrengo taulan, maila, toru eta hiperkubo baten zorizko trafiko maximoak ageri dira (flit = byte). Emaitza byte/ziklo gisa ematen da (hau da, 4 Ã— Erdib/ P,loturen banda-zabalera kontuan hartu gabe).            256 prozesadore    2D maila         2D toru          8D hiperk.     Sarearen erdibiketa        16               32                128            (lotura kop.)      knâ€“1          2knâ€“1          2nâ€“1=P/2    Prozesadore bakoitzak             sor dezakeen      0,25             0,5                 2       flitkopuru maximoa      4 /k             8 /k          (konstantea)           zikloko (b.b.)   Hiperkuboa oso sare trinkoa denez, maila eta torua baino zorizko trafiko gehiago onar dezake, baina kostua handia da (oso sare konplexua da, batik bat prozesadore kopurua handia denean). Bestalde, toruaren trafiko maximoa mailarenaren bikoitza da, kasu bonetan oso kostu txikian: kateak eraztun bihurtzea. Hala ere, hiru kasuetan trafiko hori oso handia da: byte bat ziklo guztietan eta prozesadore guztietan bidali behar izatea ez da ohiko aplikazio paraleloen ezaugarria; izan ere, "lana egin behar da (denbora behar da) komunikatzeko zerbait izan ahal izateko". Kalkulatu dugun mezu-emari maximoa muga teoriko bat da; trafikoa zorizkoa izanda ere, sarea lehenago ase egin daiteke, trafikoaren homogeneotasuna estatistikoa baino ez baita.   6.5.6.4. Analisi globala Pakete baten latentzia zehaztu dugu aurreko ataletan, transmisio-teknikaren (SF / CT) eta komunikazioaren parametro nagusien arabera (d, L, tr, B). Hainbat kasutan, eta bi prozesuren artean transmititu behar den mezuaren tamaina bakarrik kontuan harturik, komunikazioaren latentzia beste modu honetan ere modela daiteke, xehetasunak kontuan hartu gabe:   Tkom = thasi + tflit ï‚´ L   hots, hasiera-denbora jakin bat gehi zenbait nanosegundo (edo ziklo) flit (byte) bakoitzeko. Adierazpen horretatik abiatuta, ez da zaila (begizten bektore-exekuzioa analizatzean ikusi dugun modu berean) Rmax eta L1/ 2 parametroak definitzea, hau da, lor daitekeen komunikazio-abiadura maximoa, eta abiadura maximoaren erdia erdiesteko mezuen luzera minimoa:   R = L / Tkom = L / (thasi + tflit ï‚´ L) Rmax = limLâ†’âˆžR= 1 / tflit L1/2 = thasi / tflit   Komunikazioaren eraginkortasunaren analisia amaitzeko, ez dugu ahaztu behar komunikazioaren alde "fisikoan" zentratu garela: sareko transmisioan, alegia. Baina komunikazio-prozesua datu-transmisio hutsa baino gehiago da. Prozesadore baten memoriatik beste baten memoriara eraman behar dira paketeak; prozesu osoa analizatzeko, igorlean zein hartzailean bete beharreko prozedura guztiak ere kontuan hartu beharko genituzke. Eta litekeena da hori guztia (kopiak memoria- espazioaren eta sarrera/irteerako espazioaren artean, paketeak sortzea, etiketatzea, ordenatzea, etenak, deiak, testuinguru-aldaketak...) egiteko behar den denbora transmisio-denbora bera baino luzeagoa izatea. Beraz, biziki garrantzitsua da prozesu horiek guztiak optimizatuta izatea, komunikazio- denbora osoa laburtu ahal izateko. Laburbilduz, hauek dira komunikazio-denboraren osagai nagusiak:           6.5.7. Zenbait komunikazio-arazo Prozesadoreen arteko komunikazioa ahalbidetzea da komunikazio-sarearen eginkizuna, mezu kopuru handia latentzia txikiaz kudeatuz. Hori baino garrantzitsuagoa: ziurtatu egin behar da sarera injektatutako pakete guztiak helburuetara heltzen direla. Aurre egin beharko diogu, beraz, sistema banatuetan arruntak diren eta dagoeneko tratatu ditugun (esaterako, zelatatze-kontrolagailuetan) arazoei: deadlock, livelock eta starvation deitutakoei. Ikus dezagun sistema paralelo baten komunikazio-sisteman duten eragina.   6.5.7.1. Pakete-blokeoak(deadlock) Sare batean komunikazioko deadlock bat dago, baldin eta pakete multzo batek ezin badu ez aurrera ez atzera jo, eta betiko blokeatuta geratzen bada: m paketek ziklo bat osatzen dute eta aurrera joatea galarazi egiten diote elkarri. Ondorioz, ez dira inoiz helburuetara helduko (latentzia infinitua da). Arazo hori modu arruntean ager daiteke komunikazio-sarean, paketeak prozesatzeko eraren arabera. Ikus dezagun adibide bat (WH motako komunikazioa).                     Sarean lau pakete daude, eta hartutako bideek begizta itxi bat osatzen dute. Irudian garbi ageri denez, pakete horiek elkarri blokeatzen diete bidea, eta, ondorioz, ez dira inoiz helburura helduko. Kasu guztietan, egoera hori ageri da paketeek erabili behar dituzten baliabideak â€”wormhole moduan, loturak, eta, cut-through moduan, bufferrakâ€” agortu direlako Jakina, azkeneko kasuan, blokeoak ez lirateke inoiz azalduko, baldin eta paketeak gordetzeko buffer ilarak oso luzeak (mugarik gabekoak) izango balira; baina hori ez da kasu erreala eta, nahiz eta pakete askotarako tokia izan, ezin da ziurtatu trafikoa handia denean ilarak ez direla beteko. Arazoa usuagoa da paketeek hartzen duten bidea aurrez planifikatuta ez badago, hots, bideak uneko eta tokiko trafiko-egoeraren arabera aukeratzen badira (esaterako, bideratze moldakorra erabiltzen denean). Paketeen bideak finkoak eta ezagunak direnean, aldiz, errazagoa da arazoa ekiditea. Modu batean zein bestean, blokeoak saihesten edo konpontzen dituzten komunikazio-prozedurak erabili behar ditugu, egoera onartezina da eta. Teknika erabilienak azaldu baino lehen, aipamen bat. Blokeoaren arazoaren aurrean, gutxienez bi estrategia desberdin plantea daitezke: (a) egoera ez onartzea, eta blokeoa sortzen ez duten komunikazio-mekanismoak edo sare-topologiak baino ez erabiltzea (adibidez, haien egitura dela eta, arboletan ez dira inoiz pakete- zikloak sortzen); eta (b) blokeoak gertatuko ez direnik ez ziurtatzea, baina noiz gertatzen diren detektatzea eta, une horretan, konponbideren bat ematea.   6.5.7.1.1. Bideratze estatikoak laguntzen du Paketeek hartu behar duten bidea beti bera denean (estatikoa), ez da zaila paketeetarako segurtasun osoko bideak definitzea. Esaterako, 2 dimentsioko maila batean, DOR ("lehenik-X-gero-Y") bideratze-estrategiak ez du blokeorik sortzen. Izan ere, maila batean pakete-zikloak osatu ahal izateko, "lehenik-Y- gero-X" bidea jarraitzen duten paketeak behar dira, nahitaez (adibidez, m2 eta m4 paketeak aurreko irudian). Baina hori DOR estrategiaren kontra doa. Beraz, paketeen bideratze moldakorra onartzen ez bada, mailetan paketeak ez dira inoiz blokeatuta geldituko. Irudian ageri da aurreko pakete-zikloa nola hausten den DOR bideratzea erabiltzen denean.                       6.5.7.1.2. Baina ez da nahikoa Lagungarria bada ere, eta zenbait topologiarekin nahikoa, DOR bideratze- estrategiek ezin dute ziurtatu ez direla edozein saretan blokeoak gertatuko; esaterako, toruetan. Izan ere, modu "ordenatuan" ibili arren, paketeak geldituta gera daitezke ziklo batean topologiak berak zikloak baditu. Eraztunetan, esaterako, erraz sortzen dira zikloak paketeekin, pakete guztiak erabaki bera hartuta:             Gauza bera gertatzen da 2 edo 3 dimentsioko toruetan eta antzeko topologietan. Beraz, blokeoak sortzen ez dituzten komunikazio-protokoloak behar ditugu, topologia horietan mezu-ematea gauzatzeko.   6.5.7.1.3. Kanal birtualak Mezu-bideragailuen arteko lotura fisikoak irteera-portu bat eta sarrera-portu bat lotzen ditu. Baina lotura fisikoa hainbat irteeraren artean partekatu daiteke (multiplexatu), irudian ageri den moduan.               Lotura fisiko bakarraren erabilera partekatzen duten hainbat kanal birtual defini daitezke. Kanal birtualak osatzeko, irudian ikusten den legez, buffer multzo gehiago sartu behar da bideragailuetan (edo daudenak azpimultzotan banatu). Kanal birtualak komunikazio-sarearen eraginkortasuna hobetzeko erabil daitezke. Esaterako, pakete batek aurrera jarraitu ezin badu, haren kanal birtuala blokeatu egiten da, baina ez, aldiz, lotura fisikoa; hots, beste pakete batek aurrera egin dezake bigarren buffer multzoa erabiliz. Baina, horrez gain, pakete-blokeoak saihesteko ere erabil daitezke kanal birtualak. Dagoeneko aipatu dugunez, baliabide berberak erabili nahi dituzten paketeek ziklo bat eratzen dutenean sortzen da blokeoa. Ziklo horiek apurtu daitezke baliabideen azpimultzo desberdinak esleitzen bazaizkie paketeei. Adibidez, eraztun batean: paketeek 0 kanal birtuala hartu behar dute "kanpoko" lotura (Nâ€“1 eta 0 nodoak lotzen dituena) erabiltzen ez duten bitartean; bestela, 1 kanal birtuala erabiliko dute. Horrela, adibidez, aurreko adibideko blokeoa desagertu egiten da: m0 eta m1 paketeek 0 kanal birtuala erabiliko dute; m2 paketeak, hasieran 0a eta gero 1a; eta, azkenik, m3 paketeak 1 kanal birtuala; pakete-ziklo bat zena espiral bihurtu da. Motel bada ere, aurrera egin ahal izango dute paketeek (aurrean dagoenak aurrera egiten duen neurrian).               Bi kanal birtual nahikoak dira 2D toruetan blokeoak saihesteko, DOR motako bideratzea erabiltzen bada. Frogatuko ez badugu ere, bideratze dinamikoa erabili nahi bada, bi kanal birtual erabili behar dira mailetan, eta lau toruetan, blokeoak ez izateko. Ez ahaztu, kanal birtual batez hitz egiten dugunean, bufferretako azpimultzo baten erabileraz ari gara. Oro har, bideratze moldakorra erabili ahal izateko, sistemako baliabideak (bufferrak) hainbat kanal birtualetan antolatzen dira, eta modu "arautuan" erabiltzen dira. Dena dela, kanal birtualak antolatu behar izateak eragina izango du paketeak prozesatzeko denboran, eta, beraz, ondo baloratu behar dira irabaziko dena (balizkoa) eta galduko dena (erreala). Hurrengo paragrafoetan, kanal birtualak erabiltzeko beste modu batzuk azalduko ditugu, gaingiroki bada ere.   6.5.7.1.4. Maila birtualak Paketeak bideratzeko estrategia asko oinarritzen dira kanal birtualen erabileran blokeoak saihesteko; esaterako, maila birtualak izenekoa. Bi dimentsioko mailaren kasuan, lotura bakoitza bi kanal birtualetan (bi buffer multzotan) banatzen da; horrekin batera, paketeak lau kategoriatan sailkatzen dira, norantz doazen kontuan hartuta: NE, ES, SW, eta WN (ipar-ekialde, hego- ekialde, hego-mendebalde eta ipar-mendebalde). Klase bakoitzeko paketeek bideragailu bakoitzaren zortzi kanal birtualetatik bi baino ez dituzte erabili behar ("maila birtual" bat) â€”NE motako paketeek, esaterako, N1 eta E0 kanal birtualak (ikus irudia)â€”, eta nahi duten bidea har dezakete buffer horiek erabiliz, ezinezkoa baita, pakete-klase bakoitzaren barruan, zikloak, eta, ondorioz, blokeoak, osatzea.               6.5.7.1.5. Biratze kontrolatuak (Turn model) Bi dimentsioko mailetan, lau noranzkoetan biratzen diren paketeak behar dira pakete-ziklo bat osatzeko, hurrengo irudian ageri den moduan (adibide bera egin daiteke kontrako noranzkoan). DOR erabiltzen denean, lau bira horietatik bi debekatu egiten dira (Nâ†’E eta Sâ†’W). Hori dela eta, ezin da ziklorik sortu, eta paketeak ez dira blokeatuko. Baina, zikloak ekiditeko, nahikoa litzateke lau bira horietatik bakar bat debekatzea; esaterako, Sâ†’W. Hala, paketeak nahi duten moduan mugi daitezke sarean zehar mendebaldera_biratzen_ez_badute, iparraldetik zein hegoaldetik etorrita. Ondorioz, pakete batek helburura heltzeko mendebaldera joan behar badu, hori da hasieran egin behar duen bidea, ezin izango baitu, bidean zehar, mendebaldera jo (hori dela eta, west-first deritzo teknika horri). Antzeko estrategiak defini daitezke beste biratzeekin.               DOR Turn model Halako bideratze-estrategia erabiltzen denean, posible da 2D mailetan bideratze moldakorra erabiltzea, nahiz eta modu desorekatuan erabili; izan ere, pakete batzuk nahi duten bidea erabil dezakete, baina besteek, nahitaez, "lehenik-X- gero-Y" bideari jarraitu behar diote.   6.5.7.1.6. Paketeen injekzioa kontrolatzea Blokeo-egoerara heltzeko, beharrezkoa da baliabideak â€”paketeak hartzeko bufferrakâ€” agortzea bideragailu multzo batean (eta, jakina, pakete-ziklo bat osatzea baliabide horiek erabili nahian). Beraz, blokeoak saihestuko ditugu, baldin eta, baldintza eta lehentasun jakin batzuen pean, bideragailuan pakete bat onartzen ez badugu pakete horrekin bufferrak betetzen badira eta, ondorioz, ziklo bat osatzea posible bada; horrela, "burbuila" bat uzten dugu beste pakete batzuek aurrera jarrai dezaten eta okupatzen dituzten baliabideak aska ditzaten. Oro har, buffer bat okupatzeko lehentasun handiagoa izango dute dagoeneko sarean dauden paketeek sarean injektatu nahi diren pakete berriek baino (sarea paketez beteko ez dela ziurtatzeko). Teknika horren aldarea bat erabiltzen da, esaterako, Mare Nostrum cluster-aren mezu-bideragailuetan.   6.5.7.1.7. Bide seguruak erabiltzea Blokeoak tratatzeko azaldu ditugun teknika guztietan, bideak aukeratzeko askatasuna mugatu egiten da: blokeorik gabeko bideak baino ezin dira hartu. Lehen aipatu dugunez, beste estrategia bat erabil daiteke: ez da ziurtatzen blokeoak ez direla gertatuko; hori egin beharrean, balizko blokeoak detektatu egiten dira eta, gero, irtenbide bat bilatzen da. Pakete batzuk blokeatuta daudela detektatzea ez da, berez, erraza; gainbegirale global bat ez dagoenez gero, informazio lokala erabili beharko da. Blokeoak detektatzeko aukera bat denboragailuak erabiltzea da. Pakete bat tarteko mezu- bideragailu batean gelditzen denean, denboragailu bat jartzen da abian. Denbora jakin bat aurrera segitu gabe igaro bada, blokeatuta dagoela erabakiko da. Hipotesi bat baino ez da, eta agian geldituta dago inguruan trafiko handia dagoelako, eta ez deadlock batean sartu delako. Har dezagun adibide gisa 2D maila bat. Bi kanal birtual definitu dira, A eta B, eta horrekin batera bi maila birtual: A kanal birtualak (bufferrak) erabiltzen dituena eta B kanal birtualak (bufferrak) erabiltzen dituena. A maila birtualean, bideratze moldakorra onartzen da; B maila birtualean, aldiz, DOR bideratzea baino ez. Paketeak A maila birtualean (haren bufferretan) injektatzen dira eta hor mugitzen dira baldintzarik gabe, nahi duten bidea erabiliz helburura heltzeko. Pakete bat bideragailu batean gelditzen denean, denboragailu bat aktibatzen da, balizko blokeoak detektatu ahal izateko. Aurrera jarraitu gabe denbora maximoa gainditzen bada, B maila birtualera (haien bufferretara) igaroaraziko du paketea mezu-bideragailuak; hortik aurrera paketea B mailan (bufferretan) mugituko da beti, blokeorik gabeko estrategiaren bat, DOR adibidez, erabiliz. Bideratze-politika horren atzean dagoen ideia hauxe da: blokeoak ez dira oso maiz gertatzen (omen) eta, ondorioz, pakete gehienek ez dute arazorik izango helburura heltzeko. Balizko blokeoetan sartutako paketeak baino ez dira behartuko bide seguruak erabiltzera. Hainbat arazori aurre egin behar zaio, noski, estrategia hori erabili ahal izateko: itxaron behar den denbora maximoa, denboragailuen gauzatzea, eta abar. Eta ez ahaztu inoiz balizko onuren eta kostu errealen balantzea egitea.   6.5.7.1.8. Beste zenbait aukera Beste teknika ezagun bat (SF kasuan erabili dena) structured buffer pool izenekoa da. Hau da ideia: egituratu baliabideak, bufferrak, helbururako distantziaren arabera. Esaterako, egin behar den bidearen luzera 3 bada, paketeak 3 klaseko buffer bat erabiltzen du; distantzia 2 bada, 2 klasekoa, eta abar; aurrera doan neurrian, paketeak erabiltzen dituen baliabideak aldatu egiten dira. Hala, kate bat osatzen da baliabideekin: d â†’ dâ€“1 â†’ dâ€“2... eta zikloak saihestu egiten dira. Kasu partikularretarako soluzioak ere badaude. Esaterako, sarearen diametroa paketeen luzera baino txikiagoa bada, eta WH erabiltzen bada, pakete baten goiburukoa helburura heldu denean, paketeak ez du oraindik iturburua abandonatu. Lehen aipatu dugun ideia bera erabiliz (denboragailuak), igorleak berak erabaki dezake paketea blokeatuta dagoela, eta, adibidez, saretik erretiratu eta geroago birtransmititu (adi! paketeen latentzia handia izan daiteke kasu horietan). Edonola ere, pakete bat saretik erretiratzea erabakitzen bada, igorleak jakinaren gainean egon behar du; bestela, informazioa galdu egin daiteke.   6.5.7.2. Livelock eta starvationarazoak Konpontzeko arazo gehiago ere badago komunikazio-protokoloetan, nahiz eta, aurrekoarekin alderatuta, munta gutxiagokoak diren. Livelock arazoa ageri da sarean, baldin eta paketeak mugitu bai, baina helburura heltzeko gauza ez badira. Esaterako, arazo hori ager daiteke pakete-jarioa kontrolatzeko arestian aipatu dugun teknika hau erabiltzen denean: paketeak ez dira inoiz errefusatzen; tokirik ez badago, buffer ilarako pakete bat desbideratzen da tokia izateko. Ondoren, desbideratu berri den paketea berriz agertzen da sarreran eta atzera botatzen da hartu berri dugun paketea. Beraz, mugitu bai, paketeak mugitu egiten dira, baina inora ez. Sarearen kudeaketan ager daitekeen beste arazo bat starvation (gosetea) izenekoa da. Edozein komunikazio-sarek eta -protokolok zuzen jokatu behar du prozesadore guztiekin. Ezin da onartu batzuek beti aukera izatea paketeak sarean injektatzeko eta beste batzuek ez izatea. Esaterako, baldin eta sare- eremu bat badago non trafiko handiagoa espero den (adibidez, maila batean trafiko guztia zentrora badoa), ziurtatu egin behar da tokiko prozesadoreek ere aukera izango dutela haien paketeak sartzeko, eta ez geratu beti zain, baliabide guztiak okupatuta daudelako. 6.5.8. Komunikazio-protokoloak Prozesu paraleloen arteko informazioa trukatzeko, paketeen garraiatze fisikoa komunikazio-sarean egiteaz gain, hainbat prozedura exekutatu behar dira igorlean zein hartzailean, paketeak sortzeko eta paketeak hartzeko. Azken batean, prozesadore baten memoriatik beste baten memoriara gauzatu behar da komunikazioa. Beraz, ezin da analizatu komunikazioaren prozesua prozedura horiek guztiak kontuan hartu gabe. Izan ere, litekeena da halako prozeduren latentzia komunikazio fisikoarena baino handiagoa izatea. Ez ditugu prozesu horiek guztiak hemen sakon analizatuko, baina azalpen xume bat eginez bukatu nahi dugu kapitulu hau. Konputagailuzko sareen arloan estandar bihurtu diren TCP/IP protokoloak ez dira egokiak MPP sistemetan (behe-mailako cluster-etan erabili badira ere). Protokolo horiek erabiltzen direnean, igorlearen zein hartzailearen sistema eragileek hartzen dute parte prozesuan, eta paketeen hainbat kopia egiten dira, sarearen, sistemaren eta erabiltzailearen memoria-espazioetan.           Sistema eragileak parte hartu behar izateak eta kopiak egiteak kostu bat dute (denbora); gainkarga hori onargarria izan daiteke transmisio-abiadura txikia denean (100 Mb/s), baina ezin da onartu (ahalik eta txikiena izan behar du) transmisio-abiadura handia denean (10 Gb/s). Hori dela eta, protokolo eraginkorragoak garatu dira berariazko diseinuko MPP sistemetan zein goi-mailako cluster-etan erabiltzeko. Protokolo horien helburua hau da: laburtzea, minimoraino, paketeak sortzeko eta hartzeko latentziak, erabiltzailearen eta sistema eragilearen memorien arteko paketeen kopiak saihestuz (zero kopiako protokoloak). Aukera ezagunenak bi hauek ditugu: VIA (Virtual Interface Architecture) eta InfiniBand. Sare komertzial estandar gehienek gauzatzen dituzte protokolo horiek, hardwarean (nativeimplementation, azkarragoa) edo emulazioaren bidez (motelagoa). Gainera, protokolo estandar horiez gain, beste kasu batzuetan â€”Myrinet, esaterakoâ€” komunikazio-protokolo propioak ere erabiltzen dira (GM). Aukera gehiago badago ere, cluster-etan gehien erabiltzen diren komunikazio- sareak eta â€“protokoloak bi motakoak dira. Behe mailako sistemetan, Gigabit Ethernet, da erabiliena, merkea nahiz eta ez oso azkarra (adibidez, pakete txikien latentzia, MPI erabiliz, 50 Âµs edo gehiago izan daiteke); eta maila altuko sistemetan, InfiniBand eta Myrinet, eraginkorragoak baina garestiagoak. InfiniBand komunikazioetarako azpiegitura eta protokolo aurreratu bat da; irudian, InfiniBand erabiltzen duen sistema paralelo baten nodo orokor bat.   Nodoen osagaiak denetarikoak izan daitezke: kasurik sinpleenean, prozesadore huts bat, eta konplexuenean, beste sistema paralelo batzuk (SMP, esaterako), sarrera/irteera eragiketetarako gune bereziak, informazioa masiboki gordetzeko gailuak (RAID)... Barneko osagaien arteko komunikazioa kommutagailuen bidez egiten da, eta nodoen artekoa mezu-bideragailuen bidez. Myrinet ere komunikaziorako azpiegitura azkarra da. Nodoetan, diseinu bereziko NIC (network interface card) txartelak erabiltzen dira, non exekutatzen baita komunikazio-protokoloa (GM); beraz, nodoko prozesadoreak "kalkulua" bakarrik exekutatzen du, eta komunikazio-txarteleko prozesadoreak komunikazioari dagokion gainerako guztia (gainera, erabiltzaileak txartelaren funtzioak programa dezake, sistema bere beharrei egokitu ahal izateko). Eskuarki, nodoak Clos sare batean (fat tree batean) konektatzen dira, irudian ageri den moduan (64 nodoetarako). Loturak 10 + 10 Gb/s-koak dira eta pakete txikien latentzia 2 Âµs baino txikiagoa.                        arbolaren hurrengo mailarako loturak         64 nodoko Clos sarea (fat tree). Kommutagailuak 8 + 8 sarrerakoak dira                            (noranzko biko loturak).   6.6. KONPUTAGAILU PARALELOEN EBOLUZIOA Konputagailuen kalkulu-abiadura hobetzeko asmoz paralelismoa erabiltzeko saioak ia konputagailuak bezain zaharrak dira. Prototipo esperimentalak eta makina komertzialak askotarikoak izan dira, eta behin baino gehiagotan bizitza laburrekoak. Ezagunenak baino ez ditugu aipatuko kapitulu hau ixteko. Lehenbiziko konputagailu paraleloak unibertsitateetako esperimentuak izan ziren batik bat. Aitzindarietan, ILLIAC IV-a (University of Illinois, 1968) da, egur aski, ezagunena. SIMD motako makina bat zen eta datuen paralelismoa ustiatzen zuen. 64 prozesadore sinple zituen, bi dimentsioko toru antzeko sare baten bidez lotuta. Konputazio-eredu horretakoak ziren, esaterako, DAP multiprozesadorea (1980) â€”bi dimentsioko maila batean antolaturiko bit bateko prozesadore oso sinpleak, teorian 16 k prozesadore arteâ€”, eta asko saldu ziren Thinking Machines-eko CM-1 eta CM-2 makinak (1985) â€”antzeko ideia, baina hiperkuboak osatuz, teorian 64 k prozesadore lotzeko asmozâ€”. MIMD ereduan sarturik, memoria partekatuko sistemetan (SMP), NYU Ultracomputer- a aipa daiteke (New York Univ., 1983). Multiprozesadore horrek Omega sarea erabiltzen zuen komunikaziorako. Ildo bereko beste adibide batzuk dira Balance (1985) eta Symmetry (1990, 30 i386 prozesadore) multiprozesadoreak, biak Sequent etxekoak, eta BBN TC2000a (1989, 512 MC88000 prozesadore). Multiprozesadore horietan, konexio-sare erabilienak busa edo kommutagailuzko urrats anitzeko sareak izan dira. Ia kasu guztietan, asmoa prozesadore kopuru handia erabiltzea zen, baina errealitatean prozesadore kopuru apaletan gelditu ziren. Hala ere, makina horien diseinuan eta erabileran bildutako esperientziari esker, gaur egun ia "monoprozesadore" guztiak "multiprozesadoreak" dira: 2-4 prozesadore bus komun batean. Bestalde, MPP multikonputagailuek ere antzeko eboluzioa izan dute. Cosmic Cube izeneko makina izan zen lehenetako bat â€”6 dimentsioko hiperkubo batean, 64 i8086 prozesadore gehienez, SF motako komunikazioaâ€”, CalTech-eko laborategietan sortua, 1980an. Makina horren ondorioak izan ziren iPSC (Intel Personal SuperComputer) familiako hiperkuboak: iPSC1 eta iPSC2 makinak (azkenak zirkuitu-kommutazioa erabiltzen zuen). Serie horren azkeneko alea Paragon izenekoa izan da, non bi dimentsioko maila batean 2.048 i860 prozesadoreraino konekta daitezkeen (540 prozesadorekoek arrakastaz funtzionatu dute). Makina horiek guztiak Estatu Batuetatik etortzea ohikoa bada ere, Europan ere izan dira antzeko garapen teknologikoak; segur aski ezagunena Parsys etxeko SuperNode konputagailua izan da, Transputer prozesadoreetan oinarrituta (1985- 1990). Sistema hauen garapena gero eta zabalagoa izan da: CRAY etxeko T3D makina (3 dimentsioko toru bat, 128-2.048 Alpha prozesadoreekin, 4 kanal birtual, WH); IBM-ko SP2-a (128 prozesadore eta urrats anitzeko sare bat); Convex-eko SPPA- a eta Fujitsu-ko VPP500-a (crossbar bat erabiliz); MIT-eko J-Machine izenekoa; Thinking Machines-eko CM-5-a...; eta ASCII serieko makinak, lehenengo aldiz 1 Teraflop/s-ko kalkulu-abiadura lortu zutenak. Makina horietatik asko arrakastatsuak izan dira komertzialki, baina dagoeneko ez daude merkatuan. Azken urteetan, Earth Simulator edo Blue Gene superkonputagailuak kalkulu- abiadura itzelak lortu dituzte (dagoeneko, 200 TF/s baino gehiago). Bestalde, memoria partekatua baina fisiko banatua duten makinen artean, merezi du aipatzea Stanford-eko DASH konputagailua. Hasierako bertsioan, 64 MIPS RS3000 prozesadore konektatzen ziren. Konexio-eskema hierarkikoa zen: 4 prozesadoreko 16 multzo. Multzo bakoitzaren barnean, 4 prozesadoreak bus baten bidez konektatzen ziren, eta multzoak, 2 dimentsioko maila batez. Makina horren eboluzioa dira Origin serieko multikonputagailuak, hurrengo kapituluan analizatuko ditugunak. Sistemaren topologia dela eta, azkeneko makina gehienak mailak, toruak edo arbolak dira; esaterako, Cray XT3 (30.508 pr.) edo IBM Blue Gene/L (65.536 Ã— 2 pr.) konputagailuak hiru dimentsioko toruak dira, eta Intel-eko Thunder (1.024 Ã— 4 pr.) edo IBM ASC Purple (1.280 Ã— 8 pr.) konputagailuak zortzi portuko kommutagailuen bidez egindako arbola sendoak dira. Ezin dugu alboan utzi, inolaz ere ez, segur aski dagoeneko arkitektura paralelorik arrakastatsuen diren mota guztietako cluster-ak. Batetik, goi- mailakoak â€”K computer, Roadrunner, Mare Nostrum...â€”; eta, bestetik, maila apalagokoak, ohikoak dagoeneko mundu osoko unibertsitate, laborategi eta enpresetan, haien "kostu/abiadura" erlazio ona dela medio â€”nodo arruntak (64 â€“ 1.024) eta komunikazio-sare aurreratuak (Myrinet, InfiniBand, Quadrics...) edo Gigabit Ethernet soilaâ€”. Ohikoa da makina paraleloen garapena belaunalditan sailkatzea. Horietako hirugarrenean omen gaude (laugarrenean, agian, cluster-ekin). Hasieran, store- and-forward eta hiperkuboa erabili ziren; gaur egun, aldiz, wormhole/cut- through erabiltzen da, eta mailak, toruak, arbolak eta antzeko topologiak. Gero eta zailagoa da makina horien sailkapen garbia egitea, eredu askotariko ezaugarriak hartzen baitira eraginkortasunik handiena lortzeko (eskuarki, egitura hierarkikoak, eredu desberdinak erabiliz hierarkia-maila bakoitzean). Bestalde, bi estandar erabili dira eskuarki sistema paraleloak programatzeko. Batetik, OpenMP, memoria partekatuko sistema paraleloetarako, eta, bestetik, MPI, mezu-ematearen bidezko aplikazioak programatzeko. Era berean, sistema paraleloa kudeatzeko hainbat tresna ari dira garatzen: sistema eragileak, debugger-ak, profiler-ak... Azken kapituluan, abiadura handiko sistema paraleloen merkatuaren eboluzioaren, eta aplikazioak sortzeko tresnen laburpena egingo dugu.   ERANSKINA.Batez besteko distantzien kalkulua hainbat topologiatarako.   Kapituluaren gehigarri gisa, aztertu ditugun topologien batez besteko distantzien kalkulua egingo dugu. Honela definitzen daP prozesadoreko sare baten batez besteko distantzia: hau da, distantzia guztien batura zati bikote kopurua. Definizioan ez da kontuan hartu prozesadore bat bere buruarekin komunikatzeko beharra. Kontuan hartu nahi bada, distantzia guztien batura Pï‚´P bikote kopuruaz zatitu beharko genuke (bigarren kasu horri batez besteko distantzia topologikoa deritzogu). Sareen batez besteko distantziak kalkulatzeko, batukari batzuk egin behar direnez gero, hona hemen batzuen emaitzak:  â†’ serie aritmetikoa â†’ serie koadratikoa â†’ serie esponentziala â†’ serie binomiala   Emaitza horietan oinarrituta, ez da zaila aztertu ditugun sareen batez besteko distantziak kalkulatzea.   E1. Hiperkuboak (ndimentsio, 2nprozesadore) Hiperkuboa sare simetrikoa da; beraz, nahikoa da nodo bat (edozein nodo) kontuan hartzea. Dakigunez, honela etiketatzen dira hiperkubo baten nodoak: (xnâ€“1, xnâ€“2, ..., x1, x0); dimentsio bakoitzeko koordenatua 1 edo 0 da. Topologia dela eta, nodo bakoitza n nodorekin konektatuta dago, zeinetan koordenatu bakar bat aldatu den. Esaterako, (0,0,0,0) nodoa (1,0,0,0), (0,1,0,0), (0,0,1,0), (0,0,0,1) nodoekin konektatuta dago. Beraz, d = 1 distantziara n nodo dago, hain zuzen ere; d = 2 distantziara, ; eta abar. Hori dela eta, hau da, prozesadore batetik abiatuta, distantzia guztien batura:     Eta, hortik, batez besteko distantzia:     Prozesadore kopurua handia denean, beraz, hiperkubo baten batez besteko distantzia n/2da (dimentsio kopuruaren erdia).   E2. Mailak (ndimentsio,kprozesadore dimentsioko) Mailen kasuan (kateak, 2D mailak, 3D-koak, eta abar), batez besteko distantziaren kalkulua egiteko, egokia da aipatu berri dugun batez besteko distantzia "topologikoa" kontuan hartzea, hau da, distantzien batura prozesadore-bikotearen kopuruaz zatitzea, iâ†’ i bikoteak barne (P = k bada, k ï‚´ k bikote). Izan ere, n dimentsioko maila baten batez besteko distantzia topologikoa n aldiz dimentsio batekoa da. Hortik abiatuta oso erraza da gero benetako batez besteko distantzia ateratzea. Ikus dezagun, beraz, katearen batez besteko distantzia topologikoa.         i prozesadoretik abiatuta, honela kalkula daiteke gainerako prozesadoreetarainoko distantzien batura:     Sarea ez da simetrikoa, eta, ondorioz, distantzien batura aldatu egiten da i prozesadoreak okupatzen duen posizioaren arabera. Beraz, edozein prozesadoretatik abiatuta, hau izango da distantzia guztien batura:     Batez besteko distantzia topologikoa kalkulatzeko, nahikoa da distantzia guztien batura bide kopuruaz (k2) zatitzea:     Aipatu dugunez, n dimentsioko mailen batez besteko distantzia topologikoa n aldiz dimentsio batena da. Hori lortuta, interesatzen zaigun batez besteko distantzia lortzeko ("komunikaziokoa", 0 distantziako komunikazioak kontuan hartzen ez dituena), nahikoa da zuzenketa txiki bat egitea: P2/ [P(Pâ€“1)] = P/ (Pâ€“1) faktoreaz biderkatzea. Izan bedi k dimentsio bakoitzeko prozesadore kopurua, eta, ondorioz, P = kn. Hala, hau da n dimentsioko mailaren batez besteko distantzia:  (prozesadore kopurua handia denean)   Adibidez,          n= 1(katea)            n= 2(2D maila)            n= 3(3D maila)   Prozesadore kopurua handia denean, beraz, maila baten batez besteko distantzia nÃ—k/3 gisa eman daiteke. E3. Toruak(ndimentsio,kprozesadore dimentsioko) Toruak (eraztunak) eta mailak antzeko ezaugarrietako topologiak dira. Hala ere, toruen analisia sinpleagoa da, simetrikoak direlako; beraz, nahikoa da distantzien batura nodo batetik abiatuta analizatzea. Aurreko kasuan bezala, komeni da dimentsio bakarreko torua, eraztuna, aztertzea; gero, erraza da eraztunaren batez besteko distantzia edozein dimentsio kopurutara orokortzea. Torua simetrikoa bada ere, badago arazotxoren bat, emaitza desberdina baita prozesadore kopurua bakoitia edo bikoitia bada. Sinplifikatzeko, demagun P (edo k) bikoitia dela.          Prozesadore batetik abiatuta, hau da distantzia guztien batura:   Beraz, eta mailetan erabili dugun prozedura bera erabiliz (n aldiz dimentsio batekoa, eta, gero, 0 distantziako bideak kontuan ez hartzeko zuzenketa), hau da emaitza n dimentsiotarako:  (prozesadore kopurua handia denean)   Esaterako,         n= 1(eraztuna)        n= 2(2D torua)            n= 3(3D torua)   Prozesadore kopurua handia denean, beraz, toru baten batez besteko distantzia nÃ—k/4gisa eman daiteke. E4. Arbolak(prozesadoreak hostoetan) Arbola bat ere egitura simetrikoa da. Arbolaren gradua k izanik, adabegi batetik abiatuta, badago kâ€“1 adabegi 2 distantziara; k(kâ€“1), 4 distantziara; k2 (kâ€“1), 6 distantziara; eta abar (arbola bitarra bada, adabegi bat 2 distantziara; 2 adabegi 4 distantziara; 4 adabegi 6 distantziara...).                   Hau da, beraz, distantzia guztien batura:     eta batez besteko distantzia:       Adibidez, (P handia izanik):               k= 2(bitarra)                           k= 4                                        â–ª 7â–ª                                  DatuenKoherentzia                              DSM Konputagailuetan                7.1. SARRERA Hirugarren kapituluan aztertu dugunez, datuen koherentzia da arazo nagusietako bat memoria partekatuko sistema paraleloetan. Nodoen cache memorietan, aldagai partekatuen kopiak kargatuko dira, baina prozesadore guztiek memoria-sistemako ikuspegi bera izan behar dute, memoriako helbide-espazioa bakarra delako. Beraz, datuen kopiak koherente (elkarren artean berdinak) mantendu behar dira sistema osoan zehar. Aztertu dugu dagoeneko nola ebazten den datu- koherentziaren arazoa SMP multiprozesadoreetan, hau da, komunikaziorako bus bat erabiltzen duten sistemetan. Halako sistemetan, prozesadore guztiek partekatu egiten dute komunikazioko azpiegitura "zentralizatua", busa; memoria-eragiketa guztiak, beraz, busean ageriko dira, eta busa erabil daiteke informazioa beste prozesadoreetara zabaltzeko, oso modu sinplean. Koherentzia mantentzeko hardware berezia dago prozesadore bakoitzean, zelataria, busetik igarotzen den informazioa zelatatzeko eta beste prozesadoreetara informazioa bidaltzeko. Informazio horretan oinarrituta, cacheetan dauden datu-blokeak egokitu egin beharko dira â€”egoerak aldatu, informazioa baliogabetu...â€” sisteman dauden datu- blokeen kopiak "berdinak" mantendu ahal izateko. Alabaina, aurreko ebazpide hori ezin da erabili memoria fisikoki banatuta duten DSM sistemetan, zeinetan, prozesadoreen arteko komunikazioa gauzatzeko, sare "deszentralizatuak" erabiltzen baitira: mailak, toruak, hiperkuboak... Esaterako, prozesadoreak 2D mailan loturik badaude, nola jakingo du (0, 0) prozesadoreak (4, 3) prozesadoreak kargatu berri duela cachean berak E egoeran duen datu-blokea, eta, ondorioz, bloke horren egoera S-ra aldatu behar duela? Edo, nola jakingo du (2, 1) prozesadoreak berak behar duen datu-blokea M egoeran dagoela beste prozesadore batean, eta, ondorioz, ezin duela erabili memoria nagusiko kopia? Kapitulu honetan, DSM (Distributed Shared Memory) motako sistema paraleloen datu-koherentzia nola ziurta daitekeen aztertuko dugu. Hori baino lehen, ordea, beste galdera bat. Datuen koherentzia, nahitaez, hardwareaz mantendu behar da? Zenbait makinak ez dute hori egiten, eta arazoa softwareaz konpondu behar da. Gogoratu: datuak partekatzen eta aldatzen badira ziurtatu behar da koherentzia, ez bestela. Hau da, bektore handi baten osagaiekin A(i)=A(i)+1 eragiketa exekutatzeko, ez da beharrezkoa koherentzia- hardwarea, ziur asko datuak partekatuko ez direlako (datu-banaketa egokia eginez gero). Gainera, beti daukagu beste aukera bat: cachera ez eramatea partekatu behar diren datuak. Cacheetako koherentzia ziurtatzen ez duten sistemei NUMA (Non-Uniform Memory Access) deritze (adib. Cray etxeko T3D-a); datuen koherentzia hardwarez bermatzen duten konputagailuei, aldiz, cc-NUMA deritze (CacheCoherentNUMA). Jakina, eraginkortasuna dela eta, azkenak interesatzen zaizkigu. Gero eta gehiago, prozesadore anitzeko sistemak modu hierarkikoan antolatzen dira: komunikazio-sare batez lotzen diren nodoak ez dira prozesadore soilak, baizik eta multiprozesadoreak. Azken horiek, eskuarki, bus batean konektatutako 4-8 prozesadoreko SMP sistema txikiak dira. Ez ahaztu: halako arkitekturak, busarenak, oso ondo ezagutzen dira, koherentzia modu sinplean mantentzen da (zelataria), eta, beraz, 4-8 prozesadoreko txartelak adreilu gisa erabil daitezke sistema paralelo handiagoak eraikitzeko. Hori dela eta, datuen koherentzia ere hierarkikoki beteko da: nodo bakoitzaren barruan, zelatari baten bidez, baina nodoen artean... zer egin behar da sisteman egon daitezkeen kopiak baliogabetzeko? non daude kopia horiek? nondik ekarri behar dira datu- blokeak, memoria nagusitik edo beste cache batetik? zein egoeratan kargatu behar dira blokeak? Koherentzia-direktorioak dira aurreko galderetan ageri den arazoaren soluzio orokorra. Prozesadoreetako cacheetan dauden datu-blokeei buruzko koherentzia- informazioa gordeko da direktorioan eta, edozein eragiketa egin baino lehen, direktorioa kontsultatu egin beharko da, zer egin behar den jakiteko. Erraza da ulertzen koherentzia-direktorioaren egitura eta erabilera egokiak oso garrantzitsuak izango direla sistemaren funtzionamendurako: datuak koherenteak mantendu behar dira, baina sistema paraleloak azkarra eta eraginkorra izan behar du. Koherentzia-direktorioen egitura, erabilera eta abar analizatu baino lehen bi ohar. Batetik, sistemaren memoria partekatua bada ere, espero izatekoa da prozesadore bakoitzaren atzipen gehien-gehienak bertako memoria zatian izatea, eta besteen memoria komunikaziorako bakarrik erabiltzea. Adibidez, Pi prozesadoreak erabili behar dituen datuak Pj prozesadoreko memorian badaude, eta alderantziz, exekuzioa oso motela izango da; hobe da datuak hasieran trukatzea eta, gero, bertako memorian daudela, prozesatzea. Bestalde, gogoratu beharra dago partekatzen diren aldagaietan (datu-blokeetan) bakarrik mantendu behar dela koherentzia; eskuarki, prozesu paraleloen aldagai gehienak pribatuak izango dira, eta bakan batzuk baino ez partekatuak; bestela esan, datu-bloke gehienak E (edo M) egoeran izango dira, eta, beraz, ez dute koherentzia- eragiketetan parte hartuko.   7.2. KOHERENTZIA DIREKTORIOAK 7.2.1. Sarrera eta sailkapena Koherentzia-direktorioan, datu-bloke bakoitzari buruzko kontrol-informazioa gordetzen da (blokeak non dauden eta zein egoeratan, batik bat). Prozesadore batek hitz bat irakurri (huts egitean) edo idatzi behar duenean, hitzari (datu- blokeari) buruzko informazioa eskuratu behar du, direktorioan; informazio horren arabera jakingo du zehazki zer egin: esaterako, datu-blokea nondik ekarri, zein egoeratan jarri, eta abar. Hau da erabaki behar den lehenbiziko arazoetako bat: non dago koherentzia- direktorioa? Non dauden eta nola egituratzen diren kontuan hartuta, honela sailka daitezke direktorioak: â€¢ Zentralizatuak. Direktorio zentralizatu handi bat dago, eta hitz bat gordetzen du sistemaren memoriako datu-bloke bakoitzeko. Gailu zentralizatu bat ez da, ordea, aukerarik egokiena prozesadore kopurua handia denean (are gutxiago memoria bera banatuta dagoenean), direktorioa erabiltzeko gatazkak oso maiz gertatuko baitira eta, ondorioz, eragiketa horien latentzia oso handia izango delako.   â€¢ Hierarkikoak. Direktorioa hainbat gailutan banatzen da sistemako nodoetan, eta gailu horiek egitura hierarkikoan antolatzen dira (arbola bat, esaterako). 3. kapituluaren bukaeran azaldu dugun busen hierarkia izan zitekeen adibide bat. Ez dira (eskuarki) erabiltzen.   â€¢ Lauak. Koherentzia-direktorioa banatuta dago sistemako nodoen artean, memoria bezala, hierarkiarik osatu gabe. Koherentzia-informazioa gordetzeko erabiltzen den estrategiaren arabera, bi motako direktorioak bereizi dira: - MNaren ondoko direktorioak: datu-bloke bakoitzari buruzko koherentzia- informazioa hitz bakar batean biltzen da MNaren ondoan dagoen direktorioan, dagokion nodoan. - CMetan banatutako direktorioak: koherentzia-informazioa blokearen kopia duten cacheetan zehar banatzen da, zerrenda estekatuak sortuz. Bi egitura hauek dira gaur egun erabiltzen direnak.   Koherentzia-direktorioek modu apalean hazi beharko lukete prozesadore kopuruarekin, bi ikuspuntutik:   â€¢ Tamaina. Direktorioen tamainak ez luke hazi behar prozesadore kopuruarekin (ez gehiegi, behintzat). Ikusiko dugunez, informazioa gordetzeko erabiltzen den egituraren araberakoa da direktorioaren tamaina.   â€¢ Banda-zabalera. Direktorioaren erabilerak ez luke komunikazioa (mezu kopurua) gehiegi handitu behar; izan ere, komunikazio-sarea prozesuak komunikatzeko erabili behar da, eta koherentzia-mezuek ez lukete kontsumitu behar sare horren banda-zabaleraren parte garrantzitsu bat; gainera, latentziari begira, bata bestearen atzetik (seriean) joan behar duten koherentzia-mezuen kopuruak (bide kritikoa osatzen dutenak) ahalik eta txikiena izan beharko luke. Zelatariak aztertzean erabili ditugun antzeko ideietan oinarritzen dira direktorioen bidezko koherentzia-protokoloak: blokeak egoera jakin batean daude (I, E, M, S, O); idazketetan, bloke baten kopia guztiak baliogabetzen dira; eta abar. Beraz, zertan datza direktorioen eta zelatarien arteko desberdintasuna? Bada, koherentziako informazioa gordetzeko eran eta koherentzia mantentzeko komunikazioa gauzatzeko eran.   7.2.1.1. Arazoak Direktorioen bidezko koherentzia-kontrolagailuak eraikitzeko, arazo asko ebatzi behar dira. Lehenik eta behin, direktorioaren tamaina: zenbat memoria behar du direktorioak koherentzia-informazioa gordetzeko? nola hazten da direktorioaren tamaina prozesadore kopuruaren arabera? Koherentzia-direktorioak tamaina mugatukoa izan beharko luke, eta, are eta garrantzitsuagoa, tamainak apal hazi beharko luke sistemaren prozesadore kopuruarekin. Hala ere, nahiz eta tamaina garrantzitsua den, koherentzia-direktorioen arazo nagusia beste bat da: koherentzia-eragiketen atomikotasun eza. Koherentzia- direktorioa modu deszentralizatuan erabiltzen den datu-egitura banatua da; ondorioz, ezin da ziurtatu, inolaz ere, direktorioko informazioa une oro eguneratuta egongo dela, edo ez direla teilakatuko, denboran zehar, bi prozesadoreko ekintzak datu-bloke beraren gainean, espero ez zen emaitza bat sortzeko (lasterketak, races). Adibidez, urrutiko prozesadore batean egindako idazketa bat dela-eta, direktorioari abisatu egin behar zaio bloke horren kopiak baliogabetu ahal izateko, eta horrek denbora beharko du. Zer gertatzen da, bada, tarte horretan beste prozesadore batek erabili behar badu koherentzia-direktorioa, bloke horren gainean eragiketa bat egin nahi duelako? Zer informazio lortuko du direktorioan bloke horri buruz? Arazo horiek dira larrienak direktorioak erabili behar ditugunean, ziurtatu egin behar baita eragiketa desberdinen "azpieragiketak" ez direla nahasten erantzun desegoki bat emateko. Ikusiko dugunez, egoera iragankorrak erabiltzen dira blokeetarako, direktorioan zein cache memorietan, eragiketen atomikotasuna lortzeko, eta, horiekin batera, kontrol-mezu bereziak, ACK eta NACK, eragiketak onartzeko edo, une horretan prozesatu ezin badira, errefusatzeko.   7.2.2. Direktorioen egitura Has gaitezen direktorioetan zer informazio eta nola gordetzen den analizatzen. Bi dira eskema nagusiak. Batetik, memoria nagusiaren ondoko direktorioak, zeinetan bi kasu bereizi ohi diren: full bit vector eta limited bit vector izenekoak. Eta, bestetik, cache memorietan banatutako direktorioak, koherentzia-informazioarekin estekaturiko listak edo zerrendak osatzen dituztenak.   7.2.2.1. Memoria nagusiaren ondoko direktorioak Direktorio mota honetan, datu-bloke bakoitzari dagokion koherentziako informazioa memoria nagusiari atxikitako gailu batean â€”direktorioan, hain zuzen ereâ€” gordetzen da. Memoria nagusia banatuta dagoenez gero, nahiz eta logikoki partekatua izan, koherentzia-direktorioa ere banatuta dago sistema paraleloko nodo guztien artean. Bi aukera dira erabilienak koherentziako informazioa egituratzeko: full bit vector eta limited bit vector izenekoak.   7.2.2.1.1. Full bit vector(Censier & Feautrier, 1978) Direktorioa osatzeko, memoria nagusiko datu-bloke bakoitzeko hitz bat erabiltzen da, eta bloke horri buruzko koherentzia-informazioa gordetzen da hitz horretan. Datu-bloke bati dagokion koherentzia-informazioa P+k biteko hitz batean biltzen da direktorioan: P bit, prozesadore bakoitzeko (nodo bakoitzeko) bat, blokea bertako cachean dagoen ala ez adierazteko; eta k bit gehiago blokearen egoera adierazteko (kasurik sinpleenean, nahikoa da bit bat egoera definitzeko). Adibidez, lau prozesadoreko sistema batean, eta egoerak adierazteko bit bat erabiliz (Eg = 0, blokea ez da aldatu; Eg = 1, blokea aldatu da), kasu hauek izan ditzakegu direktorioan bloke jakin baten koherentzia-informazioa adierazteko:         P0         P1         P2         P3         Eg                                                          blokea P0n dago, E       1          0          0          0          0      egoeran (kopia                                                          bakarra, koher.)       1          1          0          0          0      blokea P0n eta P1en                                                          dago, S egoeran       0          1          0          0          1      blokea P1en dago, M                                                          egoeran (aldatuta)       0          0          0          0          0      blokea ez dago inon                                                          (I)                                                          MESI protokoloetan,       1          0          1          0          1      ezinezkoa; bestela,                                                          O egoera Full bit vector motako direktorioak osatzeko behar den memoria kopurua oso handia izan daiteke. Azter ditzagun adibide batzuk (bit bat egoerak adierazteko).    prozesadore       blokea                    bit kop.        gehitu behar den    kopurua                              blokekodirektorioan       memoria       64          64 byte         â†’       65 (8 byte)           % 12,5      256          64 byte         â†’      257 (32 byte)           % 50     1.024         64 byte         â†’    1.025 (128 byte)        % 200 !!   Taulan ageri denez, nodo kopurua handia denean, direktorioaren tamaina onartezina izan daiteke; izan ere, tamaina linealki hazten da prozesadore kopuruaren arabera. Kasu horietan, beraz, beste aukera batzuk bilatu beharko ditugu. Koherentzia-direktorioaren tamaina murrizteko, bi bide hauetatik jo daiteke:   â€¢ Datu-blokeak handiagoak izatea, eta, ondorioz, datu-bloke gutxiago izatea. Bloke bakoitzeko koherentzia-hitz bat erabiltzen denez, bloke kopurua txikiagoa denean koherentzia-direktorioa ere txikiagoa da. Badakigu, hala ere, ez dela komeni datu-bloke oso handiak erabiltzea, kutsadura-efektua areagotu egingo baita cachean: datu-bloke bat kargatzen denean, gero erabiliko ez den informazio asko kargatuko da (ohiko datu-blokeak 64 edo 128 bytekoak dira).   â€¢ Sareko nodo kopurua txikiagotzea, nodo bakoitzean, prozesadore soil baten ordez, SMP sistema oso bat jarriz (adibidez, 4 prozesadore / busa / zelataria). Sare-hierarkia bat osatzen da horrela; koherentzia-direktorioak sareko nodoak soilik kontrolatuko ditu, nodo bakoitzaren barruko koherentzia bertako zelatariek ziurtatuko baitute. Hala, txikiagoa izango da koherentzia-hitzen tamaina.   Adibidez, aurreko bi estrategiak konbinaturik, tamaina hauek izango ditugu full bit vector motako direktoriorako:     prozesadore        blokea                     bit kop.       gehitu behar den     kopurua                                blokekodirektorioan     memoria       256            64 byte         â†’      257 (32 byte)          % 50 64 Ã— 4 pr./nodo    128 byte         â†’       65 (8 byte)           % 6   Hala ere, direktorioaren tamaina txikiagotu badugu ere, linealki hazten da oraindik sistemaren prozesadore (nodo) kopuruaren arabera. 7.2.2.1.2. Limited bit vector Direktorioaren tamaina txikiagotzeko dugun beste aukera bat hau da: informazio gutxiago gordetzea datu-bloke bakoitzeko. Hainbat aplikaziotan, nahiz eta prozesadore (prozesu) asko erabili, partekatzen diren aldagaien kopia kopurua ez da oso handia (2-4, esaterako, irudien tratamenduan); beste askotan, kopia kopurua handia bada ere, ez dira denak aldi berean erabiltzen (L1 S1 ... L2 S2 ... L3 S3 ...). Nolanahi ere den, paraleloan exekutatzen diren programei buruzko estatistikek erakusten duten moduan, aldagai partekatuen kopia kopurua ez da asko hazten prozesadore kopuruaren arabera. Aurreko kasuan, prozesadore adina bit erabili ditugu datu-bloke baten kopiak non dauden adierazteko; ez dugu mugarik jarri, eta, beraz, aukera dago datu- bloke baten P kopia daudela adierazteko (bit guztiak 1ekoak dira). Errealista al da hori? Ziur aski, ez. Beraz, zergatik ez mugatusistemakocacheetan kargatu daitezkeen datu-blokeen kopia kopurua? Hala eginez gero, nahikoa litzateke koherentzia-hitzean blokearen kopia duten prozesadoreen helbideak gordetzea, eta ez P bit. Erabaki batzuk hartu behar ditugu. Batetik, zenbat kopia onartu beharko genituzke? Esaterako, 1.024 prozesadoreko MPP batean, 10 bit behar dira prozesadore baten helbidea emateko; datu-bloke baten 100 kopia onartuz gero, 1.000 bit erabiliko genituzke kopia duten prozesadoreen helbideak gordetzeko, hau da, 1.024 (bit bat prozesadoreko) baino gutxiago! Gainera, eskuarki nahikoa da askoz kopia gutxiagorekin (5/10). Estrategia hori erabiltzen denean, koherentzia-direktorioen tamaina asko murrizten da; adibidez:   prozesadore   blokea      k, kopia                  bit kop.       gehitu behar   kopurua               kopuru max.            blokekodirektorioan den memoria  256:64Ã— 4  128 byte        5           â†’      5 Ã—6+ 1 = 31        % 3 1.024:256Ã—  128 byte        5           â†’      5 Ã—8+ 1 = 41        % 4      4   Adibideko lehenbiziko kasuan, 6 bit erabili behar dira (nodoen) helbideak adierazteko, eta 8 bit bigarrenean; taulan ageri denez, direktorioaren tamaina oso gutxi hazten da, nahiz eta prozesadore kopurua lau aldiz handiagoa den. Izan ere, helbideak erabiltzen direnez, koherentzia-direktorioaren tamaina log2P gisa hazten da, kï‚´log2P bit erabiltzen baitira koherentzia-hitz bakoitzean (gehi egoerak adierazteko bitak). Dena dela, koherentzia-hitzen tamaina txikiagotzeko, honako baldintza hau bete behar da: kï‚´ log2P << P. Datu-bloke jakin bat kontuan harturik, sistemako cacheetan kargatu daitekeen kopia kopurua mugatua bada, zer gertatzen da baldin eta aplikazio batek kopia gehiago erabili behar baditu? Jakina, kopia kopuru maximo hori baino gehiago erabili behar badira, bietako bat egin beharko da: (a) eskaerak ez onartzea; datu-blokea ez da cachera eramango eta eragiketa (rd/wr) memoria nagusian egin beharko da; edo (b) datu-blokearen kopia bat kentzea cacheren batean (nahi den ordezkapen-estrategia erabiliz), blokea behar den cachean kopia bat kargatu ahal izateko.   7.2.2.1.3. Koherentzia-direktorioaren erabilera Zabal eta sakon aztertuko ditugu direktorioetan oinarritutako koherentzia- protokoloak hurrengo ataletan, baina merezi du azaltzea orain, modu sinplifikatua, direktorioa nola erabil behar den, bi kasu "sinpletan". Memoria partekatuko multiprozesadoreak 2D maila bat erabiltzen du komunikazio-sare gisa (ikus irudia). Nodo bakoitzak prozesadorea, cachea, memoria nagusiaren zati bat, eta dagokion koherentzia-direktorioa ditu (bai eta paketeak kudeatzeko kontrolagailua ere). Datuen koherentzia mantentzeko, MESI (baliogabetu) motako protokolo bat erabiltzen da. Bi adibideak ohiko eragiketak dira: irakurketa eta idazketa bana, biak hutsegiteak cachean (aldagaia ez dago cachean). Bietan, aukera bat (sinplifikatuta) baino ez da azaltzen.   â–ª Irakurketa Pi prozesadoreak (L, local) Pj prozesadoreari (H, home) dagokion memoria nagusiko bloke bateko hitz bat irakurri behar du, eta huts egiten du (ez dago cachean). Gainera, hitza duen datu-blokea Pk prozesadoreko cachean dago (R, remote), M egoeran (aldatuta). Blokea eskuratzeko eta datuen koherentzia mantentzeko, honako ekintza-segida hau bete behar da:  1. Kontrol-mezu bat bidaliko da L-tik H-ra â€”datu-bloke horri dagokion koherentzia-informazioa duen nodoraâ€”, blokea bera edo blokeari buruzko informazioa eskatzeko.   2. Mezua H-ra heltzen denean, koherentzia-direktorioa irakurri eta erantzuna bidaliko da, H-tik L-ra: "behar duzun datu-blokea R nodoan dago, M egoeran".   3. Ondorioz, beste mezu bat bidaliko da, L-tik R-ra, blokea eskatzeko.   4. Heltzean, mezua prozesatu, eta eskatutako blokea bidaliko da, R nodoko cachetik (hor dago, M egoeran) L nodora.                         5. Aurrekoarekin batera, H-ra ere bidaliko da datu-blokea R-tik, memoria nagusia eta koherentzia-direktorioko informazioa eguneratzeko (bi kopiak S egoeran geratuko dira).   â–ª Idazketa L prozesadoreak cachean ez duen aldagai batean idatzi nahi du; aldagaia duen datu-blokea H prozesadoreari dagokion memoria nagusiko bloke bat da, eta bloke horren kopia asko dago multiprozesadoreko cacheetan, denak S (shared) egoeran. Blokea eskuratzeko eta koherentzia mantentzeko, honako ekintza-segida hau bete beharko da:   1. Blokeari buruzko informazioa (egoera eta kokapena) eskatuko dio L- k direktorioari (H nodoan); idazketa bat egin behar duenez, blokearen kopia guztiak baliogabetu behar dira.   2. Direktoriotik erantzuna bidaliko da: "Pi, Pj... prozesadoreetan dago blokea, S egoeran". S egoeran dagoenez gero (koherentea), datu-blokea ere bidaliko da, H nodoko memoria nagusitik. Bidenabar, blokearen egoera eguneratu egingo da direktorioan (S â†’ M, idatzi egingo da eta).   3. Aurreko informazioa L-ra heldu dela, blokearen kopia guztiak baliogabetzeari ekingo zaio; eta, horretarako, mezu bana bidaliko zaie kopia duten prozesadore guztiei, datu-blokea baliogabetu dezaten. 4. Azkenik, kopia baliogabetzen duten prozesadoreetatik baieztapen-mezuak bidaliko dira L-ra, datu-blokea baliogabetu egin dela adierazteko. Mezu horiek guztiak L-n bildu direnean, eragiketa bukatutzat emango da.   7.2.2.2. Cache memorietan banatutako direktorioak(zerrenda estekatuak) Aztertu berri ditugun direktorioetan, datu-bloke bati buruzko koherentzia- informazio guztia â€”blokearen egoera, zenbat kopia dauden eta non daudenâ€” zentralizatuta dago hitz bakar batean, memoria nagusiaren ondoan kokatzen den direktorioan. Hori bai, memoria nagusia banatuta dagoen moduan, halaxe banatzen da koherentzia-direktorioa ere, sareko nodo (prozesadore) guztien artean. Azter dezagun orain direktorioak osatzeko bigarren aukera. Datu-bloke bati dagokion koherentzia-informazioa sistemako puntu jakin batean gorde beharrean, sisteman zehar banatu daiteke: datu-blokearen kopia duten cacheetan, hain zuzen ere. Koherentzia-informazioa, beraz, banatuta dago, baina informazio hori estekatu egiten da zerrenda banatuak osatuz (oro har, esteka bikoitzeko zerrendak). Koherentzia-direktorioa egituratzeko, informazio hau erabili behar da nodo bakoitzean:   â€¢ Memoria nagusiaren ondoan, "direktorioan": hitz bat datu-bloke bakoitzeko, blokearen egoera eta "lehenbiziko" kopia duen prozesadorearen helbidea (erakusle bat) gordetzeko.                 egoera                           @kopia1   â€¢ Cache memoriaren direktorioan: bi helbide (bi erakusle) datu-bloke bakoitzeko, blokearen hurrengo zein aurreko kopiak non dauden adierazteko. Horrez gain, blokearen egoera ere adierazi behar da, beti bezala.             egoera                  @kopiaiâ€“1               @kopiai+1   Gauzatu nahi den koherentzia-protokoloaren araberakoa (MESI, MOSI...) izango dira blokeen egoerak (nahiz eta, gero ikusiko dugunez, egoera gehiago erabiltzen diren, kopia zerrendak egoki kudeatu ahal izateko). Irudi honetan, bloke baten hiru kopiekin osatutako zerrenda ageri da (ageri ez badira ere, egoerak ere gorde behar dira zerrendaren hasieran eta cacheen direktorioetan).                   Laburbilduz, ez dago hitz bat bloke baten kopia guztiak non dauden eta haien egoera adierazteko, informazio hori guztia banatu egin baita datu-blokearen kopiekin batera, zerrenda bat osatuz. Gainera, ez dugu mugatu kopia kopurua, kopia zerrenda nahi adina luza baitaiteke.   Tamainaren ikuspuntutik, koherentzia-direktoriorako behar den memoria-espazioa txikiagoa da, aurrekoekin alderatuta. Ikus dezagun adibide bat.   MPP batek 1.024 nodo ditu, eta, nodo bakoitzean, 128 MB-ko RAM eta 512 kB-ko cachea. Datu-blokeak 128 bytekoak dira, eta 3 bit erabiltzen dira egoeretarako. Konparatu direktorioen tamaina bi kasu hauetan: (a) MNaren ondoan zentralizatuta, 5 kopia bakarrik; eta (b) cacheetan banatuta.  (a) Memoria nagusiko bloke kopurua: 1 M Direktorioko hitzen tamaina: 5 Ã— 10 + 3 = 53 bit Direktorioa nodo bakoitzean: 53 Ã— 1 M â†’ 53 Mb(6,6 MB) Beraz, direktorioak nodo bakoitzeko memoriaren % 5 gehitzen du.  (b) Cacheetako bloke kopurua: 4 k Koherentziako informazioa, blokeko: Cachean: 2 Ã— 10 + 3 = 23 bit MNan: 10 + 3 = 13 bit Beraz, nodo bakoitzean: (13 Ã— 1 M + 23 Ã— 4 k) â†’ 13,1 Mb hau da, aurrekoa baino lau aldiz txikiagoa.  7.2.2.2.1. Cacheetan banatutako koherentzia-direktorioen erabilera Hurrengo ataletan aztertuko dugu, sakon, nola erabili behar diren halako direktorioak koherentzia mantentzeko; hori baino lehen, ikus ditzagun eskematikoki, aurreko kasuan egin dugun bezala, prozesadoreen artean trukatu behar diren kontrol- eta datu-mezuak datuen koherentzia mantentzeko, koherentzia-direktorioa cacheen artean banatzen denean. â–ª Irakurketa L prozesadoreak H prozesadoreko memoriako hitz bat irakurri nahi du, baina ez dago bere cachean. Hitza duen blokearen kopia bakar bat dago, koherentea, R prozesadorean. Hau da, beraz, bloke horri dagokion kopia zerrenda: H â†’ R. Eragiketa betetzeko, honako mezu hauek bidaliko dira:   1. L prozesadoreak datu-blokea eskuratu behar du, eta, horretarako, eskaera- mezu bat bidaliko dio H-ri. 2. Mezua heltzean, H-ko direktorioa irakurriko da; memoria nagusiko informazioa eguneratuta dagoenez, bertako datu-blokea bidaliko zaio L-ri. Horrez gain, blokearen kopia zerrenda egokitu beharko da, kopia berria zerrendako buruan kokatzeko. Nahikoa da, horretarako, direktorioan dagoen erakuslea (kopia zerrendako burua) aldatzea, L prozesadorea izango baita zerrenda-buru berria, ez R. Bidenabar, R-ren helbidea ere bidaliko dio L-ri, datuekin batera. 3. H-tik heldu den erantzuna hartu ondoren, blokea cachean kargatu, eta kopia zerrenda osatzeari ekiten dio L-k. Horretarako, mezu bat bidaliko da L-tik R- ra, esteka ezartzeko; hortik aurrera, R-ko kopia bigarrena izango da. 4. Eragiketa amaitzeko, mezu bat bidaliko da R-tik L-ra, esteka egokitu dela adierazteko. Honela geratuko da, azkenik, datu-blokearen kopia zerrenda: H â†’ L â†” R.   â–ª Idazketa Adibide gisa, demagun idatzi egin behar dela kopia zerrendako buruan dagoen datu-bloke batean (S egoeran), L prozesadorean. Asmatu egiten da cachean eta, beraz, egin behar den gauza bakarra gainerako kopiak baliogabetzea da. Honela beteko da baliogabetze-eragiketa: 1/2. Mezu bat bidaliko du L-k H nodora, blokearen egoera egunera dezan (S-tik M-ra aldatu behar da, MNaren ondoko direktorioan). Ondorioz, aldaketaren baieztapena bidaliko da H-tik L-ra. 3/4. Ondoren, L-k baliogabetze-mezua bidaliko dio zerrendako bigarrenari (haren helbidea ezagutzen du, esteka bat duelako). Mezu hori hartutakoan, kopia baliogabetu, eta erantzuna bidaliko dio L-ri, eragiketa egin dela adierazteko eta zerrendako hurrengoaren helbidea emateko. 3'/4'. Aurrekoa errepikatu behar da blokearen kopia duten prozesadore guztiekin, harik eta azkeneko kopiaren erantzuna heldu arte. Laburrean. Koherentzia-direktorioak osatzeko erabiltzen diren bi egitura nagusiak azaldu ditugu aurreko paragrafoetan. Batean, koherentziarako behar den informazioa nodo bakoitzeko memoria nagusiaren alboan dagoen gailu batean kontzentratzen da; bestean, cache memorien artean banatzen da informazio hori. Lehenbiziko kasuaren arazoetako bat koherentzia-direktorioaren tamaina izan daiteke; bigarrenean, arazoa zenbait eragiketaren latentzian datza, batik bat kopia kopurua (zerrendaren luzera, beraz) handia bada. Egitura dena delarik ere, pakete asko bidaliko dute prozesadoreek elkarren artean koherentzia mantentzeko, komunikazio-sarea erabiliz, eta, nahitaez, modurik eraginkorrenean prozesatu behar da komunikazio hori guztia, eragiketa arrunten parte bat delako. 7.2.3. Koherentzia-trafikoaren optimizazioa Aurrekoan ikusi dugunez, MPP baten datuen koherentzia mantendu ahal izateko, hainbat mezu edo pakete trukatu behar dira sareko nodoen artean: kontrol- paketeak (motzak) eta datu-paketeak (datu-blokeak, luzeagoak). Pakete horiek guztiak ez dira sortzen exekutatzen ari den aplikazioaren berezko beharrei erantzuna emateko; izan ere, aplikazioa paraleloan exekutatzeagatik ordaindu behar den gainkarga gisa ulertu behar dira. Koherentzia-trafikoak lehiatu egin beharko du komunikazio-sarea erabiltzen duten gainerako paketeekin; beraz, oso garrantzitsua da trafiko berri hori ahalik eta mugatuen mantentzea. Gainera, argi eta garbi, koherentzia-eragiketen latentzia handia izan daiteke (bus batean baino askoz handiagoa), paketeak sortu, transmititu sarean zehar, prozesatu eta abar egin behar delako. Datuen koherentzia ziurtatu egin behar da, baina ezin da onartu prozesadoreak denbora luzez geldituta izatea, ezer egin gabe, edota trafiko handia sortzea. Hori dela eta, prozesadoreen arteko (hobeto esan, mezu-kudeatzaileen arteko) "elkarrizketak" ahalik eta modurik eraginkorrenean egin behar dira. Protokolo jakin baterako, bi dira jorratu behar diren arloak:   - bidaltzen den mezu kopurua (trafikoa) gutxiagotu egin behar da. - prozesu osoaren latentzia (seriean â€”bata bestearen ondorenâ€” bidali behar den mezu kopurua, bide kritikoa) txikiagotu egin behar da.   Bi parametro horiek, eragiketaren latentzia eta sortzen den trafikoa, baxu eta "konstante" mantendu beharko genituzke; hots, prozesadore kopuruarekiko eta, ahal den neurrian, trafiko-egoerarekiko independenteak. Komunikazio-protokolo sinpleena "eskaera/erantzuna" deitutakoa da. Komunikazio mota hori erabiltzen denean, bi prozesadorek baino ez dute parte hartzen komunikazio-eragiketa batean: eskaera egiten duenak eta erantzuna ematen duenak. Ikusiko dugunez, hori ez da erabil daitekeen protokolorik eraginkorrena, baina bai kontrolatzeko errazena, komunikazioko agenteak gutxi direlako eta ondo identifikatuta daudelako (ezaugarri hori garrantzitsua da, esaterako, protokoloak konplexuak direnean eta egoera jakin bat berreskuratu behar denean, tartean errore bat izan delako). Komunikazioaren eraginkortasunaren ikuspuntutik, hala ere, egokia da latentzia eta/edo kontrol- mezuen trafikoa murrizten duten protokoloak izatea. Azter ditzagun, beraz, "eskaera/erantzuna" komunikazio-protokoloa eta ohiko bi optimizazioak. Adibide gisa, honako eragiketa hau kontuan hartuko dugu: irakurketa-huts bat prozesadore batean (L,local node) beste nodo baten (H, home node) memoria nagusiko datu-bloke batean, zeina beste prozesadore baten cachean (R, remote node) kargatuta dagoen, M egoeran. Koherentziarako direktorioa memoria nagusiaren ondoan dago, eta protokoloa MESI motakoa da.   1.Elkarrizketak eskaera/erantzuna motakoak direnean, eragiketa betetzeko bidali behar diren paketeak irudikoak dira. L-k blokea eskatzen dio H-ri, eta hortik etorriko da erantzuna: "datu-blokea R-n dago" (irudiko 1 eta 2 mezuak). Elkarrizketa bukatuta, beste bati ekiten zaio, orain L-ren eta R-ren artean (3 eta 4a mezuak), datu-blokea eskuratzeko. Horrez gain, blokea H-ra ere bidali behar da (4b mezua), memoria nagusia eguneratzeko (bi kopiak S egoeran geratuko dira).   â–ª eskaera/erantzuna  mezuak = 5 bide kritikoa = 4       Irudian ikus daitekeenez, bost mezu bidali dira, eta horietako lau (1â†’2â†’3â†’4) eragiketaren latentzia markatzen duen bide kritikoan daude, seriean sortuko baitira, bata bestearen ondoren. 4a eta 4b paketeak paraleloan, batera, bidal daitezke. 2.Lehenbiziko optimizazioa, intervention forwardingizenekoa, trafikoa murrizten saiatzen da. Hala, H-k ez dio zuzenean erantzungo L-tik heldu den eskaerari; hori egin beharrean, mezu bat bidaliko dio R-ri, datu-blokea eskatzeko (2). R- k H-ri erantzungo dio, datu-blokearekin (3), eta, azkenik, H-k blokea bidaliko du L-ra (4).   â–ª intervention forwarding  mezuak = 4 bide kritikoa = 4     Beraz, arazorik ez zuen nodo batek, H-k, parte hartzen du (intervention) mezu- trukean, eta bigarren eskaera sortzen du, aurrekoa oraindik ebatzi gabe izanik. Bide kritikoa â€”latentziaâ€” ez da txikiagotu, baina trafikoa bai, lau pakete baino ez baitira sortzen.   3.Latentzia hobetzeko, reply forwarding izeneko estrategia erabil daiteke. Datu-blokea bi aldiz seriean bidali beharrean (Râ†’Hâ†’L) paraleloan bidaltzen da, batera: Râ†’H eta Râ†’L.   â–ª reply forwarding  mezuak = 4 bide kritikoa = 3     Trafikoa ez da gutxiagotzen, eragiketa betetzeko eta memoria nagusia eguneratzeko lau mezu behar direlako, baina hiru baino ez daude bide kritikoan: 1â†’2â†’3a. Hala ere, protokoloa bihurriagoa da orain; izan ere, L-reneskaeraren erantzuna R-tik helduko da, L-k ezagutzen ez duen helbide batetik.   Zerrendetan egituratzen diren direktorioetarako ere erabil daitezke ikusi berri ditugun hiru estrategiak. Adibide gisa, irudi honetan baliogabetze- eragiketarako (hiru kopia baliogabetzeko) hiru aukerak ageri dira, L prozesadoretik abiatuta.           eskaera / erantzuna intervention forwarding mezuak= 2k;bide kritikoa= 2k(k= kopia kop.)mezuak = 2k;bide kritikoa=k+1                                            reply forwarding                          mezuak=k+1;bide kritikoa=k+1 7.2.4. Eragiketen atomikotasuna: lasterketak Dagoeneko aztertu dugu lasterketen arazoa â€”adibidez, atomikotasun falta dela eta, datu-bloke baten bi kopia M egoeran geratzen diraâ€”, eta ikusi dugu SMP sistemetan arazoa nola konpon daitekeen, zelataria erabiliz. Direktorioak erabiltzen direnean, ordea, arazoa zailagoa da, eta kontu handiz diseinatu behar dira koherentzia-protokoloak (prozesadoreen arteko komunikazioak) lasterketak ekiditeko. Ikus dezagun adibide bat. Une jakin batean, datu-bloke baten bi kopia daude sisteman, Pi eta Pj prozesadoreetan, S egoeran. Informazio hori eguneratuta dago direktorioan (MN): Pi = 1; Pj = 1; egoera = S. Aldi bertsuan, bi prozesadoreek idazketa bana egiten dute bloke horretan, bertako cacheetan. Ondorioz, mezu bana bidaliko dute biek direktoriora, datu-blokearen kopiak non dauden jakiteko, kopia horiek baliogabetu ahal izateko. Demagun Pi-tik bidalitako mezua heltzen dela direktoriora aurrena; erantzuna bidaliko dio direktorioak (beste kopia bat dago, Pj-n), eta koherentzia-informazioa eguneratuko du (Pj = 0; egoera = M). Ondoren, baina, Pj-tik bidalitako mezua heltzen da direktoriora, H nodora. Tamalez, direktorioan dagoen informazioa eta heldu den eskaera inkoherenteak dira, ez datoz bat: datu-bloke horri buruz dagoen informazioaren arabera, Pj- k ez dauka kopiarik, eta, beraz, ezin ditu besteen kopiak baliogabetu! Zer egin dugu gaizki? Zer egin beharko genuke? Koherentzia-eragiketek atomikoak izan behar dute, hasieratik bukaerara arte interferentziarik gabeak, protokoloaren zuzentasuna ziurtatu nahi badugu. Hala ere, definitu ditugun koherentzia-eragiketak berez dira ez-atomikoak: kontrol- mezuak sarean zehar bidali, eta erantzunen zain geratuko gara. Tartean, noski, beste prozesadore batek eragiketa bat egin dezake bloke horretan, aurreko adibidean ikusi dugunez. Izan ere, eguneratu egin dugu koherentzia-direktorioko informazioa lehenbiziko eskaera prozesatzean, nahiz eta oraindik eragiketa bukatu gabe dagoen, eta hortik etorri da okerra. Beraz, nola ziurtatu eragiketa guztiak modu atomikoan exekutatzen direla? Eragiketen atomikotasuna ziurtatzeko, egoera iragankorrak (busy) erabiltzen dira blokeetarako, cacheetan zein direktorioan, eragiketa betetzen ari den bitartean. Egoera iragankorrean dagoen datu-bloke batekin eragiketa bat egiteko eskaera bat heltzen bada, zer erantzun behar da? Bi aukera daude:   a. Eskaera errefusatu egiten da, eta horretarako NACK (negative acknowledgment) kontrol-mezu berezia bidaltzen da. NACK mezua eskaera egin zuen prozesadorera heltzen denean, bertako koherentziako kontrolagailuak erabaki beharko du zer egin, eskuarki eragiketa bera berriro saiatzea (eskaera berriz bidaltzea). Elkarrizketa hori â€”eskaera / NACKâ€” errepikatu egingo da harik eta blokea egoera egonkorrean izan arte. NACK paketeak erabiltzeak sareko trafikoa igoarazten du, mezu batzuk errepikatu egin behar direlako, baina aukera sinple bat eskaintzen du koherentzia- eragiketak seriean (atomikoki) tratatzeko.   b. Eskaera gorde egiten da, buffer batean (eskuarki, ilara batean), geroxeago tratatzeko. Blokea egoera egonkorrera pasatzen denean, orduan tratatuko dira bloke horretarako ilaran metatu diren eskaerak. Bufferrak erabiliz, trafikoa murriztu egiten da, argi dago, baina bufferrak kudeatzea zaila izan daiteke; esaterako, zenbat eskaera gorde daitezke? zer gertatzen da buffer horiek betetzen badira?...   Abantailak eta desabantailak dituzte bi aukera horiek; horregatik, koherentzia- protokolo komertzialetan ohikoa da, konpondu behar den arazoaren eta egoeraren arabera, bata edo bestea erabiltzea. 7.3. KOHERENTZIA PROTOKOLOEN GAUZATZEA: BI ADIBIDE Koherentzia-direktorioen inguruko gai nagusiak azaldu ditugu aurreko paragrafoetan: egitura, tamaina, komunikazio-estrategiak, eta atomikotasuna. Hurrengo bi ataletan, bi koherentzia-protokoloren gauzatze zehatzak aztertuko ditugu: SGI-ren Origin multikonputagailuetan erabiltzen dena, eta IEEE erakundeko SCI estandarrean definitzen dena (Sequent etxearen NUMA- Q multiprozesadorean erabilia). Izan ere, biak azalduko ditugu kontrako aukerak hartzen dituztelako koherentzia-direktorioa egituratzeko (kontzentratua edo banatua), elkarrizketak gauzatzeko (reply forwarding edo eskaera/erantzuna), eta atomikotasuna mantentzeko (NACK paketeak edo eskaera ilarak). Koherentzia- protokolo horiek oso konplexuak dira; beraz, koherentzia-eragiketa nagusiak eta, orobat, sortzen diren arazoak eta nola konpontzen diren baino ez ditugu aztertuko. 7.3.1. SGI Origin multikonputagailuetako koherentzia- protokoloa Aztertu nahi dugun lehenbiziko protokoloa Origin multikonputagailuena da. DSM (cc-NUMA) motako makinak dira; lehen bertsioan, Origin 2000 (1996), sistemako nodoetan bi MIPS R10000 prozesadore zeuden (biek erabiltzen dute direktorioa, ez dago zelataririk). Gehienez 512 nodo, 1.024 prozesadore, onartzen zituen. Makina horren komunikazio-sarea hiperkubo bat da prozesadore kopurua 64 baino txikiagoa denean. Hortik aurrera, sare hierarkiko bat osatzen da, hiperkuboen hiperkubo bat. Paketeen bideratzea moldakorra da, eta kanal birtualak erabiltzen dira mezu-blokeoak saihesteko. Komunikazio-protokoloa reply forwarding motakoa da34. Koherentzia-direktorioa nodo bakoitzeko MNaren "ondoan" dago. Edukia full bit vector motakoa da (antzekoa). Koherentzia-protokoloa MESI motakoa da, baliogabetzekoa, eta idazketa-politika write-back (ahal den kasuetan). Honako 7 (6+1) egoera hauek erabiltzen dira direktorioan datu-blokeetarako: â€¢ I, E, S. Egoera egonkorrak dira. I eta S egoeren esanahia ohikoa da. E egoerak, aldiz, E eta M egoerak biltzen ditu. Beraz, direktorioko E egoera honela ulertu behar da: kopia bakar bat dago sistemako cacheetan, baina ez dakigu aldatuta dagoenetz35.   â€¢ Busy motako hiru egoera. Egoera iragankorrak dira, eta eragiketen atomikotasuna ziurtatzeko erabiltzen dira. Hirurek esanahi desberdina badute ere, koherentzia-protokoloa azaltzean ez ditugu bereiziko.   â€¢ Beste egoera bat, gauza berezietarako (orri-aldaketak TLBn).   Direktorioan dagoen informazioaz gain, cacheetan ere gordetzen da blokeen egoera (3 bitetan, ohiko egoerak: I, E, S, M eta busy). Aurreko ataleko adibideetan ikusi dugunez, hainbat kontrol-mezu bidali behar dira prozesadoretik prozesadorera koherentzia mantentzeko. Hauek dira adibideetarako erabiliko ditugunak: Rd (datu-blokea eskatzeko); INV (datu-bloke baten kopiak baliogabetzeko); RdEx (datu-blokea eskatu eta kopia guztiak baliogabetzeko); ACK (eragiketa onartzeko); NACK (eragiketa errefusatzeko); eta Wr (datu-bloke bat memoria nagusian idazteko). Koherentzia-protokoloa analizatzean, hiru kasu hauek kontuan hartuko ditugu: (a) cachean ez dagoen aldagai bat irakurtzea; (b) aldagai bat idaztea; eta (c) aldatuta dagoen bloke bat ordezkatzea. Azter dezagun, bada, eragiketa horien exekuzioa, banan-banan. 7.3.1.1. Irakurketak Irakurtzean asmatzen denean, jakina, ez da ezer egin behar (koherentzia dela eta). Beraz, hutsegiteak analizatu behar ditugu: datu-blokea eskuratu behar da, cachean ez dagoelako, eta dagokion egoera esleitu behar zaio. Irakurri behar den blokea H (home) prozesadoreari esleitutako helbide-espaziokoa da, eta, beraz, hango direktoriora jo beharko dugu blokeari buruzko informazioaren bila. Honako mezu hauek trukatuko dira:   1. L-tik H-ra, irakurketa-eskaera bidaltzen da (jakina, bertako memoriako aldagai bat irakurri behar bada â€”H eta L nodo bera badiraâ€”, mezua ez da sarera bidaliko, nodoaren barruan konponduko baita). Tokia erreserbatzen da cachean blokerako, eta busy egoeran jartzen da (hurrengo irudietako 1a eta 1b).   2. Rd mezua H nodora heltzen denean, koherentzia-direktorioa irakurtzen da (denbora aurrezteko, MNa ere irakur daiteke batera). Blokearen egoera direktorioan, hauetako bat izan daiteke:    â€¢ I / S â†’ Ez dago bloke horren kopiarik cacheetan, edo badaude baina koherenteak dira. Beraz, MNko informazioa eguneratuta dago, eta hori izango da L-ra bidaliko dena (2b); horrekin batera, direktorioko informazioa egokitu behar da (2a): L-ri dagokion bita aktibatu (azkena irudietan) eta, kopiarik ez bazegoen (I), blokearen egoera E-ra aldatu (kopia bat dago). 2b mezua L-ra heltzen denean, datu-blokea cachean kargatuko da eta egoera egokituko da: E (direktorioan I egoeran bazegoen) edo S (kopia gehiago baldin badago) (3).             â€¢ E â†’ Datu-blokea ez dago eguneratuta H nodoan (kontuz, E-k "kopia bakarra" esan nahi du, eta ez "kopia bakarra eta koherentea"; hots, baliteke M egoeran izatea dagokion cachean).Reply forwarding motako elkarrizketak erabiltzen direnez gero, H-ri dagokio datu-blokea eskatzea.                 Beraz, blokearen egoera direktorioan aldatu egingo da, E-tik busy-ra, eragiketaren atomikotasuna bermatzeko (2a), eta eskaera-mezu bat bidaliko da H- tik blokea duen prozesadorera, R-ra (2c). Bidenabar, badaezpada ere, H-ko memoria nagusian dagoen datu-blokea bidaliko da L-ra, modu espekulatiboan, agian aldatuta ez dagoelako (2b)36. Eskaera R-ra heltzen denean, aztertu egin behar da blokearen egoera cachean. Egoera, eskuarki, E edo M izango da. Dagoeneko, blokearen egoera S-ra alda daiteke bertako cachean, eta bi mezu sortu behar dira: - Bat, L-rentzat (3b); datu-blokea E egoeran bazegoen (koherentea, beraz), nahikoa da H-tik bidali den blokea baieztatzea: ACK; bestela, M egoeran bazegoen (aldatuta), datu-blokea bidali behar da, H-tik bidali den informazioa eguneratu gabe zegoelako. - Eta beste bat, eduki berekoa, H-rentzat (3c): batetik, direktorioan blokearen egoera S-ra aldatu eta eragiketa bukatutzat emateko (ACK) edo, bestetik, blokea aldatuta bazegoen (M), datu-blokea, memoria nagusia eguneratzeko.   Aipatu dugunez, eragiketa betetzen ari den bitartean, busy da blokearen egoera direktorioan (egoera iragankorra, blokearen gainean eragiketa bat egiten ari delako). Izan ere, ezin da zuzenean E-tik S-ra pasatu 1b mezua heldu denean. Hala egiten bada, erraza da koherentzia-hutsegiteak gertatzea. Adibidez, aurreko eragiketa egiten ari dela, bloke horrekin lan egiteko beste mezu bat heltzen da H nodora, R2 nodotik; bada, H nodoak memoria nagusian dagoen blokea eguneratuta dagoela usteko du (S egoeran dago direktorioan), eta kopia hori bidaliko dio R2-ri... nahiz eta agian blokea aldatuta zegoen R prozesadoreko cachean! Nahitaez, busy motako egoerak erabili behar dira eragiketaren zuzentasuna ziurtatzeko.   â€¢ Busy â†’ Blokeari buruzko informazioa ez dago eskuragarri une horretan, beste eragiketa bat ari baita egiten bloke horren gainean. Atomikotasuna ziurtatzeko, eskaera errefusatu egin behar da, NACK motako mezu bat bidaliz. Erantzuna L- n hartzen denean, erabaki egin beharko da zer egin, eskuarki eskaera errepikatzea, harik eta erantzun egokia eskuratu arte.           7.3.1.2. Idazketak Irakurketak analizatu ondoren, azter ditzagun orain idazketak. Lehenik eta behin, idatzi behar dena E edo M egoeran badago cachean, eragiketa bertan ebazten da; agian blokearen egoera aldatu beharko da, E-tik M-ra, baina, trafikoa gutxiagotzearren, ez zaio direktorioari abisatuko (hori dela eta, ez dira bereizten E eta M egoerak direktorioan). Beste bi kasuak analizatu behar ditugu: - S da blokearen egoera cachean, hots, kopia gehiago daude sisteman. Blokearen kopiak baliogabetu egin behar dira, eta, horretarako, INV motako mezu bat bidali behar da H nodora, han baitago, direktorioan, behar dugun informazioa: kopiak non dauden. - Blokea ez dago cachean (I), hots, huts egin da cachean. H-ra jo behar dugu, blokearen bila eta balizko kopia guztiak baliogabetzeko. Horretarako, RdEx (read exclusive) motako mezu bat bidaliko da. Bi aukerak batera analizatuko ditugu. INV edo RdEx mezua H-ra heltzen denean, hauetako bat izan daiteke blokearen egoera direktorioan:   â€¢ Busy â†’ Blokea egoera iragankorrean dago, eta direktorioak ezin du une horretan erantzun egokia eman. Beraz, NACK mezua bidaliko da eskaera errefusatzeko. Geroago saiatu beharko da berriz.         â€¢ Sâ†’ Kopia guztiak baliogabetu behar dira. Kopien baliogabetzea H-ren esku geratzen da. Horretarako, a. Mezu bat bidaliko da L-ra (2b), non baliogabetu behar den kopia kopurua adierazten baita. Informazio hori beharrezkoa da koherentzia-eragiketa noiz bukatzen den jakin ahal izateko. Horrez gain, egindako eskaera RdEx bazen, datu-blokea bera ere bidaliko da mezu horretan, H-ko memoria nagusian dagoen informazioa zuzena baita (S egoera). b. INV mezu bana bidaliko zaie bloke horren kopia duten prozesadore guztiei (2c, 2d...); helburuetara heltzen direnean, datu-blokearen kopiak baliogabetu egingo dira cacheetan eta ACK mezuak bidaliko dira L-ra â€”idazketa egin duen prozesadoreraâ€” kopiak baliogabetu direla baieztatzeko (3b, 4b...).  L-ren ikuspuntutik, pakete horiek guztiak â€”H-tik bidali den informazioa eta ACK guztiakâ€” heldu direnean bukatzen da koherentzia-eragiketa. Une horretan, M-ra igaroko da blokearen egoera cachean (5).                   Eragiketa betetzen ari den bitartean, zer gertatu zaio blokearen egoerari direktorioan? Blokea, azkenean, E egoeran jarri beharko da, baina horretarako bi aukera dago. Batetik, S egoeratik tarteko busy egoerara eraman daiteke, atomikotasuna ziurtatzeko. Bitartean, bloke horrekin lan egiteko eskaerak heltzen badira H-ra, errefusatu egingo dira. Hala ere, eragiketa horrela betetzen bada, baten batek abisatu egin beharko dio H-ri eragiketa bukatu dela, blokea egoera iragankor horretatik atera eta E egoeran jar dezan. Nork? L prozesadoreak, bera izango baita eragiketa bukatu dela jakingo duen bakarra. Beraz, beste mezu bat bidali beharko da, L-tik H-ra. Badago beste aukera bat: blokearen egoera direktorioanS-tik E-ra aldatzea, nahiz eta eragiketa oraindik bukatu gabe egon. Helburua bikoitza da: trafikoa txikiagotzea (ez da beharrezkoa aipatu dugun azken mezua), eta latentzia txikiagoa izatea (beste eragiketa bat aurrekoarekin tartekatu ahal izango baita). Hala egiten bada, jakina, ziurtatu egin behar da ez dela arazorik izango atomikotasun ezarekin.   Hala, bloke horretarako beste eskaera bat (Rd esaterako) heltzen bada, direktorioak onartu egingo du eskaera, blokearen egoera busy-ra aldatuko du, eta eskaera L-ri pasatuko dio, han egon daitekeelako, duen informazioaren arabera, kopia zilegi bakarra. Eskaera hori L-ra heltzen denean, aurreko eragiketa (baliogabetzea) bukatzeke badago, busy izango da blokearen egoera cachean; beraz zer egin behar da? direktoriotik heldu den eskaera errefusatzea? Ondo legoke koherentzia mantentzeko, baina beste optimizazio bat erabil daiteke orain: mezua buffer batean gordetzea, aurreko eragiketa bukatu arte. Zorionez, eskaera bakarra gorde behar da, ez baita posible eragiketa bukatu baino lehen beste bat jasotzea, direktorioko blokea busy egoeran geratu baita lehenbizikoarekin, eta, ondorioz, hurrengo eskaerak errefusatu egingo dira direktorioan bertan. Origin 2000 konputagailuan, halako optimizazioa erabiltzen da; beraz, S-tik E- ra igarotzen da blokearen egoera direktorioan eragiketaren hasieran (2a); ondorioz, L-ra hel zitekeen eskaera bakarra buffer batean gordeko da, geroxeago tratatzeko.   Azken oharra: eta, tarte horretan, H-ra heltzen den eskaera dagoeneko kopia bat zuen prozesadorekoa bada, R1ekoa? Ikus ezazu, hurrengo kasuan, arazoa nola konpontzen den (egoera direktorioan = E; eskaera = INV).   â€¢ Eâ†’ Kopia bakarra dago, baina ez dakigu aldatuta dagoenetz. H-ra heldu den mezuaren arabera, honako hau gertatuko da:    + RdEx (wr huts). Blokearen egoera direktorioan busy-ra igaroko da (2a), eta memoria nagusian dagoen datu-blokea bidaliko da L-ra, agian egokia delako (2b). Horrez gain, R-ri, datu-blokea duen prozesadoreari, RdEx (Rd + INV) eskaera bidaliko zaio (2c), eskaera egin duenaren (L-ren) helbidearekin batera.                 Mezu hori R-ra heltzen denean, bietako bat izan daiteke blokearen egoera hango cachean: E, koherentea, edo M, aldatuta. Aurreko kasu batean ikusi dugunez, bi mezu bidali behar dira: bata L-ra (3b), H-tik bidalitako blokea baieztatzeko edo, bestela, blokea bera emateko; eta bestea H-ra (3c), eragiketa bukatutzat emateko, eta, agian, blokea memoria nagusian eguneratzeko. Une horretan, blokearen egoera busy-tik E-ra aldatuko da direktorioan (4).   + INV (wr asmatu). Zerbait arraroa gertatu da: S izan behar zuen blokearen egoerak direktorioan, eta ez E (horregatik bidali da INV mezua direktoriora, kopia gehiago zegoelako). Zer gertatu da? Bada, blokearen kopia zuen beste prozesadore batek gauza bera egin du tarte horretan, idaztea, eta INV eskaera bidali du H-ra. Eskaera hori gurea baino lehen heldu da, eta blokearen egoera direktorioan E-ra aldatu da. Izan ere, bidean dago gure kopia baliogabetzeko INV mezua, H-tik bidalita! Atomikotasuna mantentzeko, eskaera errefusatu egin behar da. Finean, INV mezua helduko da L-ra, kopia baliogabetu egingo da, eta idazketa-eskaera errepikatu beharko da, baina orain RdEx moduan, datu-blokea eskuratu egin behar baita.             â€¢ I â†’ Blokearen egoera direktorioan I bada, berriz ere bi kasu bereizi behar dira, L-tik heldu den mezuaren arabera:   + RdEx (wr huts). Ondo, ez dago bloke horren kopiarik inon; blokea E egoeran jarri behar da direktorioan, L-ri dagokion bita 1ean, eta blokea bidali eskatu duenari (2b). Blokea L-n eskuratzen denean, M egoeran kargatuko da cachean, idatzi egingo baita (3).               + INV (wr asmatu). Gerta al daiteke hori? Direktorioan dagoen informazioaren arabera, ez dago inon bloke horren kopiarik! Baina L-k behintzat bazuen kopia bat! Zer gertatu da? Segur aski, honako hau gertatu da: kopia bat zuen beste prozesadore batek (R-k) aldatu du blokea, eta, ondorioz, direktorioan 0010/E egoeran geratu da (gainera, baliogabetze-mezu bat bidali da L-ra, baina oraindik ez da heldu); gero, blokea ordezkatu37 da R-n, eta M egoeran zegoenez, H-ra bidali da, MNa eguneratzeko; ondorioz, blokea 0000/I egoerara pasatu da direktorioan. Ondoren, L-ren mezua heldu da. L-tik bidali den baliogabetze-mezuak ez du dagoeneko esanahirik, eta errefusatu egin behar da; erantzuna, beraz, NACK motako pakete bat da.         7.3.1.3. Memoria nagusiaren eguneratzeak Oinarrizko koherentzia-eragiketen analisia bukatzeko, kasu bat falta zaigu: M egoeran dagoen datu-bloke baten ordezkapena. Ondo dakigunez, ordezkatu (ezabatu) baino lehen, datu-blokea memoria nagusian idatzi behar da (eta direktorioa eguneratu), bestela informazio hori galduko bailitzateke. Horregatik, Wr motako mezu bat bidaltzen da direktoriora eguneratu behar den datu-blokearekin. Direktorioan, blokearen egoerak ezin du I edo S izan, kasu horietan blokea ez baita memoria nagusira bidaltzen (koherentea da); beraz, E egoeran edo busy egoeran egon behar du.   â€¢ E â†’ Blokea E egoeran badago, eragiketa sinplea da: aldatu egin behar da egoera I-ra (dagoeneko ez dago kopiarik sisteman), eta erantzun egin behar zaio L-ri ACK mezu batez. Eragiketa bukatzen denean, blokea desagertu egingo da L-ko cachetik (x).             â€¢ Busy â†’ Kasu hau bitxia da. Memoria nagusian eguneratu behar den blokearen informazioa ezin da erabili une horretan. Interpretazioa bakarra da: gurutzatu egin dira beste prozesadore batek abiatutako eragiketa bat (1b: R-k eskatu dio H-ri L-k duen blokea) eta L-tik abiatutako datu-blokearen idazketa, ordezkapena dela eta (2d).               Direktorioak (H-k) eta ordezkapena egin duenak (L-k) busy egoeran utzi dute blokea; beraz, atomikotasuna mantendu egingo litzateke mezua (irudiko 2d) errefusatu egingo balitz (NACK). Tamalez, errefusatzen den mezuak datu-bloke bat dakar, hau da, luzea da, eta, beraz, trafikoa hazi egingo da (gainera, atzera-aurrera hori hainbat aldiz gerta daiteke). Badugu, hala ere, eragiketa optimizatzeko aukera bat: bi eragiketak konbinatzea. L-tik datorren blokea (2d) R-ri pasatzen zaio (3b), eta eguneratze-eragiketa baieztatu egiten da (3c). Horrekin batera, direktorioko egoera busy-tik E-ra aldatzen da. Azkenik, 2c mezua (blokearen eskaera) L-ra heltzen denean, nahikoa da bertan behera uztea (blokea ez dago cachean!).   7.3.2. SCI koherentzia-protokolo estandarra Sequent NUMA-Q multiprozesadorean. Koherentzia-protokoloen bigarren adibide gisa IEEE erakundeko SCI(Scalable Coherent Interface) estandarrean definitzen dena analizatuko dugu. Koherentzia- informazioa cacheetan banatzen da, esteka bikoitzeko zerrendak osatuz, eta erabili da, esaterako, NUMA-Q multiprozesadorean (Sequent), merkataritza- aplikazioetarako erabili den makina batean, hain zuzen ere (Convex-eko Exemplar-ean ere erabili da, kasu horretan inguru zientifikoetan). NUMA-Q makina multiprozesadore "txikia" da, 32 prozesadorekoa. Nodoak lau prozesadoreko SMP sistemak dira â€”4 Pentium pro, busa, zelatariaâ€” Gehienez, beraz, 8 nodo daude, sare sinple batez konektatuta: eraztun bat (sareko loturak 1 GB/s-koak dira).                 IQ-linkizeneko komunikazio-kudeatzaile berezien bidez konektatzen dira nodoak (4 prozesadoreko txartelak) sarera (eraztunera). Paketeak bideratzeaz gain, koherentziaz ere arduratzen da gailu hori, eta 32 MB-ko "cache" bat erabiltzen du horretarako, remote access cache izenekoa, non beste nodoetatik ekarri diren datu-blokeak (txarteleko cacheren batean kopiatu direnak) gordetzen baitira (antzeko ideia landu dugu busen eta zelatarien hierarkia aztertu dugunean). IQ- link-eko cachea eta barneko cacheek "inklusio-printzipioa" betetzen dute; beraz, urrutiko cachean bloke bat ordezkatzen bada, barneko cacheetan baliogabetu egin behar da. Era berean, bloke bat barneko cachean aldatzen denean, bloke horren egoera urrutiko cachean ere eguneratu behar da. Blokeak 64 bytekoak dira. Datuen koherentzia hierarkikoki mantentzen da; nodoen barruan, bertako zelatariaren bidez (MOESI protokoloa, baliogabetzekoa), eta nodoen artean, IQ cacheetan banatutako direktorio baten bidez, esteka bikoitzeko (aurrera/atzera) zerrendak osatuz: SCI koherentzia-protokoloa. Azter dezagun, gaingiroki bada ere, protokolo horren nondik norakoa38.   7.3.2.1. SCI: egoerak eta eragiketak Bloke baten egoera MNaren eta cacheen artean banatuta dago. MNaren ondoko direktorioan, zerrendako lehen kopiaren helbidea eta blokearen egoera gordetzen dira. Hiru egoera hauetako batean egon daiteke datu-bloke bat:   â€¢ Home: ez dago kopiarik urrutiko cacheetan (zerrenda hutsik dago).   â€¢ Fresh: badaude kopiak, denak berdinak eta koherenteak memoria nagusiko informazioarekin.   â€¢ Gone: MNaren informazioa ez dago eguneratuta; blokea aldatuta dago cacheetan.   Direktorio zati horretan ez dira busy egoerak erabiltzen.   Cacheetan ere blokeei buruzko informazioa gordetzen da (7 bit erabiltzen dira horretarako, eta estandarrak 29 egoera egonkor eta hainbat (asko) egoera iragankor definitzen ditu; gutxi batzuk ikusiko ditugu). Datu-blokeen egoera egonkorrek bi parte dituzte:   â€¢ Blokeak kopien zerrendan okupatzen duen posizioa (non dagoen). Lau aukera daude: Only (kopia bakarra), Head (zerrenda-burua), Mid (erdiko kopia bat), eta Tail (azken kopia).   â€¢ Egoera bera: Dirty (M), Fresh (S), Valid(Sâ€™),Exclusive (E), Stale...   Beraz, hauetako bat izan daiteke datu-bloke baten egoera: Head-Fresh, Tail- Valid, Only-Dirty... Taula honetan egoera arruntenak ageri dira.     Memoria                   Cache memorietan  Nagusian        lehena          erdian           azkena    Home            -                -               -         ez dago kopiarik    Fresh       Only-Fresh           -               -         kopia bakarra,                                                               koherentea (E)    Fresh       Head-Fresh           -           Tail-Valid    bi kopia,                                                               koherentea (S)    Fresh       Head-Fresh       Mid-Valid       Tail-Valid    kopia asko,                                                               koherentea    Gone        Only-Dirty           -               -         kopia bakarra,                                                               aldatuta (M)    Gone        Head-Dirty           -           Tail-Valid    bi kopia,                                                               aldatuta (O/Sâ€™)    Gone        Head-Dirty       Mid-Valid       Tail-Valid    kopia asko,                                                               aldatuta (O/Sâ€™)    Gone      Head-Exclusive         -           Tail-Stale    bi kopia (ping-                                                               pong)39    Gone        Head-Stale           -         Tail-Exclusive  bi kopia (ping-                                                               pong)   Dakigunez, "komunikazio-eragiketa" asko egin behar da datu-blokeak koherenteak mantentzeko. Horiek guztiak ondo betetzeko, hiru koherentzia-funtzio definitzen dira SCI estandarrean:   â€¢ InsertionedoList Construction: zerrendari kopia bat gehitzeko.   â€¢ DeletionedoRoll-Out: zerrendatik kopia bat kentzeko.   â€¢ ReductionedoPurge: zerrendako gainerako kopiak baliogabetzeko.   Hiru funtzio horien bidez bete behar da koherentzia-protokoloa. Komunikazioa dela eta, eragiketa guztiak eskaera/erantzuna motakoak dira. Gainera, ez dira NACK mezuak erabiltzen eragiketak atomikoki, banan-banan, prozesatzeko, bufferrak baizik (salbuespenak egon badaude). SCI estandarrari jarraituz, konplexutasun desberdineko hainbat protokolo defini daitezke: minimal, typical, full... Azter dezagun, adibide batzuen bidez, nola funtzionatzen duen protokoloak ohiko hiru kasuetan: irakurketak, idazketak, eta blokeen ordezkapenak. 7.3.2.2. Irakurketak Aurreko kasuetan bezala, L (local) nodoa eragiketa egiten duena da, H (home) memoria nagusian aldagaia (blokea) duena, eta R (remote) blokearen lehen kopia duena. Aldagai bat irakurri behar da L-n, baina ez dago cachean. Beraz, aldagaia duen blokea eskuratu behar da, eta kopia berria zerrendako lehen posizioan kokatuko da. Horretarako, List Construction koherentzia-funtzioa exekutatu behar da, honela:   1. Erreserbatu egiten da tokia cachean blokerako, eta busy gisa markatzen da. 2. Eskaera bat bidaltzen zaio H-ri. Eskaera H-ra heltzen denean, hauetako bat izan daiteke blokearen egoera MNaren ondoko direktorio zatian:   â€¢ Home â†’ Ez dago bloke horren kopiarik cacheetan. Hau izango da, beraz, lehena. Egoera Fresh-era aldatzen da, eta erakuslea ere aldatzen da, kopia berria erakuts dezan (@L). Azkenik, MNko datu-blokea bidaliko da (2b). Eskatutako blokea L-ra heltzean, cachean kargatuko da, eta egoera Only-Fresh izango da. Beste kopiarik ez dagoenez, ez da erakuslerik gorde behar.             â€¢ Freshâ†’ Bloke horren hainbat kopia daude prozesadoreetako cacheetan, zerrenda batean lotuta, eta zerrenda horren buruan kokatu behar da kopia berria. Horretarako, erakuslea aldatu egiten da (2a), kopia berria erakuts dezan, eta datu-blokea bidaltzen da (2b) â€”MNko kopia Fresh daâ€” bai eta zerrenda-buru zaharraren helbidea ere (@R), L-k berarekin komunikatu dadin, zerrendako estekak egokitzeko.             H-ren erantzuna hartzen denean, datu-blokea cachera eramaten da, busy gisa mantentzen da (beste busy mota bat), eta hurrengo azpieragiketari ekiten zaio: zerrendako buruan kokatzeari. Beraz, mezu bat bidaliko zaio zerrenda-buru zaharrari, zerrendako buru berria (new head) nor den abisatzeko (3). Buru zaharrera heltzen denean, blokearen egoera eta estekak aldatu egingo dira:   Only-Fresh | * - * â†’Tail-Valid|@L- *edo Head-Fresh| * - @R2 â†’ Mid-Valid|@L- @R2   Azkenik, aldaketak egin direla baieztatzeko, ACK motako mezu bat bidaliko da R- tik L-ra (4b); L-ra heltzen denean, blokearen egoera zehaztu egingo da: Head- Fresh| * - @R, eta eragiketa bukatutzat emango da.   â€¢ Gone â†’ Kontuz! Blokearen kopia egokia ez dago MNan, zerrendako buruan baizik (aldatuta). Beraz, kasu horretan ere aurreko guztia egin behar da, baina, jakina, blokea ezin da lortu H-tik, han ez baitago. Zerrenda-buru zaharrari aldaketaz abisatzen zaionean (egoera eta esteka alda ditzan), berak bidaliko dio zerrenda-buru berriari, ACK mezuarekin batera, eskatutako datu-blokea (4b). Blokearen egoera L-ren cachean Head-Dirty izango da (dagoeneko blokea aldatuta zegoelako).   7.3.2.3. Idazketak Idatzi egin ahal izateko, blokearen kopiak zerrendako buruan egon behar du; hau da, zerrenda-buruak baino ez du baimena idazketak egiteko. Gainera, baliogabetze-protokoloa da, hots, kopia bakarra geratuko da idazketa egin ondoren, gainerakoak baliogabetu egingo baitira. Beraz, kasu hauek aztertu behar ditugu: 1. (asmatu / buruan). Zerrendako buruko kopian egin behar da idazketa. Idatzi egiten da, eta gainerako kopiak baliogabetu egin behar dira (INV). â†’ Purgekoherentzia-funtzioa   2. (huts egin). Idatzi nahi den blokea ez dago cachean. Blokea eskuratu egin behar da, eta zerrendako buruan sartu (List Construction); gero, buruan izanik, kopia guztiak baliogabetu behar dira. Hau da, <idatzi/huts = irakurri/huts + idatzi/asmatu> prozesatzen da. â†’List Construction+Purge koherentzia-funtzioak   3. (asmatu / erdian). Aldatu nahi den blokea kopia zerrendako tarteko posizio batean dago. Buruko kopian bakarrik idatz daitekeenez, hau egin behar da idazketa egin ahal izateko: (a) blokearen kopia zerrendatik atera (Roll-Out), eta (b) 2. puntuko eragiketa exekutatu (hutsegite bat). â†’ Roll-Out+List Construction+Purgekoherentzia-funtzioak   Azter dezagun lehenbiziko_kasua: zerrendako buruko kopian idaztea. Koherentzia mantentzeko, gainerako kopiak baliogabetu behar dira, Purge koherentzia- funtzioa exekutatuz, baina egitekoa blokearen egoeraren araberakoa da. Lau aukera ditugu:   1. Datu-blokearen egoera cachean Only-Fresh da, kopia bakarra, beraz. Baliogabetzeko kopiarik ez badago ere, aldatu egin behar da, cachean zein direktorioan, blokearen egoera. Cachean, Only-Dirty egoeran jarri behar da, eta Gone egoeran MNko direktorioan. Informazio hori eguneratzeko, mezu bat bidali behar da H nodora; mezua hartu eta egoera aldatu egingo da: Freshâ†’ Gone. Direktoriotik helduko den baieztapenarekin (ACK) bukatuko da eragiketa.             2. Buruko kopiaren egoera Only-Dirty da. Kasu sinpleena da; kopia bakarra da, eta, gainera, aldatuta dago dagoeneko (MNko direktorioan, Gone egoeran egongo da). Beraz, ez da ezer egin behar koherentzia mantentzeko.   3. Buruko kopiaren egoera Head-Fresh da. Orain bai, kopia bat baino gehiago dagoenez (nahiz eta zenbat diren jakin ez), gainerako kopia guztiak baliogabetu behar dira. Eragiketaren hasieran40, abisatu egin behar zaio direktorioari (1b) egoera alda dezan: Fresh â†’ Gone. Direktorioaren baieztapena heltzen denean (2b), orduan ekingo zaio kopiak baliogabetzeari, honela: â†’ INV mezua bidaliko zaio zerrendako bigarrenari (3); mezua hartzen duenean, blokearen kopia baliogabetu egingo da bertako cachean (egoera = I, eta erakusleak = null), eta erantzuna bidaliko da (4b): eragiketa baieztatzeko â€”ACKâ€” eta hurrengo kopiaren helbidea emateko (R2). â†’ Prozedura bera errepikatuko da gainerako kopiekin. Azkena (Tail) baliogabetzen denean, eragiketa bukatu dela abisatuko da erantzunean, kopia gehiago ez dagoelako. Eragiketaren hasieratik busy egoera iragankorrean mantendu da blokea L-ren cachean. Bukaeran, egoera egokitu egingo da: Only-Dirty.               4. Kopiaren egoera Head-Dirty da. Direktorioan, dagoeneko, Gone egoeran egongo da blokea. Beraz, nahikoa da kopiak ezabatzea, aurreko kasuan egin den modu berean. Ikusi dugunez, baliogabetze-prozesuaren latentzia handia izan daiteke, blokearen kopia kopurua handia den neurrian, banan-banan baliogabetu behar direlako. Adibiderako hartu dugun multikonputagailuan, hala ere, kopia kopurua ez da oso handia izango, sarean 8 nodo baino ez baitaude.   Lehen zehaztu dugun idazketen bigarren_kasua â€”hutsegitea idazketa bateanâ€”, dagoeneko analizatu ditugun bi funtzioen konbinazioaren bidez konpontzen da: List Construction, blokearen kopia bat eskuratzeko eta zerrenda-buruan kokatzeko (idazketa bat egin behar denez, Gone egoeran uzten da blokea MN ondoko direktorioan); eta Purge, gainerako kopiak baliogabetzeko.   Azkenik, hirugarren_kasua aztertu behar dugu, hots, zerrendako buruan ez dagoen datu-bloke batean idaztea. Lehen aipatu dugunez, buruko kopia baino ezin da aldatu; beraz, idatzi ahal izateko, blokea zerrendatik kendu behar da lehenik, eta gero zerrendan berriz sartu, buruan. Bloke baten kopia bat zerrendatik ateratzeko, Roll-Outkoherentzia-funtzioa exekutatu behar da, honela:   1. Mezu bana bidaliko da L-tik R1-era eta R2-ra, aurreko eta hurrengo kopiak hain zuzen ere (L-k baditu haien helbideak), erakusleak egunera ditzaten, iâ€“1 eta i+1 kopiak elkarri lotzeko. Mezu horiek prozesatzen direnean, estekak egokituko dira eta ACK mezuak bidaliko dira L-ra. Erantzunak jaso bitartean (bi ACK mezuak), blokea egoera iragankorrean izango da.             Zerrendan bi kopia baino ez badago, prozedura bera da, baina auzo bakar batekin. Geratuko den kopiaren egoera ere aldatu beharko da: Only-x | *-*.   2. Bi ACK mezuak helduta, A aldagaiaren blokea kopia zerrendatik kanpo dago (haren egoera eragiketaren araberakoa izango da), eta behar izanez gero, hurrengo eragiketari ekingo zaio. Adi, sistema blokeatuta gera daitekeRoll-Out eragiketan. Ondoz ondoko bi prozesadorek desagerrarazi nahi dute zerrendatik; elkarri bidaltzen diote dagokien mezua, eta bestearen erantzunaren zain geratzen dira: sistema blokeatu egin da. Blokeoa erraz gainditu daiteke, baldin eta,busy egoeran ere, mezu mota horri erantzutea nahitaezkoa bada, eta lehentasunak ezartzen badira, honela kasu horretan: zerrenda-burutik hurbilen dagoenak du Roll-Out egiteko lehentasuna.   7.3.2.4. Memoria nagusiaren eguneratzeak Koherentzia-eragiketa behinenen analisia amaitzeko, bloke baten ordezkapena cachean aztertu behar dugu. Nahiz eta datu-blokea memoria nagusiko kopiarekin koherentea izan, Roll-Out eragiketa exekutatu behar da blokea cachetik kentzeko, zerrendaren estekak egokitzeko. Horrez gain, ordezkatzen den blokea Only-Dirty egoeran badago, datuak memoria nagusian gorde beharko dira eta direktorioko informazioa eguneratu (H-n). Egin behar diren eragiketa horiek guztiak analizatu ditugu dagoeneko. Agian merezi du Roll-Out eragiketaren kasu partikular bat aipatzea, idazketak aztertu ditugunean agertu ez den bat: kendu nahi den datu-blokea kopia zerrendako buruan dago. Kasu horretan, honela egin behar da:   1. Mezu bat bidali bigarrenari, blokearen egoera alda dezan: Mid(Tail)-Valid (Fresh) â†’ Head(Only)-Dirty(Fresh). Bitartean, blokea busy egoeran dago. 2. Erantzuna heltzen denean, mezu bat bidali behar da H-ra, direktorioko erakuslea egunera dezan. H nodoaren ACK mezua heltzen denean, eragiketa bukatu da.   7.3.2.5. Atomikotasuna eta lasterketak Aurreko paragrafoetan agerian utzi dugunez, koherentzia-eragiketak ez dira, inolaz ere, atomikoak eta, ondorioz, espero izatekoa da eragiketen arteko interferentziak egongo direla. Gainera, direktorioan, zerrenden hasieran, ez dira busy egoerak erabiltzen. Beraz, nola konpontzen dira interferentzia horiek? Oro har, hau da prozedura: batetik, unean bertan prozesatu ezin diren eskaerak, datu-blokea busy egoeran dagoelako, geroago tratatzeko gordetzen dira; eta, bestetik, heltzen den eskaera dagoen informazioarekin koherentea ez bada, errefusatu egiten da. Ikus ditzagun hiru adibide. 1. Datu-bloke baten kopia zerrendari beste kopia bat gehitzen ari zaio, L1 prozesadorean, eta List Construction eragiketa exekutatzen ari da. Dagoeneko abisatu zaio H-ri, eta horrek zerrenda-buruko helbidea itzuli du eta erakuslea egokitu du, buru berria erakuts dezan. L1 prozesadoreko kopia busy egoeran dago oraindik, eragiketa ez baita bukatu. Tartean, L2 prozesadoreak datu-bloke horren aldagai bat irakurtzen du eta huts egiten du (ez du cachean); ondorioz, eskaera-mezua bidaltzen dio H-ri. Direktorioan dagoen informazioaren arabera, L1 da zerrenda-burua, eta horixe da erantzuna; erantzunarekin batera, zerrendaren hasiera aldatu egiten da direktorioan, L2 erakusteko lehen kopia gisa. Erantzuna hartuta, L2-tik mezu bat bidaliko da L1-era (new head), baina hara heltzean, blokearen egoera busy da oraindik. Zer egin behar da? Mezua errefusatu beharrean, bertan gordetzen da, geroago tratatzeko. Zorionez, eskaera bakar bat gorde behar da, hurrengo eskaera, heltzekotan, L2-ra helduko baita (hara bidaliko du H prozesadoreak), eta, hala, erantzun gabeko mezuen behin-behineko ilara osatuko da. Ilara horretako lehenak eragiketa bukatzen duenean, eta egoera egonkorrera igarotzen denean, erantzun gabe duen mezua prozesatuko du; horrela, kopien zerrenda-burua hedatu egingo da behin-betiko zerrenda osatu arte.                   Estrategia bera erabiltzen da beste kasu askotan ere; esaterako, Purge eragiketa egiten ari den bitartean, antzeko behin-behineko ilaran utziko dira buruan kokatzeko eskaerak.   2. Bloke baten zerrenda-buruak idazketa bat egin behar du, eta, ondorioz, kopia guztiak baliogabetu behar ditu. Haren egoera Head-Fresh da. Baliogabetzeei ekin baino lehen, mezu bat bidaltzen dio H-ri (direktorioari) blokearen egoera alda dezan: Freshâ†’ Gone. Baina, hara heltzen denean, bloke horren egoera direktorioan ez da Fresh, Gone baizik. Posible da? Bai; hau gertatu da: idazketa (huts) bat egin da zerrendan ez dagoen (datu- blokea ez duen) prozesadore batean, eta dagoeneko H-ra (direktoriora) zuzendu da, zerrenda-buruan kokatzeko (List Construction). Beraz, egoeraz gain, erakuslea ere aldatuta dago, kopia berria erakusten baitu. Direktorioan ez dira busy egoerak erabiltzen, baina erraz detektatzen da heldu berri den eskaera ez dela koherentea direktorioko uneko informazioarekin, eta, ondorioz, mezua errefusatu egiten da, NACK motako mezu bat bidaliz. Zerrenda- buruan (ustez) zegoena jadanik ez dago buruan (nahiz eta berak oraindik ez dakien arren), eta berriz saiatu beharko du idazten, bigarren kopia denean, baina beste modu batean (Roll-Out + List Construction + Purge).   3. Azkenik, ikus dezagun beste adibide bat. Cache baten bloke bat ordezkatu behar da, eta bloke hori dagokion zerrendako buruan dago; dagoeneko askatu da zerrendako bigarrenetik, eta direktorioarekin komunikatzen ari den bitartean, eragiketa bukatzeko, beste prozesadore batek bloke horren zerrenda-buruan sartu nahi izan du, eta, jadanik, direktorioan markatu da zerrenda-buru berri gisa (List Construction). Aurreko kasuan bezala, zerrenda-buru zaharraren Roll-Out eskaera heltzen denean, eragiketa ez da koherentea direktorioan dagoen informazioarekin, eta, beraz, errefusatu egin behar da (NACK). Kontuz; zerrenda-buru berriaren mezua zerrenda-buru zaharrera heltzen denean, erantzun berezia eman behar zaio: benetako bigarren kopia non dagoen, alegia.   7.4. LABURPENA DSM motako multiprozesadoreetan, memoria-espazioa bakarra da, baina memoria banatuta dago sistemako nodoen artean. Prozesadore asko eduki ahal izateko, komunikazio-sarea ez da sare zentralizatu bat (busa), mailak, toruak eta abar baizik. Beraz, datuen koherentzia ziurtatzeko ezin dira zelatatze motako estregiak erabili. Koherentzia hardwareaz mantentzeko, direktorioak erabiltzen dira, non datu-bloke bakoitzari buruzko informazioa gordetzen den, hitz bakar batean edo cacheetan banatuta, kopiekin batera. Koherentzia mantentzeak eragin handia izan dezake sistemaren errendimenduan, eta, beraz, ahalik eta modurik eraginkorrenean egin behar da. Mota horretako koherentzia-protokoloak oso konplexuak dira, eta xehetasun handiz aztertu behar dira balizko kasu posible guztiak, irtenbiderik egokiena bilatzeko. Ezin da ahaztu ez dagoela sistema osoa kontrolatzeko gailu zentralizaturen bat; beraz, zaila izan daiteke eragiketen atomikotasuna ziurtatzea eta lasterketak saihestea. Horretarako, batetik, blokeetarako egoera iragankorrak erabiltzen dira, eragiketa hasten denetik bukatu artean; eta, bestetik, NACK motako mezuak bidaltzen dira, prozesatu ezin daitezkeen eskaerak errefusatzeko (edo, zenbait kasutan, gorde egiten dira geroago tratatzeko). Ideia horiek guztiak zertu zituen lehen konputagailua DASH izenekoa zen, eta hortik eratorri dira makina komertzialak (SGI-ko Origin seriea, kasu). Koherentzia-protokoloen bi adibide aztertu ditugu kapitulu honetan; dagoeneko urte batzuk dituzten makinetan erabili dira, baina antzeko ideiak erabiltzen dira gaur egun DSM makina guztietan.                                          â–ª 8â–ª                      BegiztenParalelizazioa etaAtazenBanaketa                    8.1. SARRERA Aurreko kapituluetan, programak paraleloan, P prozesadoreren artean, exekutatu ahal izateko ebatzi behar diren arazo berrietako batzuk aztertu ditugu: datuen koherentzia, sinkronizazioa, komunikazioa, eta abar. Kapitulu honetan, begiztak paraleloan exekutatzeko estrategia nagusiak azalduko ditugu, begiztak baitira programen datu-paralelismoa ustiatzeko gune behinenak. Lehenbiziko kapituluan ikusi dugunez, begiztak bektorialki exekutatzen direnean aginduen jatorrizko ordena galdu egiten da. Gauza bera gertatzen da begiztak (eta, oro har, azpiprogramak) paraleloan exekutatzen direnean; iterazioen exekuzioa hainbat prozesadoreren artean banatuko da, eta, beraz, ez dugu jakingo zein ordenatan exekutatuko diren, ez baitago prozesuen kontrol zentralizaturik. Begizta baten (azpiprogramen) aginduak, ordea, ezin dira edonola desordenatu, haien arteko datu-dependentziak errespetatu egin behar baitira; beraz, aginduen arteko dependentziak analizatu behar ditugu, begizta nola paraleliza daitekeen aztertzeko. Dependentzien analisia 1. kapituluan egin dugun bera da, baina hartuko ditugun erabakiak desberdinak izango dira. Laster ikusiko dugunez, ohiko sinkronizazio-funtzioen bidez betearaziko ditugu aginduen arteko dependentziak, baldin eta dependentzia duten aginduak prozesadore desberdinetan exekutatu behar badira. Programak azkarrago exekutatzea, hau da, kalkulu-abiadura handiagoak lortzea da paralelismoaren helburu nagusia. Amdahl-en legeak dioenez, P prozesadore erabiliz ez dugu lortuko, eskuarki, programa P bider azkarrago exekutatzea, baina saiatu beharko dugu azelerazio-faktorerik handienak lortzen. Nolanahi ere, kontuz ibili behar da; paraleloan exekutatu ahal izateko, gainkarga bat gehituko zaio programari: sinkronizazioa, komunikazioa, datu-banaketa... Hori dela eta, kodea paralelizatzeko ahaleginetan denbora galdu baino lehen (askotan ez baita txikia izango), analizatu egin beharko dugu, sakon, exekutatu nahi dugun algoritmoa, kodea paraleloan exekutatuz zer irabaziko eta zer galduko dugun ikusteko. Analisi horren emaitza nahikoa argia ez bada, segur aski ez du mereziko kodea paralelizatzea; agian, konputagailu paraleloetarako espresuki diseinatutako algoritmo berriak landu beharko ditugu. Oro har, programa bat paraleloan exekutatu ahal izateko, lehenik paraleloan exekuta daitezkeen atazak identifikatu behar dira: begiztak, funtzioak, azpiprogramak... Gero, ataza horiek sistemako prozesadoreetara banatu behar dira (scheduling). Horrekin batera, prozesuen arteko sinkronizazioa zehaztu beharko da, baita datuen banaketa edota komunikazioa ere, erabili behar dugun sistemaren paralelismo-eredua kontuan harturik. Hainbat galdera plantea daitezke prozesu osoari buruz; esaterako, zer motako programak dira egokienak paraleloan exekutatzeko? programa horietatik, zer exekuta daiteke paraleloan eta zer ez? nola jakiten da hori?...   â–ª Paralelismo motak   Zer paralelizatzen den begiratuta, bi paralelismo mota identifika daitezke: datu-paralelismoa eta funtzio-paralelismoa. Datu-paralelismoa erabiltzen denean, prozesu paralelo guztiek algoritmo berdina exekutatzen dute, datu desberdinak prozesatzeko; hau da, datuak banatu eta lokalki prozesatzen dira. Eredu horren adibiderik sinpleena begizta luze baten exekuzio paraleloa da, iterazioen arteko dependentziarik ez dagoenean; esaterako, kasu hau (hiru prozesadore erabiliz):                      P0                    do i = 1, 100000 do i = 1, 300000   A(i) = B(i) + C(i) A(i) = B(i) + C(i) enddo enddo                    P1                    do i = 100001, 200000                    A(i) = B(i) + C(i)                    enddo                     P2                    do i = 200001, 300000                    A(i) = B(i) + C(i)                    enddo   Ikus daitekeenez, ez dago batere arazorik jatorrizko begiztaren exekuzioa paraleloan egiteko, iterazio guztiak independenteak direlako (dagoeneko aztertu dugunez, kodea bektorizatzeko ere kasurik onena da hori). Hiru prozesuak berdinak dira; prozesatzen diren datuak, ez. Datu-paralelismoa maiz erabiltzen da kalkulu asko egiten duten aplikazioetan, datu-egitura handiak eta oso erregularrak prozesatzen baitira. Funtzio-paralelismoa erabiltzen denean, ordea, kalkuluak (prozedurak, funtzioak, azpiprogramak...) banatzen dira prozesadoreen artean. Esaterako, honela banatu daiteke lau "funtzio" dituen programa bat, bi prozesadoreren artean:   Programa (dependentzia-grafoa)P0P1         Prozesadore bakoitzak, beraz, programa osoaren azpimultzo bat exekutatzen du. Hainbat kasutan, bi ereduak batera erabiltzen dira programa baten barruan, zati batzuk modu batean eta beste batzuk bestean exekutatuz. Paralelismoa sailka daiteke, halaber, prozesadoreen artean banatzen diren atazen "tamainen" (exekuzio-denboren) arabera, paralelismoko "alea"ren arabera, alegia. Funtzioak, prozedurak eta abar banatzen direnean, ale larriko (coarse grain) paralelismoa erabiltzen da; begiztak banatzen badira, ale ertainekoa (medium grain); begizta-iterazioak banatzen badira, ale xehekoa (fine grain). Erabiltzen den konputagailu paraleloaren arabera, bata edo bestea interesatuko zaigu. Ale larriko paralelismoa egokia da prozesadore kopurua txikia edo komunikazioaren kostua handia den sistema paraleloetan. Aldiz, paralelismo- maila oso handiko sistemetan, eskuarki ale ertaineko edo xeheko paralelismoa hobesten da, komunikazioaren kostua minimizatu delako eta prozesadore asko erabil daitezkeelako. Ale xeheko edo ertaineko paralelismoa erabili nahi denean, begiztak dira hautagai nagusiak paralelizatzeko, exekuzio-denbora gehiena hortxe xahutzen baita. Lehen aipatu dugunez, bi aukera ditugu begizta paraleloan exekutatzeko: prozesadoreen artean begiztaren iterazioak banatzea (datu-paralelismoa), edo begizta osatzen duten aginduak/atazak banatzea (funtzio-paralelismoa). Adibidez:   do i = 0, N-1 A(i) = A(i) + 1 B(i) = B(i) * 2 enddo     iterazioak banatzea          aginduak banatzea bi prozesadoreren artean   Pprozesadoreren artean  do i = pid, N-1, P          do i = 0, N-1        do i = 0, N-1 A(i) = A(i) + 1             A(i) = A(i) + 1      B(i) = B(i) * 2 B(i) = B(i) * 2             enddo                enddo enddo         pid= 0..Pâ€“1                 P0                       P1   Lehenbiziko kasuan, paralelismo-maila oso handiak eskuratu daitezke, baldin eta prozesadore kopurua handia bada (limitean, N prozesadore baditugu, prozesadore bakoitzak begizta-iterazio bakar bat exekutatuko du). Bigarrenean, aldiz, paralelismo-maila begiztaren gorputzekoa da (oro har, mugatuagoa; adibidean, 2), baina ale-tamaina handiagoa. Eskuarki, aurreneko aukera lehenetsiko dugu.     â–ª Datu-dependentziak: sinkronizazioa   Orain arte ikusi ditugun adibideetan, ataza guztiak independenteak dira, ez baitago datu-dependentziarik haien artean. Hori da, zalantzarik gabe, egokiena, prozesuen exekuzioa erabat independentea izango baita. Eskuarki, hala ere, dependentziak egongo dira atazen artean, eta ezin izango da ataza horiek modu independentean, guztiz paraleloan, exekutatu: programaren semantika errespetatzeko, datu-dependentziak sinkronizazio-eragiketa bihurtu behar dira, dependentzia duten aginduak prozesadore desberdinetan exekutatu behar badira. Adibide honetan, esaterako, P0 prozesadoreak ezin du F3 funtzioa exekutatu P1ek F2 funtzioa exekutatu arte.   Programa (dependentzia-grafoa)P0P1           Sinkronizazioa dela eta, exekuzio-denborak luzeagoak izango dira eta azelerazio-faktoreak txikiagoak. Beraz, sinkronizazioa erabili behar ez izatea izango da kodearen paralelizazioaren helburu nagusietako bat.   â–ª Testuinguru paraleloa   Zer da sistema paralelo batetik espero behar duguna? Bada, aipatu dena: programa batetik abiatuta, prozesu paraleloak sortu, prozesuen artean partekatzen diren datuen kokapen egokia memorian lortu, atazak esleitu, eta dagozkien sinkronizazioa eta komunikazioa adierazi. Programa paraleloen ereduak bi izan ohi dira:Nagusi/Morroi eta SPMD izenekoak. Lehenbiziko kasuan, prozesu nagusiak Pprozesu edo hari (thread) sortzen ditu une jakin batean, morroiak; hari horiek exekutatu, eta, bukaeran, prozesu nagusiari itzuliko diote kontrola. Bitartean, nagusiak ez du ezer egiten, morroi guztien bukaera itxarotea izan ezik (edo, agian, ataza bat utzi du berarentzat). Bigarren ereduan (SPMD, Single-Program-Multiple-Data), aldiz, paraleloan exekutatuko den programa errepikatu egiten da prozesadoreetan, eta modu deszentralizatuan exekutatzen dira kopia guztiak, dagozkien datuekin. Prozesuek aldagai pribatu bana erabiltzen dute â€”pid, prozesuaren identifikadoreaâ€” nor diren adierazteko; aldagai hori erabiliko da, hain zuzen ere, atazak bereizteko: if (pid = i) then ... else ... Oro har, prozesuen edo harien exekuzioa sinkronizatu egin beharko da.Sinkronizazio-mekanismoak 4. kapituluan aztertu ditugunak dira: lock eta unlock funtzioak (edo semaforoak), sekzio kritikoetara sartzeko; hesiak (barrier), prozesu multzo bat puntu jakin batean biltzeko; eta gertaerak (wait, itxaroteko, eta post, abiarazteko), puntutik punturako sinkronizazioa gauzatzeko (ekoizle/kontsumitzaile eredua). Baina, finean, noren ardura da programa modu paraleloan adieraztea? Programa guztiak berriz egin behar dira paraleloan exekutatu ahal izateko? Antzeko kasuetan bezala, bi aukera ditugu: (a) programatzaileak berak adierazten du zer egin daitekeen paraleloan eta zer ez, lengoaia paralelo egokiak (edo lengoaia "arrunten" hedapenak) erabiliz; edo (b) automatikoki egiten da, konpilatzean. Konpiladorea arduratzea lan horretaz da onena; izan ere, programa asko garatu da prozesadore bakarreko sistemetarako, eta aukera izan beharko genuke kode hori guztia sistema paraleloetan ere erabiltzeko, neke edo ahalegin handirik gabe. Horrela, gainera, programa "eramangarriagoak" lortuko genituzke, arkitektura jakin batekiko independenteak. Kasu askotan, ordea, lan hori guztia ez da batere erraza, eta oraindik ez daude eraginkortasun handiko tresna automatikoak kodea paralelizatzeko (salbuespenak salbuespen). Bestalde, prozesadore bakarreko sistemetarako garatutako algoritmoak ez dira askotan egokienak sistema paraleloetarako, eta algoritmo zein programa berriak sortu behar dira, espresuki diseinatuta hainbat prozesadoretan paraleloan exekutatzeko. Beraz, eskuarki, programatzaileak analizatu beharko du programa eta adierazi zer egin daitekeen paraleloan eta nola. Programazio paraleloa bideratzeko, hainbat lengoaia berezi garatu dira, lan- ingurune desberdinetara egokituta (memoria partekatua, memoria banatua...), baina, gaur egun, ohikoena API jakin batzuk â€”OpenMP, MPI...â€” erabiltzea da. Bestalde, lengoaia klasikoak ere egokitu egin dira kalkulu paralelorako (Fortran eta antzekoak)41. Horiekin batera, hainbat tresna automatiko ari dira garatzen, gero eta hobeak, programen exekuzio paraleloaren lagungarri: ataza-banatzaileak, debugger-ak, eraginkortasunaren analizatzaileak... Ez ditugu hemen tresna horiek azalduko. Hurrengo paragrafoetan, aipatu ditugun arazoetako batzuk analizatuko ditugu, batik bat begiztak paraleloan nola exekutatu, ahal bada sinkronizazio-funtzioak erabili behar izan gabe. Azkenik, begizten iterazioak P prozesadoreren artean banatzeko erabil daitezkeen estrategiak aztertuko ditugu. 8.1.1. Oinarrizko ideiak begizten paralelizazioari buruz Iterazioak hainbat prozesadoreren artean exekutatzea da begizten paralelizazioaren helburua. Begizta bat beti "paraleliza" daiteke, baina paralelizazioa ez da beti egokia, komunikazioaren edo sinkronizazioaren kostua ere kontuan hartu behar delako, eta kostu horrek gainditu dezake, aise, P prozesadore erabiltzeagatik lor zitekeen edozein abantaila. Hainbat kasutan, txorakeria da begizta prozesadoreen artean banatzea, askoz denbora gutxiagotan exekutatuko baita prozesadore bakar batean! Bi dira eraginkortasuna galtzeko zio nagusiak. Batetik, begiztaren aginduen arteko datu-dependentziak, haien distantzia 0 ez denean, hau da, iterazioen artean direnean. Dependentzia duten aginduak sinkronizatu beharko ditugu, hainbat prozesadoretan exekutatuko baitira. Eta, bestetik, datu-banaketa; memoria partekatuko makina bat badugu, arazoak izango ditugu datuen partekatze faltsuarekin eta, sistemaren egituraren arabera, busaren transmisio- ahalmenarekin edo mezuen latentziarekin. Analiza dezagun datu-dependentzien eragina adibide batzuen bidez.  (1)  do i = 0, N-1 (1) A(i) = A(i) + 1 (2) B(i) = A(i) * 2 enddo   iterazio-espazioa   Kasurik sinpleena da, iterazio guztiak independenteak direlako (1â†’2 dependentzia d = 0 distantziakoa da). Nahi den moduan banatu daitezke begiztaren iterazioak prozesadoreen artean; kasurik onenean, prozesadore kopurua oso handia bada, iterazio bat prozesadoreko. (2a)  do i = 0, N-2 (1) A(i) = B(i) + 1 (2) B(i+1) = A(i) * 2 enddo   Adibide honetan, 0 distantziako dependentziaz gain, d = 1 distantziako2 â†’ 1 dependentzia dago; ondorioz, prozesadoreek ezin dute lan egin independenteki: P1ek itxaron egin behar du P0k bukatu arte, P2k P1ek bukatu arte, eta abar. Exekuzio paraleloa ez da batere egokia kasu honetan, exekuzio-denbora prozesadore bakar batekoa baino txarragoa izango litzatekeelako, 1 â†’ 2 â†’ 1 dependentzia-zikloa dela medio. Ezinbestean, seriean exekutatu behar da, prozesadore bakar batean.   (2b)  do i = 0, N-3 A(i+2) = A(i) + 1 enddo   Paralelizatu ezin daitezkeen dependentzia-ziklorik sinpleenak d = 1 distantziako errekurrentziak dira (dependentziak bere buruarekin) Hala ere, errekurrentziaren distantzia d > 1 izango balitz (2, 3...) aukera bat izango genuke 2, 3... prozesadorerekin lan egiteko. Esaterako, d = 2 kasuan, P0 prozesadoreak iterazio bikoitiak (0, 2...) exekuta ditzake, eta P1 prozesadoreak iterazio bakoitiak (1, 3...). Modu mugatuan bada ere, paralelismoa aprobetxa daiteke begizta 2 bider azkarrago exekutatzeko (beste arazorik kontuan hartu gabe).  (3) Bi (edo gehiago) dimentsioko begiztek aukera asko dute paraleloan exekutatzeko, bat dimentsioko. Dependentzien arabera, aukera eraginkorrena hartuko dugu. Adibide honetako begiztan ez dago dependentziarik; beraz, bi aukerak erabil daitezke.   do i = 0, N-1 do j = 0, M-1 A(i,j) = A(i,j) + 1 enddo enddo  dopar i = 0, N-1 do j = 0, M-1 A(i,j) = A(i,j) + 1 enddo enddopar      do i = 0, N-1 dopar j = 0, M-1 A(i,j) = A(i,j) + 1 enddopar enddo     Kanpoko begizta (i) paralelizatzen bada, N ataza paralelo sortuko dira, bakoitzean j begizta oso bat exekutatzeko. Aldiz, barneko begizta paralelizatzen bada (j), serieko Nataza sortuko dira (errenkada bakoitzeko bat), bakoitzean M ataza paralelo exekutatzeko.   (4) Oro har, iterazioen arteko dependentziak izango ditugu, eta dependentzia horiek errespetatzeko, iterazioen arteko sinkronizazioa gehitu beharko dugu, baina, aukeran, ahalik eta gutxien. Esaterako, adibide honetako lehenbiziko paralelizazio-saioak ez dirudi oso egokia denik; barruko begizta (j) paralelizatu "omen" da, baina, (0, 1) distantziako errekurrentzia bat dagoenez, Pk eta Pkâ€“1 prozesadoreak sinkronizatu egin behar dira, batean sortzen diren datuak bestean behar direlako. Bigarren saioan, aldiz, paralelizazioa egokia izan da: kanpoko begizta (i) paralelizatu da, eta prozesadore bakoitzari j begizta oso bat esleitu zaio; dependentziak, beraz, prozesadore bakoitzaren barruan geratuko dira.    do i = 0, N-1 dopar j = 1, M-1 A(i,j) = A(i,j-1) + 1 enddopar enddo ?   dopar i = 0, N-1 do j = 1, M-1 A(i,j) = A(i,j-1) + 1 enddo enddopar     Hurrengo ataletan, begiztak paralelizatzeko aukerak, egin daitezkeen optimizazioak, eta iterazioen banaketa analizatuko ditugu, beti ere memoria partekatuko eredua kontuan hartuz.   8.2. BEGIZTEN PARALELISMO-MAILA ADIERAZTEKO EGITURA NAGUSIAK Aipatu dugunez, datu-paralelismoa ustiatzeko eremu egokienak dira begiztak: kalkulu "sinple" batzuk behin eta berriz exekutatu behar dira datu desberdinen gainean. Hori dela eta, hainbat egitura garatu dira lengoaia klasikoetan begizten paralelismo hori agerian uzteko. Begizta bat paraleloan exekutatu behar dela erabaki baino lehen, aginduen arteko dependentzien analisia egin behar da, paraleloan exekutatzen denean, aginduen jatorrizko exekuzio-ordena galdu egiten baita. Analisi horren arabera erabakiko dugu zer exekuta daitekeen paraleloan eta zer ez, gehitu behar den sinkronizazioa, eta abar. Dependentzien analisia ezagutzen dugu dagoeneko: dependentzia-grafoa eta iterazioen espazioa, dependentzien distantzia, ZKH proba, indukzio-aldagaien tratamendua... Dependentzien analisia egin eta gero, hainbat hobekuntza egin beharko ditugu dependentzien eragina â€”sinkronizazioaâ€” arintzeko. Hori guztia baino lehen, ikus ditzagun begizten paralelismo-mailak adierazteko hiru aukera nagusiak. 8.2.1. Iterazioen arteko dependentziarik gabeko begiztak: doall begiztak Kasurik sinpleena da hau. Begizta baten barruan, dependentzia guztiak 0 distantziakoak badira (hau da, iterazioen arteko dependentziarik ez badago), begiztako iterazioak edozein ordenatan exekuta daitezke edozein prozesadoretan, eta hori adierazteko egitura usuena doall izeneko begizta da. Esaterako: do i = 0, N-1 (1)C(i) = C(i) * C(i) (2)A(i) = C(i) + B(i) (3)D(i) = C(i) / A(i) enddo     doalli = 0, N-1 C(i) = C(i) * C(i) A(i) = C(i) + B(i) D(i) = C(i) / A(i) enddoall   Begiztaren iterazioak, beraz, askatasun osoz esleituko dira prozesadoreen artean, ez baitio axolarik zein ordenatan exekutatuko diren. Beraz, doall motako begizta bat exekutatzeko, hainbat ataza independente sortuko dira, nahi den moduan eta tokian exekutatzeko prest; adibidez,  A1 doall i = 1, 5 A2 enddoall A3  Oro har, sinkronizazio-hesi bat izango da doall baten bukaeran, prozesu guztiak sinkronizatzeko (edo kontrola hari nagusiari itzultzeko). Zenbait lengoaiatan, programatzaileak erabaki dezake sinkronizazio-hesi hori bete behar den ala ez. Laburrean: doall motako begizta nahi den moduan exekuta daiteke paraleloan, nahi den prozesadore kopurua erabiliz. Beste arazorik kontuan hartu gabe (partekatze faltsua edo datuen banaketa, komunikazio-sarearen erabilera...), P prozesadore erabiliz, begizta P aldiz azkarrago exekutatuko da. 8.2.2. Iterazioen arteko dependentziak dituzten begiztak Iterazioen arteko dependentziak daudenean, ezin da, besterik gabe, begizta paraleloan exekutatu; dependentzia-grafoaren arabera erabakiko dugu zer eta nola egin. Oro har, hau izango da irtenbidea: iterazio batean aurreko iterazio batean sorturiko datu bat erabili behar bada, sinkronizazio-eragiketak sartu behar dira aginduen eta iterazioen artean, globalak â€”hesiakâ€” edo puntutik puntura â€”gertaeren bidezâ€”. Ikus ditzagun bi aukerak.   8.2.2.1. Forall begiztak(sinkronizazio globala) Kontuan hartu adibide hau:    do i = 1, N-1         1 1 1 1... (1) C(i) = C(i) * C(i)    2 2 2 2... (2) A(i) = C(i) + B(i)    3 3 3 3... (2) D(i) = C(i-1) / A(i) enddo    1 eta 3 aginduen arteko dependentzia d = 1 distantziakoa da, hots, hurrengo iterazio baterantz doa. Demagun Nâ€“1 prozesadoretara banatu direla iterazioak, banan-banan, paraleloan exekutatzeko asmoz. Hala, bigarren prozesadoreak ezin izango du 3 agindua exekutatu harik eta lehen prozesadoreko "baimena" heltzen den arte, han 1 agindua exekutatu dela adieraziz. Hots, sinkronizatu egin beharko dugu prozesadoreen lana (iterazioak): begizta ezin da besterik gabe paralelizatu (ezin da doall egitura erabili). Aginduen arteko dependentzia guztiak grafoan aurrera badoaz, sinkronizazio- mekanismo sinple bat erabil daiteke, hesi bat, honela:                            foralli = 1, N-1     1 1 1 1...                         C(i) = C(i) * C(i)                         A(i) = C(i) + B(i)   2 2 2 2...                         HESIA(...)                         D(i) = C(i-1) / A(i) 3 3 3 3...                         endforall    Prozesadore guztiek 1 eta 2 aginduak exekutatuko dituzte paraleloan, eta, gero, sinkronizazio-hesian sartuko dira. Denak hesian sartu direnean, hesia ireki egingo da, eta denek ekingo diote 3agindua exekutatzeari, batere arazorik gabe, 1iâ€“1â†’3i dependentzia guztiak konpondu baitira. Egitura horri forall (edo doall + barrier) deritzo. Funtsean, jatorrizko begizta bi (oro har, n) segmentutan â€”dependentziarik gabeko ondoz ondoko agindu multzotan, zeinak paraleloan exekuta daitezkeenâ€” banatu da, eta segmentu bakoitza doall moduan exekutatu, tartean sinkronizazio- hesi bat jarrita:          foralli = 1, N-1                         doalli = 1, N-1          C(i) = C(i) * C(i)                       C(i) = C(i) * C(i)          A(i) = C(i) + B(i)            =          A(i) = C(i) + B(i)          HESIA(...)                               enddoall          D(i) = C(i-1) / A(i)          endforall                                [HESIA(...)]                                                    doalli = 1, N-1                                                   D(i) = C(i-1) / A(i)                                                   enddoall   (hainbat inplementaziotan,doallbegiztaren bukaerak sinkronizazio-hesi bat dakar; kasu horietan, tarteko hesia sobera legoke.)  Adi. Erabili dugun hesiak dependentzien arazoa konpontzen badu ere, gehiegizko sinkronizazioa betearazten du; aurreko adibidean, esaterako, ez da beharrezkoa 1 agindu guztiak bukatuta izatea 3 aginduei ekiteko, nahikoa delako Pkâ€“2 prozesadorekoa bukatuta izatea Pk prozesadorean 3 aginduari ekiteko. Hala ere, sinkronizazio-mekanismo sinple eta erraza da.   8.2.2.2. Doacross begiztak("puntutik punturako" sinkronizazioa) Aurreko adibideko aginduen arteko dependentzia guztiak aurrerantz zihoazen grafoan. Kasu orokorrean, ordea, dependentziak gora eta behera joango dira eta dependentzia-zikloak osatuko dira. Dependentzia-zikloak beti konplexuak dira (esaterako, ezin dira bektorizatu), nahiz eta paraleloan exekutatzeko aukeraren bat dagoen (modu mugatuan bada ere). Ikus adibide hau:                                            i=2 3 4 5 6 7                        do i = 2, N-2        1                       (1)                  1                       A(i) = B(i-2) + 1    1                       (2)                  2                       B(i+1) = A(i-2) * 2  2                       enddo                2                                            1 1 1                                            2 2 2   Bi dependentzia daude begizta horretan, bata 2 distantziakoa eta bestea 3koa. Adibidez, i=4 iterazioko 2 agindua ezin da exekutatu i=2 iterazioko 1agindua bukatu arte, eta, era berean, i=5 iterazioko 1 aginduak itxaron egin behar du i=2 iterazioko 2 agindua exekutatu arte. Beraz, begiztako iterazioak paraleloan exekutatu nahi baditugu, sinkronizatu egin beharko dugu aginduen exekuzioa, d> 0 distantziako dependentzia guztietarako. Eta, horretarako, puntutik punturako sinkronizazio esplizitua erabili beharko dugu: gertaerak, hain zuzen ere. Begizta mota hori doacross izenarekin adierazi ohi da. Sinkronizaziorako, adierazle- edo gertaera-bektoreak erabiltzen dira, gertaera- bektore bat dependentziako eta osagai bat iterazioko. Bektore horien gainean, dagoeneko ezagutzen ditugun bi sinkronizazio-funtzio hauek exekutatzen dira:   post(g,i)â†’ aktibatuggertaera-bektorekoiosagaia g(i) = 1; wait(g,i)â†’ itxaronggertaera-bektorekoiosagaia aktibatuta izan arte while(g(i)==0) {};   Aurreko begizta paraleloan exekutatzeko, honelako kodea behar dugu:   doacrossi = 2, N-2 wait(gB,i-3) ; itxaron duela 3 iterazioko2agindua bukatu arte (1)A(i) = B(i-2) + 1 post(gA,i) ; bukatu daiiterazioko1agindua (gAgertaera-bekt.) wait(gA,i-2) ; itxaron duela 2 iterazioko1agindua bukatu arte (2)B(i+1) = A(i-2) * 2 post(gB,i) ; bukatu daiiterazioko2agindua (gB) enddoacross   i iterazioko 1 agindua iâ€“3 iterazioko 2 aginduaren ondoren exekutatu behar da, B bektorean dagoen dependentzia dela eta. Dependentzia hori sinkronizatzeko, gB gertaera-bektorea erabili dugu: wait(gB,i-3). 2 agindua exekutatu ondoren, beraz, adierazi egin beharko dugu i iteraziokoa egina dagoela â€”post(gB,i)â€”. Modu berean sinkronizatu dugu beste dependentzia, A bektorean; 1 agindua exekutatu ondoren, gA gertaera-bektorearen i osagaia aktibatu dugu, eta 2 agindua exekutatu baino lehen, zain geratu gara iâ€“2 iterazioko 1 agindua bukatuta izan arte. Adi: iterazio guztiak paraleloan ari gara exekutatzen, prozesadore desberdinetan; beraz, i iterazioko 1 agindua exekutatu bada ere, litekeena da aurreko iterazioetan agindu hori oraindik exekutatu gabe izatea. Doacross begiztekin ezin da paralelismo-maila alturik erdietsi, dependentzia- zikloek mugatzen baitituzte paraleloan egin daitezkeen lanak. Esaterako, aurreko adibideko begizta exekutatzeko, iterazioak prozesadoreetara banatzen baditugu, alferrik erabiliko ditugu P prozesadore, ez baitugu inoiz izango hiru prozesadore baino gehiago batera lanean (aukera gehiago aztertuko dugu gero). Gainera, azelerazio-faktorea hiru baino txikiagoa izango da, prozesadore bakoitzean 1 eta 2 aginduez gain lau sinkronizazio-funtzio exekutatu behar baitira. Gehitu behar den sinkronizazioaren eta exekutatu behar ziren aginduen exekuzio-denboren erlazioak esango digu paralelizazioak merezi duen ala ez42. Aurreko begizta paralelizatzeko azken erabakia 3 prozesadore baino ez erabiltzea bada, sinkronizazioa arindu egiten da pixka bat, dependentzia batzuk prozesadore bakoitzaren barruan geratuko baitira: kasu honetan, 2 â†’ 1 dependentzia, B bektorean, ez da sinkronizatu behar.                           P0 P1 P2                         12       doacrossi = 2, N-2, 3                         1        A(i) = B(i-2) + 1                         3        post(gA,i)                         1                         4        wait(gA,i-2)                         22       B(i+1) = A(i-2) * 2                         2        enddoacross                         3                         2                         4                           15                         1                         6                         1                         7                         25                         2                         6                         2                         7                         ...   Laburrean: doacross motako begiztek puntutik punturako sinkronizazioa erabiltzen dute iterazioen arteko dependentziak betetzen direla bermatzeko. Eskuarki, paralelismo maila mugatua eskaintzen dute, eta kasu bakoitzean ebaluatu behar da merezi duen ala ez, kostu guztiak kontuan hartuz. Arestian aipatu dugunez, paralelizatzeko kasurik txarrena dependentzia-ziklo bat duen begizta da, non distantzia guztien batura 1 den (oro har, kasu hau: 1iâ€“2iâ€“3iâ†’ 1i+1â€“2i+1â€“3i+1 â†’1i+2â€“...). Esaterako,   do i = 0, N-2 (1)A(i) = B(i) + C(i) (2)B(i+1) = A(i) / 2 enddo   doacross i = 0, N-2 wait(gB,i-1) (1)A(i) = B(i) + C(i) ?? (2)B(i+1) = A(i) / 2 post(gB,i) enddoacross   Une oro, prozesadore bakar bat ari da lanean (i prozesadoreak itxaron egin behar du iâ€“1 prozesadorea bukatu arte); ondorioz, prozesadore bakarrekoa baino luzeagoa izango da exekuzio-denbora, kodea exekutatzeaz gain, sinkronizazio- funtzioak ere exekutatuko baitira. Beste arrazoirik izan ezean, kode hori seriean exekutatu behar da, ez paraleloan.   Ikusditzagunbesteadibide batzuk.     â–ª 1. adibibidea   do i = 1, N-1 (1) A(i) = B(i) + C(i) (2) C(i) = A(i-1) * 2 (3) D(i) = A(i) + A(i-1) enddo   doacrossi = 1, N-1 (1) A(i) = B(i) + C(i) post(gA,i) wait(gA,i-1) (2) C(i) = A(i-1) * 2 (3) D(i) = A(i) + A(i-1) enddoacross   Nahiz eta 1 distantziako bi dependentzia egon, garbi dago nahikoa dela 1iâ€“1â†’2i sinkronizazioarekin (wait), horrekin 1iâ€“1â†’3i sinkronizazioa ere betetzen delako (aginduen arteko ordena errespetatzen bada).   Aurreko adibidean badago beste aukera bat ere; dependentzia guztiak aurrerantz doazenez, sinkronizazio-hesi bat erabil daiteke, honela:   foralli = 1, N-1 (1) A(i) = B(i) + C(i) HESIA(...) (2) C(i) = A(i-1) * 2 (3) D(i) = A(i) + A(i-1) endforall   â–ª 2. adibibidea   do i = 2, N-2 (1)A(i) = B(i) + E(i-2) (2)C(i) = A(i-1) + C(i) (3)D(i) = A(i) * 2 (4)E(i+1) = D(i) - 1 enddo   doacrossi = 2, N-2 wait(gE,i-3) (1) A(i) = B(i) + E(i-2) post(gA,i) wait(gA,i-1) (2) C(i) = A(i-1) + C(i) (3) D(i) = A(i) * 2 (4) E(i+1) = D(i) - 1 post(gE,i) enddoacross   Puntutik punturako sinkronizazioa erabili behar da begizta horretan; ezin da erabili sinkronizazio-hesi bat, dependentzia guztiak ez baitoaz aurrerantz grafoan.     â–ª 3. adibibidea   do i = 0, N-2 do j = 0, N-2 A(i+1,j+1) = A(i+1,j) + 1 B(i,j) = A(i,j) enddo enddo   doacross i= 0, N-2 do j = 0, N-2 A(i+1,j+1) = A(i+1,j) + 1 post(gA,i,j) wait(gA,i-1,j-1) B(i,j) = A(i,j) enddo endoacross   Iterazio-espazioan ageri denez, dela errenkadaka dela zutabeka, prozesadoreen atazak sinkronizatu egin behar dira. Bi dimentsioko bektoreak ditugunez, gertaera-bektoreak ere bi dimentsiokoak dira. (Aukera gehiago dago begizta hori paralelizatzeko; une honetan, gertaera-bektoreen erabilera besterik ez dugu azaldu nahi.) 8.2.3. Antidependentzien eta irteera-dependentzien eragina Kodea bektorizatu behar denean, antidependentziek ez dute arazo handirik sortzen; nahikoa da bektoreak ordena egokian irakurtzea. Aldiz, kodea paralelizatu behar denean, haien eragina handiagoa da, eta kontuan hartu behar dira sinkronizazioa ondo gauzatzeko. Ikus adibidea (antzeko adibidea eman daiteke irteera-dependentziekin):     do i = 0, N-3 (1) A(i) = B(i+2) / A(i) (2) B(i) = B(i) + C(i) enddo                                                  load B                          doacrossi = 0, N-3   <post>                          (1)                  load A                          A(i) = B(i+2) / A(i) /                          post(gB,i)           store A                          wait(gB,i-2)         load C                          (2)                  load B                          B(i) = B(i) + C(i)   +                          enddoacross          <wait>                                               store B   Adibideko antidependentzia datu-dependentzia arruntaren moduan prozesatu da, wait/post sinkronizazio-funtzioen bidez (edo, nahi izanez gero, sinkronizazio- hesi baten bidez). Baina, berez, sinkronizatu egin behar dena beste hau da: i iterazioko lehenengo aginduaren irakurketa, B(i+2), i+2 iterazioko bigarren aginduaren idazketa, B(i), baino lehen egin behar da. Garbiago islatzen da sinkronizazio hori alboko kodean, makina-lengoaiaz idatzita: post eragiketa irakurketa egin bezain pronto exekutatzen da, eta, era berean, wait eragiketa idazketa egin behar denean, ez aurretik. Beraz, sinkronizatu behar badira ere, sinkronizazioa malguagoa da (denbora gehiago ematen du), datu-dependentziekin alderatuta. Behar izanez gero, aldagai laguntzaileak erabil daitezke antidependentziak tratatzeko (bektore-konpiladorearen kasuan ikusi dugun moduan). Esaterako, do i = 0, N-2 A(i) = A(i+1) + 1 enddo  doacrossi = 0, N-2 wait(gA,i-1) A(i) = A(i+1) + 1 ? post(gA,i) enddoacross     do i = 0, N-2 B(i) = A(i+1) A(i) = B(i) + 1 enddo  doacrossi = 0, N-2 B(i) = A(i+1) ld A+1 / [st B] post(gA,i) <post> wait(gA,i-1) <wait> A(i) = B(i) + 1 [ld B] / add / st A enddoacross   B aldagai laguntzailea ez da erabiliko, noski, erregistro libreak baldin baditugu, hor utziko baita irakurritakoa, geroxeago erabiltzeko prest. Irteera-dependentziak modu berean tratatu behar dira; sinkronizazioaren bidez, ordea, idazketen ordena (ez besterik) ziurtatu behar da. 8.2.4 Adi if aginduekin Sinkronizazio-eragiketekin adi ibili behar dugu. Azter ezazu kasu hau:   do i = 1, N-1 (1)if (B(i)>0) then (2) A(i) = A(i) + B(i) (3) C(i) = A(i-1) / 2 endif enddo     doacrossi = 1, N-1 (1)if (B(i)>0) then (2) A(i) = A(i) + B(i) post(gA,i) wait(gA,i-1) ?? (3) C(i) = A(i-1) / 2 endif enddoacross Begizta paralelizatzeko, sinkronizatu egin ditugu 2 eta 3 aginduak, baina kontuz! zer gertatzen da i iterazioko if agindua betetzen ez bada, baina bai gero i+1 iteraziokoa? Garbi dago, i+1iterazioko 3 agindua zain (wait) geratuko da i iterazioko adierazlea ea noiz aktibatzen den, baina hori ez da inoiz gertatuko! Programa ez da inoiz bukatuko: sinkronizazioko blokeo (deadlock) bat dugu. Arazo hori ez izateko, nahikoa da post funtzioak then eta else adarretan exekutatzea (edo bukaeran):   doacross i = 1, N-1 (1)if (B(i)>0) then (2)A(i) = A(i) + B(i) post(gA,i) wait(gA,i-1) (3) C(i) = A(i-1) / 2 else post(gA,i) endif enddoacross   8.3. SINKRONIZAZIOAREN GAUZATZEA Iterazioen arteko sinkronizazioa gauzatzeko, gertaera-bektoreak (eta wait/post funtzioak) erabili ditugu. Sinkronizazio-mekanismo hori oso sinplea da eta erabat malgua, baina baditu desabantaila batzuk:   â€¢ Gertaera-bektoreak hasieratu egin behar dira. Dependentziaren distantzia k bada, lehenengo k iterazioak ez dira sinkronizatu behar; horretarako, lehenengo k osagaiak 1era hasieratu behar dira, eta gainerakoak 0ra, edo, baliokidea dena, sinkronizazio-funtzioa honela egin behar da: if (i>k) wait(...).   â€¢ Memoria-espazio asko behar dute: bit bat iterazio bakoitzeko (edo prozesu/ prozesadore bakoitzeko).   â€¢ Kontuz ibili behar da partekatze faltsuarekin; hots, baliogabetze kopurua murrizteko, gertaera-bektore baten osagaiek memoria-bloke desberdinetan egon beharko lukete.   Hori dela eta, zenbait kasutan egokia da beste irtenbide bat erabiltzea. 8.3.1. Sinkronizazioa kontagailuen bidez Sinkronizazio-eragiketetarakobehardenmemoria-espazioa murrizteko, kontagailuak erabil daitezke, gertaera-bektoreak erabili beharrean. Sinkronizazio-kontagailu batek noraino aurreratu den begiztaren exekuzioan adierazten du. Adibidez, kA = 5 bada, sinkronizazio-kontagailu hori erabiltzen duten aginduek 5 iterazioa exekutatu dute jadanik, baina 6a oraindik ez. Hurrengo iterazioei buruz ez dakigu ezer, agian exekutatu dira edo agian ez; beraz, ez-bukatutzat joko dira. Gertaera-bektoreekin egiten den modu bertsuan, dependentzia duen agindu bat exekutatu baino lehen, aztertu egin behar da dependentzia hori sinkronizatzen duen kontagailuaren balioa, behar den datua kalkulatu den ala ez jakiteko. Sinkronizazio-kontagailuaren balioa ordena hertsian gehitu behar da. Nahiz eta i iterazioko kalkuluak eginak izan, ezin da kA=i"markatu" iâ€“1 iterazio arteko kalkulu guztiak bukatuta izan arte, hots, kA=iâ€“1 izan arte. Bestela, gaizki interpretatuko genuke kontagailuaren esanahia: hots, i-rainoko iterazio guztiak eginda daudela. Beraz, agindu bat exekutatu ondoren, egindakoaren sinkronizazio-abisua eman baino lehen, dagokion txanda itxaron behar da; horrela, sinkronizazio-puntuak ordenatu egiten dira, iterazioen arabera. Funtsean, hau egin da: gertaera-bektore bitarrak (1/0, egina/egiteke, iterazio bakoitzeko) "kodetu" egin dira.   gAgertaera-bektorea sinkronizazio-kontagailua   1      1      1      1      1      0      1        0         ...     â†’ kA= 5  gA1    gA2    gA3    gA4    gA5    gA6    gA7      gA8     kA= 5 â†’ 5eraino, iterazio guztiak eginda daude; hurrengoak ez (ez dakigu).   Sinkronizazio-kontagailuak kudeatzeko, bi funtzio hauek erabil daitezke:   post(k,i) â†’ kontagailuari iterazioko balioa esleitzen zaio, k=i wait(k,i) â†’ itxaron egiten da k<iden bitartean   Ikus dezagun, bi adibidetan, nola erabili kontagailuak sinkronizaziorako.     â–ª 1. adibibidea    do i = 2, N-1 A(i) = B(i) + C(i) D(i) = A(i) + A(i-2) C(i) = 2 * A(i) enddo     doacross i = 2, N-1                       doacross i = 2, N-1  A(i) = B(i) + C(i)                        A(i) = B(i) + C(i)  post(gA,i)                                wait(kA,i-1)k < i-1?  wait(gA,i-2)                              post(kA,i)k = i  D(i) = A(i) + A(i-2)                      [wait(kA,i-2)]  C(i) = 2 * A(i)                           ez da behar  enddoacross                               D(i) = A(i) + A(i-2)                                            C(i) = 2 * A(i)                                            enddoacross   gertaera-bektoreen bidezko sinkronizazioa kontagailuen bidezko sinkronizazioa   â–ª 2. adibibidea   do i = 3, N-1 B(i) = A(i-2) - 1 A(i) = B(i) + 1 C(i) = A(i) + B(i-3) enddo      doacross i = 3, N-1                       doacross i = 3, N-1  wait(gA,i-2)                              wait(kA,i-2)  B(i) = A(i-2) - 1                         B(i) = A(i-2) - 1  post(gB,i)                                wait(kB,i-1)  A(i) = B(i) + 1                           post(kB,i)  post(gA,i)                                A(i) = B(i) + 1  wait(gB,i-3)                              wait(kA,i-1)  C(i) = A(i) + B(i-3)                      post(kA,i)  enddoacross s                             C(i) = A(i) + B(i-3)                                            enddoacross   gertaera-bektoreen bidezko sinkronizazioa kontagailuen bidezko sinkronizazioa   Dependentzia bakoitzerako, sinkronizazio-kontagailu bat erabiltzen da, eta k=iâ€“1 izan arte itxaron egiten da k=i idatzi baino lehen. Gertaera-bektoreekin alderatuta, beraz, malgutasuna galdu egin dugu, baina memoria-espazio asko aurrezten da, eta hasieratzea sinpleagoa da (aldagai bat). 8.3.2. Kontagailu bakar bat prozesadore bakoitzeko Aurreko adibideetan, kontagailu bana erabili dugu dependentzia bakoitza sinkronizatzeko; zenbait kasutan, aldiz, nahikoa da kontagailu bakar bat prozesadore bakoitzeko (ez dependentzia bakoitzeko bat) erabiltzea. Ikus dezagun adibide bat. Begizta hau paralelizatu behar da:    do i = 0, N-6 (1) A(i+2) = B(i+1) - 1 (2) B(i+5) = A(i+1) * 3 (3) C(i) = A(i) + B(i) enddo     1 eta 2 aginduen arteko dependentzia-zikloa dela eta, segur asko ez du merezi 4 prozesadore baino gehiago erabiltzea; demagun irudian ageri den moduan banatzen direla iterazioak lau prozesadoreetara. Bada, nahi izanez gero, nahikoa da prozesadoreak elkarren artean sinkronizatzea, ez aginduak, prozesadore bakoitzeko kPisinkronizazio-kontagailuak erabiliz, honela (adibidez,P2 prozesadoreko begizta):   do i =2, N-6, 4 wait(kP1,i-1) (1)A(i+2) = B(i+1) â€“ 1  wait(kP0,i-2) (2)B(i+5) = A(i+1) * 3 post(kP2,i)  (3)C(i) = A(i) + B(i) enddo   9â€“10 eta 8â€“10 iterazioak (1i-1â†’2i eta 1i-2â†’3i dependentziak, hurrenez hurren) sinkronizatu ditugu, kP1 eta kP0 kontagailuen bidez, eta horrela ez da beharrezkoa 5â€“10 iterazioak (2i-5â†’3i dependentzia) sinkronizatzea, 5 iterazioa 9a baino lehen exekutatu baita P1 prozesadorean. Era berean, 2i-4â†’1i dependentzia ez dira sinkronizatu behar, prozesadore berean exekutatuko baitira. Bukaeran, kP2 bertako sinkronizazio-kontagailuaren balioa gehitu dugu, iterazio horrekiko dependentzia guztiak konpondu direla adierazteko. 8.4. BEGIZTAK ERAGINKORKI PARALELIZATZEKO OPTIMIZAZIO NAGUSIAK Azaldu dugunez, sinkronizazio-funtzioak gehitu behar dira iterazioen arteko dependentziak dituzten begiztak paralelizatu ahal izateko; zoritxarrez, eragin handia dauka horrek lortuko den azelerazio-faktorean eta eraginkortasunean. Beraz, ahal den neurrian, mugatu egin beharko genuke sinkronizazio-funtzioak erabiltzea, dependentziak ezabatuz edo haien eragina arinduz, begiztak transformatuz eta abar doall begiztak, dependentziarik gabekoak, erabili ahal izateko. Ikus ditzagun optimizazio horien adibide esanguratsuenak. 8.4.1. Dependentziak ezabatu edo minimizatu(aldagai eskalarrak, metaketa partzialak...) Begizta baten barruan aldagai eskalarrak erabiltzen direnean, iterazioen arteko dependentziak sortzen dira, mota guztietakoak. Dependentzia horiek desagertu egiten dira aldagai eskalar horiek bektore bihurtzen baditugu (osagai desberdin bat iterazio bakoitzeko), edo, testuinguru honetan baliokidea dena, aldagai pribatu bihurtzen baditugu, hots, prozesadore bakoitzean aldagai desberdin bat. Hona hemen bi adibide: hedapen eskalarra eta errekurrentzia eskalar baten trataera (metaketa partzialak). Bigarren adibidea bektoreen arteko biderketa eskalarra da, eta komenigarria da mota horretako eragiketa bereziak detektatzea, modu eraginkorrean exekutatzeko. Hala, hainbat kalkulu-eskema edo patroi "detektatzen" dira, eta konpiladoreak (programatzaileak) automatikoki sartuko du kode optimizatua eragiketa horietarako, makinaren baliabideak â€”hardwarea eta softwareaâ€” modurik onenean erabiltzeko.   â–ª Hedapen eskalarra                            doalli = 0, N-1 do i = 0, N-1             X(i)= A(i)*A(i) + B(i)*B(i) X = A(i)*A(i) + B(i)*B(i) C(i) = SQRT( C(i) = SQRT(X)            X(i)) D(i) = X - 1              D(i) = enddo                     X(i)- 1                           enddoall                            edo erazagutuXaldagai pribatu gisa (aldagai desberdin                           bat prozesu bakoitzean)  â–ª Metaketa partzialak   (Pprozesadore,pid: 0..P-1)  do i = 0, N-1             do i = pid, N-1, P C(i) = A(i) * B(i)        C(i) = A(i) * B(i) BATURA = BATURA + C(i)    BAT = BAT+C(i) enddo                     enddo                            LOCK(S)                           BATURA = BATURA + BAT                           UNLOCK(S)                            BAT: prozesadore bakoitzeko aldagai pribatua.                           S: sarraila. 8.4.2. Begizten fisioa Begizta hainbat zatitan banatzen da. Fisioaren helburua honako hau da: begizta zati bakoitzari paralelizazio-estrategiarik eraginkorrena aplikatu ahal izatea. Oinarrizko teknika da, eta erabili behar da, esaterako, begizta zati bat paraleloan exekutatu ahal izateko, beste zati bat nahitaez seriean exekutatu behar bada. Jatorrizko dependentzia-grafoa âˆ blokeak deitzen diren zatitan banatzen da: grafoaren nodoen azpimultzotan â€”edo nodo soltetanâ€”, zeinen artean dependentzia-ziklorik ez dagoen. Ikus dezagun adibide bat:     do i = 1, N-2 (1)A(i) = B(i) (2)C(i) = A(i) + B(i-1) (3)D(i) = C(i+1) (4) B(i) = C(i) * 2 enddo       doalli = 1, N-2; bloke hauek paraleloan exekuta daitezke (1)A(i) = B(i) (3)D(i) = C(i+1) enddoall  [hesia]  do i = 1, N-2; bloke hau seriean exekutatu behar da (2)C(i) = A(i) + B(i-1) (4)B(i) = C(i) * 2 enddo Agian merezi du kalkulu sinple bat egitea. Zenbat bider azkarragoa izango da adibide horretako programa paraleloa? Kalkulua sinplifikatzeko, demagun agindu baten exekuzio-denbora T = 1 dela. Serieko programaren exekuzio-denbora, beraz, 4N izango da. Aldiz, programa paraleloaren exekuzio-denbora (sinplifikatuta) beste hau izango da: 2N/P+ 2N+ X, non P prozesadore kopurua den, eta X hesiaren exekuzio-denbora. Beraz, nahiz eta X kontuan hartu ez, azelerazio-faktorea 2 baino txikiagoa izango da beti.               8.4.3. Aginduen berrordenatzea Aukera badago, zikloak osatzen ez direlako, atzera doazen dependentziak aurreranzko dependentzia bihurtu behar dira, kodea berrordenatuz. Hori egin ezean, kode paraleloa ez da batere eraginkorra izango. Adibidez,                                                    t                do i = 1, N-1  doacrossi = 1, N-1                (1)            wait(gB,i-1)       1 2                A(i) = B(i-1)  (1)                1 2                (2)            A(i) = B(i-1)      1 2                B(i) = C(i)    (2)                1 2                enddo          B(i) = C(i)                               post(gB,i)         dena seriean !                               enddoacross                               ??                   do i = 1, N-1  foralli = 1, N-1   21                (2)            (2)                21                B(i) = C(i)    B(i) = C(i)        21                (1)            HESIA(..)          21                A(i) = B(i-1)  (1)                enddo          A(i) = B(i-1)                               endforall     Ordena aldatuta, kodea egoki paraleliza daiteke, hesi bat zein wait eta post sinkronizazio-funtzioak erabiliz. 8.4.4. Dependentzien lerrokatzea(peeling) d= 0 distantziako dependentziek ez dute arazorik sortzen paralelizazio- prozesuan, eta ez dira sinkronizatu behar. Zenbait kasutan, posible da d > 0 distantziako dependentziak dituen begiztatik abiatuta, d= 0 distantziako dependentziak dituen beste begizta bat sortzea (doall), eta, ondorioz, sinkronizazio-eragiketak erabili behar ez izatea. Ikus adibide hau.   do i = 1, N-1 (1)A(i) = B(i) (2)C(i) = A(i-1) + 2 enddo   Jatorrizko begizta paralelizatzeko, nahikoa da 1 eta 2 aginduen artean hesi bat sartzea. Baina badugu beste irtenbide bat: zergatik ez dugu begizta berri bat definitzen, jatorrizko begiztaren iterazio desberdineko aginduak nahasiz, dependentzia guztiak 0 distantziakoak izan daitezen? Aurreko irudian ikus daiteke nola definitu den iterazio berria, i eta i+1 iterazioko aginduak erabiliz: 1i eta 2i+1. Hala, jatorrizko iterazio-espazio osoa zeharkatu daiteke, hasierako eta bukaerako agindu batzuk izan ezik: 21 eta 1Nâ€“1 adibidean. Beraz, honela geratuko da begizta paralelo berria:   C(1) = A(0) + 2  doalli = 1,N-2 ; iterazio bat gutxiago A(i) = B(i) C(i+1)=A(i)+ 2 enddoall  A(N-1) = B(N-1)   Ez dago sinkronizazio-funtziorik! Iterazio guztiak paraleloan exekuta daitezke, nahi den moduan Adibide honetan, jatorrizko bi iterazioko aginduak nahasi ditugu iterazio berria egiteko; hori dela eta, begizta berrian iterazio bat gutxiago exekutatu behar da (oro har, k iterazioko aginduak nahasten badira, kâ€“1 iterazio gutxiago). Ordainean, hasierako eta bukaerako agindu batzuk begiztatik kanpo exekutatu behar dira, eskuarki prozesadore bakar batean43. Dependentziak lerrokatzea ez da beti horren erraza, eta, zenbait kasutan, artifizio batzuk behar dira: agindu batzuk errepikatzea. Hori gertatzen da, esaterako, bi aginduen arteko dependentzia bat baino gehiago dagoenean, baina distantzia desberdinetara. Ikus adibide hau:   do i = 2, N-1 (1)A(i) = B(i) (2)C(i) = A(i-1) + A(i-2) enddo     do i = 2, N-1 (1)A(i) = B(i) (1Â´) X(i) = B(i) (2)C(i) = X(i-1)+ A(i-2) enddo   C(2) = A(1) + A(0) C(3) = B(2) + A(1)  doalli = 2,N-3 A(i) = B(i) --1i X(i+1) = B(i+1) --1'i+1 C(i+2) = X(i+1) + A(i)--2i+2 enddoall  A(N-2) = B(N-2) A(N-1) = B(N-1)  1 agindua errepikatuta, begizta berria osatu dugu jatorrizko begiztaren hiru iterazio erabiliz (beraz, bi iterazio gutxiago egingo dira), eta hasiera eta bukaera bat gehitu izan behar dugu: 22, 23, 1Nâ€“2, 1Nâ€“1. 8.4.5. Hari independenteak sortzea(switching) Dependentzia-zikloak dira, dakigunez, konplexuenak paralizatzeko. Oro har, zikloa osatzen duten dependentzien distantzien batura k bada, hainbat kasutan aukera bat izango dugu k prozesu paralelo exekutatzeko, sinkronizazioa erabili behar izan gabe. Horretarako, peeling moduko estrategia bat erabiliko dugu: begizta berri bat sortu jatorrizko begiztaren iterazio desberdinen aginduak nahasiz. Adibidez,   do i = 0, N-3 A(i+1) = B(i) + 1 B(i+2) = A(i) * 3 C(i) = B(i+2) - 2 enddo     Dependentziak iterazioen espazioan zabalduta, 3 prozesu edo hari paralelo independente sor daitezkeela ageri da, hau bezalakoak:   1i / 2i+1 / 3i+1 // 1i+3 / 2i+4 / 3i+4 // 1i+6 / 2i+7 / 3i+7 // ...   Beraz, honela idatz daiteke begizta, 3 ataza independente sortzeko:   B(2) = A(0) * 3; "prologoa" C(0) = B(2) - 2  doallk = 0, 2; 3 hari paralelo  do i = pid, N-4, 3 ; begiztaren pausoa 3 da A(i+1) = B(i) + 1 B(i+3)=A(i+1)* 3;i+1 iteraziokoa C(i+1)=B(i+3)â€“ 2;i+1 iteraziokoa enddo  enddoall  A(N-2) = B(N-3) + 1 ; "epilogoa"   Hala ere, oso ondo aztertu behar da datuen erabilera, hari bakoitzean ondoz ondokoak ez diren bektore-osagaiak prozesatu behar baitira, eta horrek eragina handia izan dezake sistemaren eraginkortasunean. 8.4.6. Sinkronizazioko eragiketa kopurua txikiagotzea Sinkronizazioa da ordaindu behar den bidesarietako bat kodea paralelizatu ahal izateko. Beraz, ahalik eta gutxien erabili beharko genuke, benetan behar denean baino ez. Horretarako, eragiketen iragankortasuna (trantsitibotasuna) kontuan hartu behar dugu. Esaterako, 1iâ†’2i+1 eta 2i+1â†’3i+2 aginduak sinkronizatu behar badira, ez da beharrezkoa 1iâ†’3i+2 sinkronizazioa egitea, berez gertatuko delako. Adibidez, begizta hau exekutatu behar dugu paraleloan:   do i = 2, N-1 (1) B(i) = B(i) + 1 (2) C(i) = C(i) / 3 (3) A(i) = B(i) + C(i-1) (4) D(i) = A(i-1) * C(i-2) (5) E(i) = D(i) + B(i-1) enddo       Bi begizta hauek ondo sinkronizatuta daudela egiazta daiteke; bigarrenean, baina, sinkronizazio-eragiketa gutxiago erabiltzen dira.                     doacross i = 2, N-1    doacross i = 2, N-1                  (1)                    (1)                  B(i) = B(i) + 1        B(i) = B(i) + 1                  post(gB,i)             (2)                  (2)                    C(i) = C(i) / 3                  C(i) = C(i) / 3        post(gC,i)                  post(gC,i)             wait(gC,i-1)                  wait(gC,i-1)           (3)                  (3)                    A(i) = B(i) + C(i-1)                  A(i) = B(i) + C(i-1)   post(gA,i)                  post(gA,i)             wait(gA,i-1)                  wait(gA,i-1)           (4)                  wait(gC,i-2)           D(i) = A(i-1) * C(i-2)                  (4)                    (5)                  D(i) = A(i-1) * C(i-2) E(i) = D(i) + B(i-1)                  wait(gB,i-1)           enddoacross                  (5)                  E(i) = D                  (i) + B(i-1)                  enddoacross                    i=2                  1 2 3 4 5                   3                  1 2 3 4 5                   4                  1 2 3 4 5    Aginduen ordena errespetatzen bada, 1i>>2i>>3i ... ordena berez beteko da. Adibidez, 2i-1â†’3i sinkronizazioarekin â€”wait(gC,i-1)â€” 1i-1 eta 5i aginduen arteko sinkronizazioa ere betetzen da: 1i-1 >> 2i-1 â†’ 3i >> 4i >>5iïƒž1i-1â†’5i; ondorioz, ez da beharrezkoa post(gb,i)/wait(gb,i-1)sinkronizazio-eragiketak egitea. Bestalde, 2iâ†’4i+2 dependentzia ez da sinkronizatu behar, 2iâ†’3i+1 eta 3i+1â†’4i+2 dependentziak sinkronizatu direlako; beraz, 2iâ†’3i+1â†’4i+2 ïƒž 2iâ†’4i+2. Nolanahi ere den, aurrekoa egia izan dadin, prozesadore bakoitzeko aginduen ordena errespetatu egin behar da. Ildo berean, prozesu bakoitzak iterazio bat baino gehiago exekutatu behar badu, ez dira sinkronizatu behar, noski, prozesu bakoitzaren barruan geratzen diren dependentziak (ikus 8.2.2.2. ataleko adibidea). 8.4.7. Begizten tratamendua (berrordenatzea...) Begizten berrordenatzea (trukea) teknika arrunta da bektore-konputagailuetan, bi (edo gehiago) dimentsioko bektoreak tratatzeko. Kodea paralelizatzeko ere teknika arrunta da, beste modu batean erabiltzen bada ere. Ez ahaztu beti posible dela begizta bat paralelizatzea; beraz, eraginkortasuna bilatzen da ordena-aldaketarekin (sinkronizazioak saihestea, alearen tamaina handiagotzea...). 8.4.7.1. Begizta-trukea Begizten habiratze-ordena aldatu egiten da exekuzio eraginkorragoa lortzeko, bai ale-tamaina handitzeko, bai eta sinkronizazio-eragiketak saihesteko. Jakina, dependentziek agintzen duten ordena errespetatu egin behar da. Adibide jakin bati ekin baino lehen, laburbil ditzagun, eskema batean, bi dimentsioko begiztak paralelizatzeko ditugun aukerak eta haien esanahia.    do i =             do_par i=           doj=                do_par j= do_par j=          do j =              do_par i=           doi=         jatorrizko ordena   jatorrizko ordena  begiztak trukatuta   begiztak trukatuta   iataza serie,      iataza paralelo      jataza serie,      jataza paralelo  bakoitzeanjataza                       bakoitzeaniataza      paralelo                               paralelo   Beraz, kanpoko zein barneko begizta paraleliza daitezke, eta, horrez gain, begiztak trukatu gabe ala trukatuta. Barneko begizta paralelizaturik, ale xeheko paralelismoa lortzen da; kanpoko begiztarekin, aldiz, ale edo atazen tamaina handiagoak lortzen dira. Begiztak trukatu egingo ditugu horrekin sinkronizazio-eragiketa gutxiago erabili behar badira edo, agian, ataza-tamaina handiagotzen bada. Esaterako, azter dezagun adibide hau:   jâ†’ do i = 1, 3 do j = 0, 5 A(i,j) = A(i-1,j) + 1 enddo enddo iterazio-espazioa     do i = 1, 3 do_par j= 0, 5 A(i,j) = A(i-1,j) + 1 enddo_par enddo                             6 prozesadore batera (doall), hiru aldiz, lan gutxi   edo   do_pari = 1, 3 do j = 0, 5 A(i,j) = A(i-1,j) + 1 enddo enddo_par                                     3 prozesadore batera (?), behin, lan gehiago.                                 Adi! sinkronizazioa erabili behar da (doacross)   Irudietan ageri den moduan, bi aukera ditugu begizta paralelizatzeko. Lehenengoan, barneko begizta (j) exekutatzen da paraleloan, eta kanpoko begizta (i) seriean: beraz, errenkadak seriean prozesatzen dira, banan-banan, eta errenkada bakoitzeko lana (zutabeak) paraleloan. Lortzen den paralelismoa handia izan daiteke, baina agian alea txikiegia da. Bigarrenean, paralelismo- maila txikiagoa da, 3 prozesadore baino ez lanean batera; ordainean, prozesadore bakoitzak lan gehiago du egiteko. Zoritxarrez, kasu horretan, begiztako dependentziek prozesadoreak sinkronizatzera behartzen gaituzte (doacross), irudian ikusten den moduan. Badago beste aukerarik? Bai, paralelizatzeko aukerak berriro analizatu behar dira, baina begizta-trukea egin ondoren. Izan ere, adibide horretan zilegi da begizten ordena aldatzea, iterazio-espazioa zutabeka zeharkatzea, datu-dependentzia guztiak errespetatzen baitira. Hori egin ondoren, bi aukera ditugu berriro: kanpoko zein barneko begizta paralelizatzea. Kanpoko begizta, j orain, paralelizatzen badugu, hau lortuko genuke:   do_par j= 0, 5 do i = 1, 3 A(i,j) = A(i-1,j) + 1 end enddo_par  P1                                  6 prozesadore batera,doall, behin, lan ertaina   Ikusten denez, ez dago batere arazorik zutabeak paraleloan exekutatzeko (doall, sinkronizaziorik gabe), aurreko lehen kasuan bezala, eta, gainera, atazen tamaina handiagoa da, zutabe oso bat. Horixe da paralelizatzeko aukera egokia adibide honetan, bestea, begiztak trukatuta barnekoa (i) paralelizatzea, oso txarra baita: ale-tamaina txikia da, eta sinkronizazioa behar du:  do j = 0, 5 do_par i= 1, 3 A(i,j) = A(i-1,j) + 1 enddo_par enddo                             3 prozesadore batera (?,doacross), 6 aldiz, lan gutxi   Laburbilduz, begizta-trukearen helburua paralelismorik handiena (atazen tamaina, ataza kopurua...) lortzea da, kasu guztietan sinkronizazio-beharra minimizatuz. Gogoratu: ezin da edozein aldaketa egin begizten ordenan; hau da araua: "ez da posible aldaketa egitea, baldin eta, aldatu ondoren, dependentzien distantzia- bektoreetako 0 ez den lehen osagaia negatiboa bada".   8.4.7.2. Noranzko-aldaketa Dependentziak direla eta, begizten ordena aldatzea ez da beti posible; hala ere, zenbait kasutan, nahikoa da aldaketa txikiak egitea, esaterako, iterazioen exekuzio-ordenan (atzetik aurrera), begizta-trukea ahalbidetzeko. Adibidez:   do i = 1, 100 do j = 0, 2 A(i,j) = A(i,j) - 1 D(i,j) = A(i-1,j+1) * 3 enddo enddo Kanpoko begizta paralelizatzea ez da oso egokia, prozesadoreak sinkronizatu egin beharko baikenituzke. Barneko begizta paraleliza daiteke, baina paralelismo-maila oso baxua lortuko genuke (3 ataza baino ez). Eta, zoritxarrez, ezin dira begiztak besterik gabe trukatu! Haatik, aukeratxo bat badago, baldin eta j begiztaren ordena aldatzen badugu, eta 2tik 0ra exekutatzen badugu (gauza bera baita horrela edo jatorrizko ordenan, 0tik 2ra, exekutatzea). Beraz, hori da aukera: begiztak trukatu, j begiztaren ordena aldatuta, eta, barneko begizta (orain i) paralelizatu; hala, paralelismo-maila altuagoa lortzen da (100 ataza independente).     do j =2, 0, -1 doall i= 1, 100 A(i,j) = A(i,j) - 1 D(i,j) = A(i-1,j+1) * 3 enddoall enddo     8.4.7.3. Desplazamenduak(skew) Zenbait kasutan, paralelizazioa ez da eraginkorra ez kanpoko ez barruko begiztetan, dependentziak direla eta; esaterako, adibide honetan.   do i = 1,N do j = 1, M A(i,j) = A(i,j-1) + A(i-1,j) enddo enddo   Baina, kasu honetan ere dependentziarik gabeko begizta berria sor daiteke: diagonalean aurrera egiten duen begizta hain zuzen ere. Begizta berria sortzeko, i iterazio bakoitzari dagozkion j iterazioak desplazatu egiten dira, hurrengo irudian ikusten den moduan; eta, gero, begizta-trukea erabiltzen da, paralelizazioa egokia izan dadin.   j=1 2 3 4 5 6 ... ... 9 (M+Nâ€“1)            do i = 1, N do j = 1+(i-1), M+(i-1) A(i,j-(i-1)) = A(i,j-1-(i-1)) + A(i-1,j-(i-1)) enddo enddo     do j = 1, M+N-1 doall i = max(1,j-M+1), min(j,N) A(i,j-(i-1)) = A(i,j-1-(i-1)) + A(i-1,j-(i-1)) enddoall enddo  8.4.7.4. Begizten kolapsoa eta koalestzentzia Begiztak habiratuta badaude (eta txikiak badira) begizten kolapsoa edo koalestzentzia erabil daiteke (hau da, bi dimentsioko begizta dimentsio bakarreko begizta bihurtzea) paralelismo-maila handiagotzeko, adibide honetan ageri den moduan:   do i = 0, M-1 do j = 0, N-1 A(i,j) = A(i,j) + 1 enddo enddo                         kolapsoa                          koalestzentzia     doallk = 0, M*N-1                           doallk = 0, M*N-1    A(k) = A(k) + 1                             i = k/M    enddoall                                    j = k mod N                                                A(i,j) = A(i,j) + 1                                                enddoall    8.5. ATAZEN BANAKETA(scheduling) Begizta bat analizatu eta gero, eta paraleliza daitekeela erabakita, iterazioak banatzeari ekin behar zaio. Doall motako begizta bat bada, iterazio guztiak paraleloan exekuta daitezke, kasurik onenean iterazio bakar bat prozesadore bakoitzean; hala ere, eskuarki ez dugu iterazio kopurua beste prozesadore izango, eta, beraz, banatu egin beharko ditugu iterazioak (oro har, atazak) prozesadoreen artean. Doacross begizta bat bada, erabil daitekeen prozesadore kopurua mugatua da, eta sinkronizazioaren arabera banatu beharko ditugu iterazioak. Iterazioen esleipena edo banaketa modu askotarikoa izan daiteke, baina helburuabeti bera da. Batetik, prozesadoreenlan-karga orekatua mantentzea (load balancing), bestela lortuko dugun azelerazio-faktorea oso kaskarra izango delako; eta, bestetik, sinkronizazio-eragiketen kostua (latentzia, trafikoa) txikia izatea. Laburbilduz: begiztaren exekuziorik ahalik eta eraginkorrena bilatu behar da.                   Exekuzio-denbora â†’     Exekuzio-denbora â†’                 P0bukaera                P0                 P1                       P1                 P2                       P2bukaera                 P3                       P3                   lan-banaketa desorekatua lan-banaketa orekatua   Bi gai aztertu behar ditugu. Batetik, zein iterazio esleitzen diren (prozesadore bakoitzean zer exekutatzen den); eta, bestetik, banaketa noiz egiten den: begizta konpilatzen denean edo exekutatzen denean.   8.5.1. Banatzen diren iterazioak: ondoz ondokoak edo tartekatuak Lehenbiziko sailkapen honetan, kontuan hartzen da zein iterazio banatzen diren prozesadoreen artean, hots, ondoz ondokoak diren ala ez. Bi dira aukera nagusiak:   â€¢ Ondoz ondoko banaketa: ondoz ondoko iterazioak esleitzen zaizkio prozesadore bakoitzari. Esaterako, honela banatzen dira N iterazio P =3 prozesadoreren artean:  iâ†’        0 ...N/3â€“1         N/3 ... 2N/3â€“1         2N/3 ...Nâ€“1 Proz.           P0                     P1                      P2   â€¢ Banaketa tartekatua: begiztaren iterazioak tartekatu egiten dira prozesadoreen artean. Adibidez,  iâ†’    0     1     2     3     4     5       6         7         8      ... Proz.  P0    P1    P2    P0    P1    P2      P0        P1        P2      ...   Adibidean, tartekatze-maila 1 izan da (banan-banan banatu dira iterazioak), baina edozein izan daiteke; esaterako, binaka: P0 â†’ 0, 1, 6, 7, 12, 13...; P1 â†’ 2, 3, 8, 9, 14, 15...; P2 â†’ 4, 5, 10, 11, 16, 17... Limitean, tartekatze-maila N/P denean, ondoz ondoko banaketa egiten da.   Aukeratzen den esleipen-estrategiaren arabera, honela geratuko da prozesadore bakoitzak exekutatuko duen begizta zatia (N = iterazio kopurua, P = prozesadore kopurua,pid = prozesadore-identifikadorea):   doall i = 0, N-1 < > enddoall   â–ª Ondoz ondoko banaketa   do i = (pid)*N/P, (pid+1)*N/P - 1;N/P= zatien tamaina < > enddo   â–ª Banaketa tartekatua, banan-banan44   do i = pid, N-1,P < > enddo Banatu behar den begizta doall motakoa bada (iterazio guztiak independenteak) aurreko bi estrategiak egokiak izan daitezke. Aldiz, begiztaren iterazioak sinkronizatu behar badira, esleipen tartekatua da aukera egokia; izan ere, ondoz ondoko begizta zatiak banatzen badira, exekuzioa (ia) seriean gertatuko da, irudian ageri den moduan.   P0 P1 P2       Bi aukera nagusi horiez gain, ondoz ondokoa eta tartekatua, zenbait kasutan egokiagoak dira beste batzuk lan-karga orekatuta mantentzeko. Esaterako, iterazio bakoitzaren kalkulu kopurua begiztaren indizearen arabera hazten dela baldin badakigu (adibidez, matrize triangeluarrak erabiltzen direnean), doubling izeneko banaketa erabil daiteke: iterazio bikoteak esleitzen zaizkie prozesadoreei â€”1 eta N, 2 eta Nâ€“1...â€”, hau da, iterazio "motz" bat eta "luze" bat, banatzen den konputazio-karga antzekoa izan dadin. 8.5.2. Banketa estatikoa edo dinamikoa Bigarren sailkapen honetan, lan-banaketa noiz egiten den kontuan hartzen da: konpilatzean (finkoa, beraz, programa konpilatzen den unetik), edo exekutatzen den bitartean, atazak bukatu ahala.   8.5.2.1. Banaketa estatikoa Banaketa estatikoa da programa konpilatzen denean egiten bada. Konpiladoreak zein programatzaileak erabakitzen du prozesadore bakoitzean zein begizta- iterazio exekutatuko diren. Banaketa estatikoa erabiltzen bada, ez zaio batere gainkargarik gehitzen programaren exekuzio-denborari iterazio-esleipena dela eta, baina (a) aurretik jakin behar da exekutatuko den iterazio kopurua (askotan, kopuru hori programan bertan kalkulatzen da); eta (b) zaila da lan-karga prozesadoreen artean modu orekatuan banatzea, ez baitakigu, oro har, zenbat denbora kostatuko den begiztako iterazio jakin bat exekutatzea (esaterako, if bat dagoelako, datuak nola dauden banatuta ez dakigulako...). Beraz, sinplea da, baina baliteke oso eraginkorra ez izatea. 8.5.2.2. Banaketa dinamikoa Lan-karga orekatua izan dadin, iterazioen esleipen dinamikoa egin daiteke, programa exekutatzen ari denean, hain zuzen ere. Exekuzioan, prozesu bakoitzak begiztaren iterazio kopuru jakin bat hartzen du exekutatzeko; begizta zati horren exekuzioa bukatzen duenean, beste zati bat hartzen du, harik eta prozesu guztien artean begizta osoa exekutatzen duten arte. Banaketa mota horrek karga bat gehitzen dio begiztaren exekuzioari, kalkuluaz gain banatze-prozedura ere exekutatu beharko baita prozesu bakoitzean; gainkarga hori, jakina, ahalik eta txikiena izan beharko luke. Hainbat estrategia erabil daitezke begizta jakin baten iterazioak ahalik eta egokien banatzeko. Alde batean, tamaina_bereko_begizta_zatiak banatzen dituzten metodoak daude; bestean, gero_eta_zati_txikiagoak banatzen dituztenak. Azter ditzagun banaketa dinamikoko estrategia erabilienak.   8.5.2.2.1. Autobanaketa(self-scheduling) Begizta-iterazioak banan-banan banatzen dira; hau da, prozesadore batek iterazio baten exekuzioa bukatzen duenean, beste iterazio bat exekutatuko du, une horretan dagokiona: egiteke dagoen lehena, hain zuzen ere. Honela programatu daiteke estrategia hori:                               LOCK(SAR);                             nirea = hurrengoa;                             hurrengoa = hurrengoa +                             1;                             UNLOCK(SAR);      doall i = 0, N-1      A(i) = B(i) + C(i) â†’ while (nirea â‰¤ N-1) do      enddoall               A(nirea) = B(nirea) + C(nirea);                              LOCK(SAR);                             nirea= hurrengoa;                             hurrengoa = hurrengoa + 1;                             UNLOCK(SAR);                             endwhile                              [Lock/unlock â†’ nirea = Fetch&Inc(hurrengoa)]   Prozesadore bakoitzak iterazio bakar bat exekutatzen du, eta, bukatutakoan, beste bat eskuratzen du. Iterazioak esleitzeko, kontagailu bat erabiltzen da, hurrengoa, zeina modu atomikoan erabiltzen baita SAR sarrailaren bidez. Oso modu orekatuan banatzen dira iterazioak, banan-banan, baina sinkronizazio- kostua handia izan daiteke, batik bat iterazio soil bat exekutatzeko denbora oso txikia bada (adibideko kasua, esaterako). Beraz, banaketa egokia izan dadin, Texe >> Tsink izan beharko du. 8.5.2.2.2. Zatikako banaketa(chunk scheduling) Aurreko kasuko sinkronizazioko gainkarga arintzeko, begizta zati handiagoak banatu daitezke esleipen-eragiketa bakoitzean (Z tamainakoak, ondoz ondoko iterazioak45). Honela:                              LOCK(SAR);                            nirea = hurrengoa;                            hurrengoa = hurrengoa +                            Z;                            UNLOCK(SAR);     doall i = 0, N-1     A(i) = B(i) + C(i) â†’ while (nirea â‰¤ N-1)     enddoall               do i = nirea,                            min(nirea+Z-1,N-1)                            A(i) = B(i) + C(i)                            enddo                             LOCK(SAR);                            nirea= hurrengoa;                            hurrengoa = hurrengoa +                            Z;                            UNLOCK(SAR);                            endwhile                             [Lock/unlock â†’ nirea = Fetch&Add(hurrengoa,Z)]   Aurreko kasuan bezala, hurrengoa kontagailuak kontrolatzen du egindako lana, eta esleipen bakoitzean Z gehitzen zaio. Dagokion begizta zatia (Z iterazio) bukatzen denean, beste zati bat esleitzen zaio prozesadore bakoitzari, iterazio guztiak bukatu arte. Beraz, sinkronizazio-karga arindu egin da, ez baita exekutatzen esleipen-eragiketa bat iterazio bakoitzeko, Z iterazioko baizik. Ordainean, baliteke lan-karga aurreko kasuan bezain ongi banatuta ez izatea (oro har).   8.5.2.2.3. Autobanaketa gidatua(GSS, guided self-scheduling) Aurreko kasuan esleitzen diren begizta zatiak tamaina finkokoak dira (Z iterazio). Baina ez dakigu banatzen den lan-karga orekatua den ala ez, zati bakoitzaren exekuzio-denbora ezezaguna delako (esaterako, if A then B aginduak exekuzio-denbora desberdinak ditu A-ren arabera). Beraz, gerta daiteke esleitzen den azken zatiaren exekuzio-denbora oso luzea izatea, eta une horretan ez dago erremediorik: prozesadore bakar bat izango dugu lanean, besteak itxaroten ari direla. Badirudi, beraz, ez dela oso egokia, zenbait kasutan, tamaina finkoko zatiak esleitzea. Lan-karga orekatzeko, esleitzen diren zatien tamaina aldakorra izatea aproposa izan daiteke, eta, hain zuzen, begizta zati gero eta txikiagoak esleitzea: bukaerara hurbiltzen garenean, banaketa gero eta "finagoa" izatea. Horixe bera bilatzen du GSS izeneko banaketak, eta horretarako begizta zati hauek banatzen dira:  Zs = ïƒ©(N â€“ i) / Pïƒ¹(zati osoa goitik46)   non N â€“ i une horretan exekutatzeko geratzen den iterazio kopurua den, eta P prozesadore kopurua; hau da, exekutatzeko geratzen denaren "bere partea" hartzen du prozesadore bakoitzak. Banaketa aurreko kasuan bezala egiten da, baina Z ez da konstante bat. Badago banaketa horren aldaera bat, factoring izenekoa; estrategia horretan, esleipen-eragiketa bakoitzean tamaina bereko P zati banatzen dira, zatien tamaina honako hau izanik: (Nâ€“ i)/ 2P; hots, exekutatzeko geratzen diren iterazioen erdia prozesadore guztien artean banatzen da. Ez ahaztu: agian lan-karga orekatuagoa lortuko da autobanaketa gidatua erabiliz, baina esleipen-kostua handiagoa izango da, zatien tamaina kalkulatu egin behar baita esleipen-eragiketa bakoitzean (zatiketa bat egin behar da). Gainkarga hori murrizten saiatuko gara azkeneko aukeran.   8.5.2.2.4. Autobanaketa trapezoidala(trapezoid self-scheduling) Aurreko kasuan bezala, esleitzen diren begizta zatien tamainak gero eta txikiagoak dira; hala ere, banaketak gehitzen duen karga arintzeko, begizta zatien tamaina kalkulatzeko ez da zatiketa bat egiten, kenketa bat baizik. Honela kalkulatzen dira, beraz, begizta zatien tamainak:     Zs+1 = Zs â€“ k       Esleituko diren zatirik handiena eta txikiena, Z1 eta Zn, eta k konstantea, aurretik definitu behar dira. Begizta zatien tamainek serie aritmetiko bat osatzen dute, eta haien baturak N izan behar du (iterazio kopuru osoa); beraz, zati handiena eta txikiena definituta, honela kalkula daiteke k parametroa:     Laburrean. Paraleloan exekutatu behar diren atazak â€”begizta-iterazioak zein prozedurak, funtzioak edo azpiprogramakâ€” prozesadoreen artean banatu behar dira (kasurik sinpleenean, prozesadore kopurua ataza kopurua baino handiagoa denean, prozesadore bakoitzak ataza bat, edozein, exekutatuko du). Lan-karga orekatua bilatu behar da, prozesadore guztiak lanean izateko. Atazen exekuzio-denbora aurreikus daitekeenean, egokiena banaketa estatikoa da, ez baitu inongo gainkargarik gehitzen; bestela, banaketa dinamikoa erabil daiteke, atazak exekutatu ahala esleitzeko. Nolanahi ere den, esleipen-eragiketen exekuzio- denborak atazen exekuzio-denbora baino askoz txikiagoa izan behar du. Bestalde, begizta-iterazioen kasuan, esleitzen den iterazio kopurua datu-blokeko tamainaren multiploa izatea egokia da, cacheko partekatze faltsua saihesteko. Laburpen gisa, taula honetan N = 1.000 etaP = 4 kasuan banatzen diren begizta baten iterazio kopuruak ageri dira, estrategia dinamikoren arabera.                           Zatika             GSS                     TSS                        (Chunk)        Zs=ïƒ©(Nâ€“i) /Pïƒ¹  Z1= 76,Zn= 4 â†’k= 3                         Z= 100                 1         100               250                     76                2         100               188                     73                3         100               141                     70                4         100               106                     67                5         100                79                     64                6         100                59                     61                7         100                43                     58                8         100                34                     55                9         100                25                     52                10        100                19                     49                11         /                 14                     46 esleipen-      12                           11                     43 eragiketa      13                           8                      40                14                           6                      37                15                           5                      34                16                           3                      31                17                           3                      28                18                           2                      25                19                           1                      22                20                           1                      19                21                           1                      16                22                           1                      13                23                           /                      10                24                                                   7                25                                                   4                                                                     /        kopurua         10 (N/Z)             22                     25 8.6. ATAL PARALELOAK: FORK / JOIN Hasieran aipatu dugunez, begiztak dira paralelizatzeko hautagairik onenak (kalkulu intentsiboko aplikazioetan, behintzat). Baina paralelismoa ustiatu daiteke, halaber, prozedura- edo funtzio-mailan (edo, ale xeheko paralelismoan, aginduen artean), paraleloan, aldi berean, exekuta daitezkeen atalak (sections) definituz. Paralelismo mota hori adierazteko hainbat aukera daude, eta erabilienak Fork / Join eta Parallel Sections sasiaginduak dira. Fork sasiaginduak ondoren datorren lana prozesadoreen artean, arazorik gabe, banatu daitekeela adierazten dio konpiladoreari; Join, aldiz, ataza guztiak sinkronizatzeko puntua da (hesi bat), berriro exekuzio sekuentzialarekin jarraitu ahal izateko. Gauza bera adierazten da "Parallel Sections/ End Parallel Sections" sasiaginduen bidez. Hona hemen adibide sinple bat, non bost funtzio exekutatu behar diren, paraleloan:   Atazen dependentzia-grafoa Kodea   Fork;atal paraleloa (2 proz.) F1; F2; Join;bukaera  Fork;atal paraleloa (2 proz.) F3; F4; Join;bukaera  F5;   Hau da, hasieran bi thread edo prozesu paralelo sortzen dira, batean F1 eta bestean F2 funtzioak exekutatzeko. Bukatutakoan, bi prozesuak sinkronizatu egiten dira, hurrengo "atal paraleloari" ekin baino lehen, non F3 eta F4 funtzioak exekutatuko diren. Azkenik, F5 funtzioa exekutatuko da, prozesadore bakar batean.   Behar izanez gero,Fork/Join sasiaginduak ezagutzen ditugun egituren bidez (doall eta hesiak) simula daitezke, bai eta alderantziz ere, doall begizta bat sortu Fork/Join erabiliz; esaterako, honelakoa izango litzateke aurreko adibiderako: doall k = 0, 1 ; bi iterazioak paraleloan if ( pid = 0) thenF1;; P0k egiten duF1funtzioa if ( pid = 1) thenF2; ; P1ek egiten duF2funtzioa enddoall  [ HESIA(...) ]  doall k = 0, 1 ; bi iterazioak paraleloan if (pid = 0) then F3; if (pid = 1) then F4; enddoall  [ HESIA(...) ]  F5; ; prozesadore batean   8.7. ERAGINKORTASUNAREN ANALISIA Begizta bat P prozesadoretan, paraleloan, exekutatzen denean, helburua, noski, begizta P aldiz azkarrago exekutatzea da. Kapitulu honetan, begiztak paralelizatzeko dauden estrategia nagusiak aztertu ditugu. Ez da erraza, hala ere, azelerazio-faktore handienak eskuratzea, tartean hainbat arazo daudelako. Lehenengoa, bistan da, prozesadore kopurua da. Sistema paraleloak 4 prozesadore baditu, azelerazio-faktorea ez da inoiz 4 baino handiagoa izango. Baina badaude hain azalekoak ez diren arazoak. Esaterako, sistemaren arkitekturak eta datuen kokapenak erabateko eragina dute exekuzio-denboran. SMP makina batean, datuek busa erabiltzen dute MNtik CMetara (eta alderantziz) joateko, eskuarki blokeka. Bi arazo daude: batetik, busa bera, eta, bestetik, datu-partekatzea. Ataza paraleloak oso txikiak badira (ale xeheko paralelismoa; esaterako, kapitulu honetan erabili ditugun begizta-iterazioak), prozesadoreek behin eta berriz eskatuko dituzte datu-blokeak, eta baliteke busa erantzun azkarra emateko gauza ez izatea; ondorioz, exekuzio-denborak luzeagoak izango dira eta azelerazio-faktorea txikiagoa. Bestalde, atazak banatzeko, datuak non dauden kontuan hartu beharko da. Esaterako, begizta baten i eta i+1 iterazioetan prozesatu behar diren datuak memoriako datu-bloke berean badaude, egokiena iterazio horiek prozesadore berean exekutatzea izango da, eta ez bi prozesadoretan, kasu horretan partekatze faltsuko arazoa izango baitugu, eta, ondorioz, litekeena da datu-bloke horiek behin eta berriz baliogabetu behar izatea, koherentzia mantentzearren, nahiz eta blokeko aldagai guztiak pribatuak izan. DSM motako (prozesadore askoko) sistemetan antzeko arazoak ditugu, baina kasu honetan datuen kokapenaren arazoa larriagoa da, memoria nagusia sistemaren nodo guztien artean banatuta baitago. Beraz, oso garrantzitsua da datuak non dauden kontuan hartzea atazak banatu baino lehen, komunikazio-sarea ahalik eta gutxien erabili behar izateko. Aurrekoaz gain, atazen sinkronizazioaren eragina ere nabarmena da. Atazen exekuzio-denborei prozesuen sinkronizazioaren kostua (denbora) gehitu behar zaie. Sinkronizazioaren gainkarga nolakoa izango den aurreikusi behar da, makinaren lan-kargaren, egituraren, komunikazio-sarearen eta abarren arabera. Esaterako, sinkronizazio-eragiketen exekuzio-denbora milisegundo batzuk bada eta atazena segundo batzuetakoa, ez dago arazorik, sinkronizazioaren kostua mespretxagarria baita; aldiz, atazak mikrosegundokoak badira, sinkronizazioaren kostu hori onartezina da: paraleloan exekutatzen diren atazak "txikiegiak" dira sistema horretarako. Beraz, sinkronizazioaren eta ataza paraleloen exekuzio- denboren arteko erlazio "egokia" bilatu behar da. Ezaugarri horiek guztiak balioetsi behar dira programa jakin bat paralelizatzeko unean, horien araberakoa izango baita sistematik lortuko dugun eraginkortasuna.                                         â–ª 9â–ª                           AbiaduraHandikoKonputagailuak.                                  OpenMP etaMPI:                   ProgramaParaleloakSortzekoTresnak(sarrera).            Aurreko kapituluetan, konputagailu paraleloen ezaugarri nagusiak aztertu ditugu. Hasieran, arlo teknikoan eta zientifikoan baino ez ziren erabiltzen, eskuarki kalkulu asko behar zuten aplikazioetan; gaur egun, berriz, makina horiek ohikoak dira edozein laborategi, unibertsitate edo goi-mailako enpresatan. Azken kapitulu honetan sistema paralelo azkarrenen eboluzioa denboran zehar aztertuko dugu. Horrez gain, programa paraleloak sortzeko gehien erabiltzen diren tresnak ere azalduko ditugu: OpenMP, SMP sistemetarako, eta MPI, memoria banatuko sistemetarako. 9.1. ABIADURA HANDIKO KONPUTAGAILUAK Konputagailu paraleloen aukera oso zabala da, 4-8 prozesadore dituzten SMP sistema xumeetatik hasita, 100.000 prozesadore baino gehiago dituzten "1 Formulako" makinetaraino. Azken horiek munduko makinarik azkarrenak dira, baina ez dira merkatuko makinak, gobernuek finantzatutako proiektu "estrategikoak" baizik. Sistema paralelo arruntenak, ordea, cluster-ak dira: 64 - 4.096 prozesadore (edo gehiago) komunikazio-sare aurreratu batez lotuta. Sistema azkarrenak ez badira ere, "merkeak" dira, eta zientzietako zein enpresako hainbat aplikaziotarako oso erabilgarriak dira. www.top500.org helbidean, munduko 500 konputagailu azkarrenen zerrenda argitaratzen da, urtean bitan (ekainean eta azaroan). Ez da erraza makinen portaera (abiadura) konparatzea, arkitektura eta baliabideak batetik, eta exekutatzen dituzten aplikazioak bestetik, oso desberdinak direlako. Hala ere, fabrikatzaile guztiak ados edo jarri dira LINPACK proba-bankua (ekuazio linealen sistema trinko handiak) exekutatzen lortutako abiadura erabiltzen konputagailuak sailkatzeko. Hurrengo paragrafoetan, 2011ko ekaineko zerrendako ezaugarri nagusiak azalduko ditugu (informazio zehatzagoa eta zabalagoa, gunean bertan). 2011ko ekainean, munduko konputagailurik "azkarrena" Fujitsuren K computer cluster-a da (RIKEN Advanced Institute for Computational Sciences, Japonia): 8,16 Petaflop/s-ko exekuzio-abiadura lortu du 548.352 nukleo erabiliz (68.544 SPARC64 VIIIfx, 8 nukleo, 2 GHz, 16 GFlop/s). Bigarrena, NUDTko Tianhe-1A cluster-a da (Tianjin NSC, Txina): 186.368 nukleo ditu (Intel EM64T Xeon X5670 eta NVIDIA GPU, FT-1000 8C) eta 2,57 PF/s lortu du. Hirugarrena (iaz lehena), Cray Inc. etxeko Jaguar makina da (Oak Ridge National Laboratory, USA); MPP motako superkonputagailua da, eta 1,76 PF/s-ko exekuzio-abiadura lortu du, 224.162 nukleo erabiliz (AMD x86_64 Opteron 6-core). Guztira, 10 konputagailuk gainditu dute 1 PF/s-ko kalkulu-abiadura eta 87k 100 TF/s-koa (duela urte bat, 54 baino ez ziren). Aurreikuspenak betetzen badira, zazpi urte barru edo Exaflop/s-a lortuko da (1018 eragiketa segundoko!). Europako lehena, bederatzigarrena zerrenda horretan, Bull etxeko Tera-100 konputagailua da (CEA, Frantzia): 1,05 PF/s, 136.368 nukleo (PowerPC 450, 850 MHz, Infiniband QDR). 68. posizioan lehen kapituluan aipatu dugun JaponiakoEarth Simulatorbektore- multikonputagailuaren bertsio berria dago; 1.280 bektore-prozesadore erabiliz (SX-9 bektore-prozesadoreak, 8 prozesadoreko SMP txartelak fat tree batez lotuta), 122,4 TF/s-ko kalkulu-abiadura lortu du. Dagoeneko, bektore- prozesadoreak erabiltzen dituen zerrendako makina bakarra da. Zerrendako 170a BarcelonaSupercomputingCenter-eko Mare Nostrum konputagailua da (IBM JS21 BladeCenter), 10.240 prozesadoreko cluster bat (PowerPC, Myrinet), eta 63,8 TF/ s-ko kalkulu-abiadura lortu du. Grafiko honetan ageri da nola eboluzionatu den konputagailu azkarrenen kalkulu- abiadura denboran zehar (zerrendako lehena, azkena eta guztien batura). Irudian ageri denez, 1993 urtean lortu zen lehenbiziko aldiz 100 GF/s-ko exekuzio- abiadura gainditzea, eta 1997 urtean 1 TF/s-ko abiadura, ASCI Red izeneko makinarekin. 18 urteko segidan, abiadura maximoa 59,7 GF/s-tik 8,16 PF/s-ra igaro da; hau da, 136.683 aldiz handiagoa da. Moore-ren legeari jarraituz47, abiadura ia-ia bikoiztu egin da urtero (2004 urteko makinarik azkarrena ez litzateke sartuko 2011ko 500 makina azkarrenen artean!).     Lehen esan dugunez, (super)konputagailu horiek ez dira ohikoak; esaterako, gaur egun (2011 urtean) bakarrik 60 konputagailu daude munduan 16.000 prozesadore baino gehiagorekin. Oro har, konputagailu paraleloak txikiagoak dira: top500 zerrendako makina gehienek (% 80ek) 4 k â€“ 16 k arteko core edo nukleo dituzte. Sistema paralelo azkarrenen arkitekturak ere oso joera nabaria izan du azken urteotan: 500 konputagailu horien % 82 cluster-ak dira dagoeneko, ia % 17 MPP motakoak dira, eta % 0,4 (2 sistema bakarrik) konstelazioak; ez dago besterik (aspaldi desagertu ziren zerrendatik SMP motako konputagailuak, eta gauza bera gertatuko da konstelazioekin). Kopuruari baino gehiago abiadurari begiratuta, ordea, MPP makinak azkarragoak dira (guztien kalkulu-abiaduren baturaren % 33 dira).         Erabiltzen diren komunikazio-sareak direla eta, Gigabit Ethernet da erabiliena (% 46), baina InfiniBand sarea gero eta gehiago erabiltzen da (% 41); bestalde, % 6 diseinu bereziko sareak dira (proprietary). Abiadura dela eta, ordea, egoera desberdina da; Gigabit erabiltzen dituzten konputagailuek abiadura osoaren % 20 eskuratzen dute, eta diseinu bereziko sareak erabiltzen dituztenek, askoz gutxiago badira ere, % 17. Aurreko bi ezaugarriek argi eta garbi erakusten dute bidea: gero eta gehiago, sistema paraleloak cluster-ak dira, eta Gigabit Ethernet bezalako sare "arruntak" (ez azkarrenak, baina merkeak) erabiltzen dituzte prozesadoreen arteko komunikazioa gauzatzeko (edo, ezaugarri hobeak behar badira, Infiniband). Bestalde, makina azkarrenak (baina oso garestiak) diseinu bereziko MPP sistemak dira. Zenbakizko azken aipamen bat. Garai batean, sistema paraleloak makina sofistikatuak ziren eta oso eremu berezi eta kontrolatuetan erabiltzen ziren; gaur egun, alabaina, munduko 500 makina azkarrenen % 57 industrian eta komertzio-arloan erabiltzen dira. Joera hori ere oso nabarmena da denboran zehar; makinarik azkarrenak ez badira ere (horiek ikerkuntza-arloan eta gobernuei lotutako instituzioetan erabiltzen dira), sistema paraleloak gero eta gehiago erabiltzen dira kalkulu asko edo datu-prozesamendu masiboak egin behar dituzten industria- eta komertzio-arloetan (telekomunikazioak, elektronika eta erdieroaleak, energia, hegazkinen eta automobilen diseinua, finantza- erakundeak, informazioaren prozesamendua...). Izan ere, cluster sinple bat osatzea ez da oso "garestia"; adibidez, lau nukleoko 32 nodoko oinarrizko cluster (Pentium edo antzekoa, Gigabit Ethernet) baten kostua 20-25 mila euro inguru da (prozesadore eraginkorragoak eta InfiniBand edo Myrinet komunikazio-sarea erabili nahi bada, 45-50 mila euro inguru).       9.2. OpenMP eta MPI: PROGRAMA PARALELOAK SORTZEKO TRESNA NAGUSIAK (sarrera) Liburu honen helburuetatik at geratzen da aplikazio paraleloak programatzeko tresnak aztertzea; hala ere, gutxienez haien oinarrizko ezaugarriak azaldu nahi ditugu. Aurreko kapituluetan azaldu dugunez, bi eredu ditugu sistema paraleloetan: memoria-espazioa partekatzen duten makinak eta memoria-espazio pribatua dutenak. Eredu bakoitzerako, ohikoa da programazio modu desberdin bat erabiltzea. SMP sistemetan, OpenMP erabili ohi da, eta memoria banatuta duten sistemetan, DSM zein MPP sistemetan, MPI da aukera erabiliena (bi kasuetan, aukera gehiago daude). Ikus ditzagun haien ezaugarri nagusiak. 9.2.1. OpenMP Memoria partekatuko sistemak programatzeko tresnarik erabiliena OpenMP da. Gogora ditzagun sistema horien ezaugarri nagusiak: prozesuek memoria-espazio bakarra erabiltzen dute eta haien arteko komunikazioa aldagai partekatuen bidez gauzatzen da; hori dela eta, aldagai horien erabilera "babestu" egin behar da, eskuarki sinkronizazio-funtzioen bidez. OpenMP ez da programazio-lengoaia bat, C eta Fortran lengoaiekin erabiltzen den API (Application Programming Interface) bat baizik. Doako bertsioak eskuratu daitezke (adibidez, Intel-eko C konpiladorekoa). OpenMP-k ez du dependentzien analisia egiten; beraz, programatzaileak erabaki behar ditu zer exekuta daitekeen paraleloan eta zer ez, aldagaien izaera, eta abar. Exekuzio-eredua Fork/Join motakoa da. Paraleloan exekutatu behar diren kode zatiak aurkitzean, hainbat thread edo hari sortzen dira, eta, lana bukatutakoan, hari horiek "hil" eta exekuzio sekuentzialarekin jarraitzen da. Hariek erabiltzen dituzten aldagaiak pribatuak edo partekatuak izan daitezke. Oro har, OpenMP begiztak paraleloan exekutatzeko erabiltzen da, baina atal paraleloak ere defini daitezke. OpenMP-k hiru osagai hauek eskaintzen ditu programa paraleloak idatzi ahal izateko:   - Konpiladorearentzako sasiagindu multzo bat, #pragma ompformatukoak, atal paraleloak zehazteko, lan-banaketa adierazteko, eta hariak sinkronizatzeko.   - Biblioteka-funtzio bakan batzuk (esaterako, hariei identifikadore bana esleitzeko, hari kopurua zein den jakiteko, edo lock/unlockfuntzioak sekzio kritikoak antolatu ahal izateko).   - Ingurune-aldagai bakan batzuk (adibidez, hari kopurua edo begizten iterazioak banatzeko estrategia zehazteko).   Honako hauek dira erabil daitezkeen sasiagindu nagusiak:  â–ªAtal paraleloak definitzeko   >>#pragma omp parallel [aldag,â€¦] { atal paraleloa } Hainbat hari sortzen dira, eta denek kode zati bera exekutatzen dute, errepikatuta; lana banatzeko, harien identifikadoreak edo OpenMP-k dituen lan- banaketarako egiturak erabili behar dira. Aldagaien izaera esplizituki erazagutu behar da: partekatuak (shared) edo pribatuak (private).   â–ªLana banatzeko   -- Atal paralelo baten barruan, for begizta baten iterazioak harien artean banatzeko.  >> #pragma omp for [aldag, sched,â€¦] for ...   Aldagaien izaeraz gain, iterazioak banatzeko estrategia (scheduling) adieraz daiteke: static, dynamic, guided... Atal paraleloa for begizta baino ez bada, paralleleta forpragmakbakar batean bil daitezke: #pragmaparallelfor[â€¦]  -- Funtzioak edo prozedurak (ez begizta baten iterazioak) harien artean banatzeko (ale ertaineko edo larriko paralelismoa).  >> #pragma omp sections [aldag,â€¦] { #pragma omp section { ... } #pragma omp section { ... } ... }   â–ª Hariak sinkronizatzeko  -Sekzio kritiko bat definitzeko (elkarrekiko esklusioa)  >>#pragma omp critical [aldag,â€¦] { sekzio kritikoa }   Horrez gain, badaude bibliotekako funtzio batzuk lock / unlock motako eragiketak sortzeko: omp_set_lock(&S) ; omp_unset_lock(&S) ; -Sinkronizazio-hesi bat;  >>#pragma omp barrier   Eskuarki, pragma bakoitzaren bukaeran hesi bat dago inplizituki (nahi izanez gero, kendu daiteke).   Adibide gisa, ikus dezagun nola paraleliza daitekeen forbegizta bat OpenMP erabiliz. Begiztak y =4/ (1 + x2) funtzioaren integrala (batuketa bat) kalkulatzen du, kurba peko area hainbat poligonotan zatituz eta haien area batuz; emaitza pi zenbakia da. Hasieran, batu nahi den tarte kopurua eskatzen da (emaitzaren doitasuna tarte kopuruaren arabera izango da).    void main () { int i, n; double dx, x, batura = 0.0, pi;  printf("\n Tarte kopurua --> "); scanf("%d",&n);  dx = 1.0 / (double) n;  for (i=0; i<n; i++) { x = (i + 0.5) * dx; batura = batura + 4.0 / (1.0 + x*x); } pi = batura * dx;  printf("\n PI(+/-) = %1.16f (%d tarte batuta)", pi,n); }    for begiztaren iterazioak independenteak dira, baina batura aldagai partekatua erabiltzen da. Begizta paraleloan exekuta daiteke, arazorik gabe, baldin eta hariek aldagai pribatu bana erabiltzen badute emaitza partzialak batzeko, eta, bukaeran, emaitza partzial horiek, hari bakoitzeko bat, batura aldagaian gehitzen badira, sekzio kritiko baten barruan. Bi aukera ditugu hori egiteko: sekzio kritiko bat antolatzea, edo eragiketa horietarako OpenMP- k aurredefinitua duen aldagai mota bat erabiltzea: reduction (gauza bera, baina OpenMP-ren esku). Horrez gain, hari guztiek x aldagai pribatu bana erabili behar dute. Hona hemen nola geratuko den begizta:    #include <omp.h> #define NUM_THREADS 8  void main () { int i, n; double dx, x, batura = 0.0, pi;  omp_set_num_threads(NUM_THREADS);  printf("\n Tarte kopurua --> "); scanf("%d",&n);  dx = 1.0 / (double) n;  #pragma omp parallel for private(i,x) reduction(+:batura) schedule(static)  for (i=0; i<n; i++) { x = (i + 0.5) * dx; batura = batura + 4.0 / (1.0 + x*x); }  pi = batura * dx;  printf("\n PI(+/-) = %1.16f (%d tarte batuta)", pi,n); }    Hari paraleloen kopurua, 8 adibidean, omp_set_num_threads funtzioaren bidez ezarri da (ingurune-aldagai bat ere erabil daiteke hari kopurua ezartzeko). Hala, for begizta 8 harien artean exekutatuko da, paraleloan (hala adierazi da pragma parallel for sasiaginduaren bidez). Begiztako i eta x aldagaiak pribatuak dira (desberdinak hari bakoitzean), eta batura reduction motako aldagaia da, partekatua baina berezia (bukaeran baino ez da eguneratuko benetako batura aldagaia; bitartean, aldagai laguntzaileak erabiliko dira hari bakoitzean). Begiztaren iterazioak banatzeko, esleipen (scheduling) estatikoa erabili dugu, ondoz ondokoa (beste aukerak ere erabil daitezke: estatikoa tartekatua, chunk scheduling eta guided scheduling). Oso programa sinplea da aurrekoa, baina OpenMP programa guztiek antzeko egitura eta itxura dute.   9.2.2. MPI(Message Passing Interface) Memoria banatuko sistema paraleloetan (MPP), prozesuek memoria-espazio pribatua erabiltzen dute: ez dago aldagai partekaturik. Beraz, prozesuen arteko komunikazioa mezu-ematearen bidez egin behar da. Bestalde, DSM sistemetan memoria partekatua bada ere, fisikoki banatuta dago, eta, ondorioz, mezuak bidali behar dira prozesadoretik prozesadorera beste nodo bateko memoria erabili ahal izateko. Bi kasuetan, prozesadoreen arteko komunikazioa (mezuak) adierazteko programazio-tresna erabiliena MPI da. Banaketa libreko bi inplementazio erabilienak LAM eta MPICH dira. MPI ez da programazio-lengoaia bat, komunikazioetarako API bat baizik (komunikazio-funtzio multzo "handi" bat), prozesuen arteko datu-mugimendua zein sinkronizazioa esplizituki adierazi ahal izateko. MPI-k SPMD programazio-ereduaren arabera egiten du lan; hau da, lan-banaketa prozesuen identifikadoreen bidez egiten da:   if (pid = 1) then ... else ...   Prozesuen arteko komunikazioa puntutik puntura izan daiteke â€”bi prozesuen arteanâ€” edo kolektiboa â€”prozesu guztiek parte hartzen duteâ€”. Komunikazio modu asko erabil daitezke, baina bi dira nagusiak: sinkronoa (komunikazio-funtzioak blokeatu egiten dira komunikazioa bete arte); eta, buffered (esaterako, bidali behar den paketea buffer batean uzten da eta itzuli egiten da, nahiz eta hartzaileak paketea hartzeko oraindik prest ez izan). MPI funtzio asko badago ere, hainbat programatarako nahikoa da honako sei hauekin:   -MPI_Init(&argc,&argv); MPI_Finalize();   Edozein programatako lehen eta azken MPI funtzioak.   -MPI_Comm_rank(comm,&pid); MPI_Comm_size(comm,&prk);   Prozesuak identifikatzeko funtzioak; lehenbizikoak pididentifikadorea itzultzen du, eta bigarrenak prozesu kopura, prk. Prozesuak "komunikatzaileak" deitzen diren taldetan bil daitezke, eta talde bakoitzaren barnean identifikadore desberdina erabiliko dute; izan ere, commaldagaiak prozesu-taldea adierazten du. Hasieran, prozesu guztiak biltzen dituen talde bat dago, MPI_COMM_WORLD izenekoa.   -MPI_Send(&message,count,datatype,dest,tag,comm); -MPI_Recv(&message,count,datatype,source,tag,comm,&status);   Mezu bat bidaltzeko (send) edo hartzeko (receive) komunikazio-funtzio nagusiak. Hiru parametro erabiltzen dira mezua zehazteko: helbidea (&message), luzera (count) eta osagai mota (datatype). Horrez gain, tag edo marka bat adieraz daiteke, mezuak klasetan banatu ahal izateko (datuak, kontrola...). Igorlea (source) edo hartzailea (dest) adierazteko, pid identifikadorea erabili behar da.   "Puntutik punturako" komunikazio-funtzioez gain, komunikazio "kolektiboak" ere egin daitezke. Komunikazio kolektibo batean prozesu guztiek (edo multzo jakin batek) parte hartzen dute. Besteak beste, honako komunikazio-eragiketa kolektibo hauek egin daitezke: - MPI_Bcast(â€¦) : broadcast, datuak prozesu jakin batetik gainerako prozesuetara zabaltzeko.   - MPI_ Scatter(â€¦):prozesu jakin baten datuak guztion artean banatzeko.   - MPI_ Gather(â€¦):prozesuetan banatuta dauden datuak prozesu jakin batean biltzeko (scatter eragiketaren kontrakoa).   -MPI_Reduce(â€¦):prozesuetan banatuta dauden datuekin eragiketa bat egiteko (batuketa bat, adibidez), eta emaitza prozesu jakin batean uzteko.   Bestalde, sinkronizazio esplizituko funtzio bakarra dago:MPI_Barrier(â€¦), prozesu guztiak programaren exekuzioko une jakin batean biltzeko.   Oro har, memoria banatuko aplikazioak memoria partekatukoak baino zailagoak dira programatzen, prozesuen arteko komunikazioa adierazi behar baita; esaterako, komunikazioa kontu handiz egiten ez bada, erraza da deadlock edo blokeo-egoerak sortzea. Konparazio baterako, hona hemen nola programatu behar den aurreko adibidea (pi zenbakiaren kalkulua) memoria banatuko sistema baterako:    #include <mpi.h>  void main (int argc, char **argv) { int pid, prk, i, n; double dx, x, batura = 0.0, pi_lok, pi;  MPI_Init(&argc, &argv); MPI_Comm_rank(MPI_COMM_WORLD,&pid); MPI_Comm_size(MPI_COMM_WORLD,&prk);  if (pid == 0) { printf("\n Tarte kopurua --> "); scanf("%d",&n); }  MPI_Bcast(&n,1,MPI_INT,0,MPI_COMM_WORLD);  dx = 1.0 / (double) n;  for ( i=pid; i<n;i+=prk) { x = (i + 0.5) * dx; batura = batura + 4.0 / (1.0 + x*x); } pi_lok = batura * dx;  MPI_Reduce(&pi_lok,&pi,1,MPI_DOUBLE,MPI_SUM,0, MPI_COMM_WORLD);  if (pid == 0)  printf("\n PI(+/-) = %1.16f (%d tarte batuta)", pi,n);  MPI_Finalize(); }    Prozesu guztiek kode bera exekutatuko dute, baina bakoitzak pid identifikadore desberdina du, MPI_Comm_rank funtzioaren bidez eskuratzen dena. MPI_Comm_size funtzioak prozesu paralelo kopurua itzultzen du (prozesu kopurua programa exekutatzean adierazten da; esaterako, 8 prozesu sortzeko: > mpirun -np 8 prog_izena). MPI_COMM_WORLD aurredefinitutako konstante bat da, eta eragiketan prozesu guztiek parte hartzen dutela adierazten du. Gero, prozesu jakin batek, pid = 0 prozesuak, batu nahi den tarte kopurua eskatzen du (tarte asko batuta, emaitza zehatzagoa izango da). Baina, aldagai partekaturik ez dagoenez, berak bakarrik jakingo du n-ren balioa. Beraz, balio hori prozesu guztietara bidali behar da â€”MPI_Bcast funtzioa, broadcast batâ€” denek jakin dezaten n-ren balioa. Begiztaren exekuzioa dator gero, baina, jakina, prk prozesuen artean. Iterazioak estatikoki eta tartekatuta banatu dira, prozesuen pid identifikadoreak erabiliz. Prozesu bakoitzeko kalkuluak bukatuta, emaitza partzial guztiak batu behar dira azken emaitza, pi, lortzeko, eta, horretarako, MPI_Reduce funtzioa exekutatzen da: prozesu guztiek P0ri bidaltzen dizkiote emaitzak, eta "bidean" batu egiten dira. Azkenik, pid = 0 prozesuak emaitzainprimatzen du, berak bakarrik du eta. Aurreko adibidea oso sinple bada ere, MPI programa guztiek antzeko egitura dute.     OpenMP eta MPI dira API erabilienak aplikazio paraleloak sortzeko, baina badaude beste batzuk; esaterako UPC (Unified Parallel C), memoria partekatuko baina fisikoki banatuko sistemak, cluster bat esaterako, programatzeko. Horrez gain, txartel grafikoak programatzeko erabiltzen diren lengoaietatik eratorrita, OpenCL lengoaia garatzen ari da, gaurko prozesadoreek dituzten nukleoak (cores) eta konputagailuen txartel grafikoen konputazio-baliabideak, batera, kalkulu paraleloa egiteko. Programatzeko tresna horiez gain, hainbat tresna sortu dira azken urteotan aplikazio paraleloak garatzeko â€”debugger paraleloak, errendimenduaren analizatzaileak, lan-kargaren kudeatzaileak...â€” eta sistema paralelo bera (batik bat cluster-ak) kudeatzeko.                                           Bibliografia       Azken 10-15 urteotan argitaratutako liburu eta aldizkarietako artikulu asko erabili ditugu testu hau sortzeko, eta, neurri handi batean, informazio horren guztiaren konpilazioa eta birformulazioa da testua. Hona hemen erabili ditugun erreferentzia nagusietako batzuk; behar izanez gero, irakurleak ez du arazorik izango, erreferentzia hauetatik abiatuta, hainbat eta hainbat testu eta artikulutara heltzeko.   â–ª Paralelismoari buruzko liburu orokorrak: Culler D.E., Singh J.P. Parallel Computer Architecture. A Hardware/Software Approach. Morgan Kaufmann, 1999. Hennessy J.L., Patterson D.A. Computer Architecture: A Quantitative Approach(4. ed.). Morgan Kaufmann, 2007. Hwang K. Advanced Computer Architecture: Parallelism, Scalability and Programmability.McGraw-Hill, 1993. Ortega J., Anguita M., Prieto A. Arquitectura de Computadores.Thomson, 2005. Sima D., Fountain T., Kacsuk P. Advanced Computer Architectures: A Design Space Approach. Addison Wesley, 1997.  â–ª Bektore-konputagailuak Espasa R., Valero M., Smith J.E. Vector architectures: past, present and future.International Conference on Supercomputing, 425-432, 1998. â–ª SMP sistemen datuen koherentzia, sinkronizazioa eta kontsistentzia RodrÃ­guez C., Ãlvarez G., Arregi O., PÃ©rez J.M. Microprocesadores RISC. EvoluciÃ³n y Tendencias.RAMA, 1999. Stenstrom P. A survey of cache coherence schemes for multiprocessors.Computer, 23. lib., 6. zenb., 12-24, 1990. Tomasevic M., Milutinovic V. (eds.) The Cache Coherence Problem in Shared Memory Multiprocessors: Hardware Solutions.IEEE Computer Society Press, 1993. Mellor-Crummey J.M., Scott M.L. Algorithms for scalable synchronization on shared memory multiprocessors.ACM Transactions on Computer Systems, 9. lib, 1. zenb., 21-65, 1991. Adve S.V., Gharachorloo K. Shared memory consistency models: a survey.Computer, 29. lib., 12. zenb., 66- 76, 1996. Hill M.D. Multiprocessors should support simply memory-consistency models.Computer, 31. lib., 8. zenb., 28-34, 1998.  â–ª Komunikazio-sareari buruzko liburuak Dally W.J., Towles B. Principles and Practices of Interconnection Networks.Morgan Kaufmann, 2004. Duato J., Yalamanchili S., Ni L. Interconnection Networks: An Engineering Approach. Morgan Kaufmann, 2003. Scherson I.D., Youssef A.S. (eds.) Interconnection Networks for High Performance Parallel Computers.IEEE Computer Society Press, 1994. Varma A., Raghavendra C.S. (eds.) Interconnection Networks for Multiprocessors and Multicomputers: Theory and Practice. IEEE Computer Society Press, 1994.  â–ª Kodea paralelizatzeko eta bektorizatzeko teknikak Allen R., Kennedy K. Optimizing Compilers for Modern Architectures. Morgan Kaufmann, 2002. Wolfe M. High Performance Compilers for Parallel Computing.Addison Wesley, 1996.   Banerjee U., Eigenmann R., Nicolau A., Padua D. Automatic program parallelization.Proceedings of the IEEE, 81. lib., 2. zenb., 211-243, 1993. Lilja D.J. Exploiting the parallelism available in loops. Computer, 27. lib., 2. zenb., 13-26, 1994.  â–ª DSM makinak / Koherentzia-direktorioak Lenoski D., Weber W.D. Scalable Shared Memory Multiprocessing.Morgan Kaufmann, 1995.  â–ª Aplikazio paraleloak programatzeko tresnak Chandra R. et al. Parallel Programming in OpenMP.Morgan Kaufmann, 2001. El-Ghazawi T., Carlson W., Sterling T., Yelick K. UPC: Distributed Shared Memory Programming.Wiley-Interscience, 2005. Pacheco P.S. Parallel Programming with MPI.Morgan Kaufmann, 1997.  â–ª Paralelismoari buruzko beste zenbait gai (testu honetan tratatu ez direnak) Dongarra J. eta al. (eds.) Sourcebook of Parallel Computing.Morgan Kaufmann, 2003. Foster I. et al. The Grid 2. Morgan Kaufmann, 2004. Foster I. Designing and Building Parallel Programs. Addison Wesley, 1995. May J. Parallel I/O for High Performance Computing.Morgan Kaufmann, 2001. Quinn M.J. Parallel Programming in C with MPI and OpenMP.McGraw-Hill, 2004. Sloan J.D. High Performance Linux Clusters.O'Reilly, 2005. Sterling T. Beowulf Cluster Computing with Linux.The MIT Press, 2002. Wilkinson B., Allen M. Parallel Programming Techniques and Applications using Networked Workstations and Parallel Computers.Pearson, 2005. â–ª Zenbait webgune Ezaguna denez, informazio asko dago sarean. Helbide interesgarri bakan batzuk aukeratu ditugu, testuaren osagarri gisa.   www.top500.org Sistema paralelo azkarrenen zerrenda. 6 hilabetean behin eguneratzen da. Hortik abiatuta, informazio asko eskura daiteke konputagailu paraleloei buruz. www.spec.org Prozesadoreen kalkulu-abiadurari buruzko gunea. www.ieeetfcc.org Cluster computingarloko gune nagusia. www.openmp.org SMP sistemetarako aplikazioak programatzeko OpenMPâ€“ren gunea. www-unix.mcs.anl.gov/mpi/ MPI, mezu-ematearen bidezko programazio-estandarraren gunea. www.gwu.edu UPC, C paraleloaren gunea. www.khronos.org/opencl/ OpenCL-ren gunea www.infinibandta.org Clustereta SAN sistemetarako garatu den komunikazio-azpiegitura berria. www.myri.com Sistema paraleloak osatzeko sare-teknologia komertzial nagusietako bat (Myrinet). www.globus.org Globus toolkit-aren (eta, oro har,Gridkonputazioaren) gunea. http://gridcafe.web.cern.ch/gridcafe/ Gridkonputazioari buruzko aurkezpen argia bezain sakona, Europako CERN erakundean.  â–ª Aldizkari batzuk Prozesadoreei eta sistema paraleloei buruzko informazio gehiena arloko aldizkarietan eta kongresuetako aktetan argitaratzen da. Hona hemen horietako batzuk (ez dira dibulgazioko aldizkariak):   IEEEerakundeko aldizkariak:Micro,Computer,Spectrum,Proceedings of the IEEE, Design and Test of Computers,Transactions on Parallel and Distributed Systems,Transactions on Computersâ€¦ IBM:Journal of Research and Development,Systems Journal ACMerakundeko aldizkariak:Computer Architecture News,Communications of the ACMâ€¦ Int. Symp on Computer Architecture(ISCA),Supercomputingâ€¦                                        Glosategia                 ACK (acknowledgement) Hainbat eragiketatan (koherentzia-eragiketetan, esaterako) bidaltzen den pakete (edo kontrol-seinale) mota bat: onarpena (acknowledgment). Heldu den pakete (edo eskaera) baten erantzun gisa bidaltzen da, pakete horretan eskatutakoa onartu edo egin dela informatzeko. Adierazleak (flag) Oro har, sinkronizaziorako (gertaerak gauzatzeko) erabiltzen den aldagai bitarra. Esaterako, gertaeren bidezko sinkronizazio-prozesuetan, adierazle bat (0/1) erabiltzen da ekoizle eta kontsumitzaile prozesuak sinkronizatzeko: 0, oraindik ez da sortu datu berria; 1, datu berria sortu egin da. Alea (grain) Paraleloan exekutatu behar diren atazen tamaina eta komunikazio-beharra zehazten du aleak (grain). Hauek dira bi muturrak: ale_larriko_paralelismoa, non atazen exekuzio-denbora handia den eta prozesuen artean bidaltzen diren mezuak luzeak diren, nahiz eta komunikazioa ez den oso maiz gertatzen; eta ale xeheko_paralelismoa, zeinean atazak txikiagoak diren, usuago komunikatzen diren, eta mezuak txikiak diren. Amdahl-en legea(Amdahlâ€™s law) Oro har, paralelismoaren mugak ezartzen dituen legea. Bektore-konputagailuei dagokienez, programetan bektoriza ezin daitekeen kode-frakzioaren eragina azpimarratzen du. Honela eman daiteke: azelerazio-faktorea = TE / TBE = K / (f + (1â€“f) K) non TE = exekuzio-denbora prozesadore eskalarrean; TBE = exekuzio-denbora bektore-konputagailuan; K = azelerazio-faktorea kode guztia bektorizatzen denean; eta f = bektorizazio-faktorea diren. Antidependentzia (antidependency) Aginduen arteko datu-dependentzia mota bat (izen-dependentzia bat). Bigarren aginduak lehenbiziko aginduak irakurri behar duen aldagai bera idatziko du. Esaterako: A =B+ 1 B= C / 2 Sinonimoa: WAR (write-after-read) dependentzia. Arbola eta arbola sendoa(fat tree) Sistema paraleloak osatzeko sare-topologietako bat. Oro har, arbolako hostoetan prozesadoreak daude, eta tarteko adabegietan mezu-bideragailuak. Datu- trafikoari erantzun egokia emateko, arbola "sendoak" (fat tree) erabiltzen dira. Arbola sendoetan komunikaziorako azpiegitura (kanalak, bideragailuak...) ugaltzen dira arbolan gora, errorantz goazen neurrian. Asmatu / asmatze (hit) Memoria nagusiko azpimultzo bat besterik ez da gordetzen cache memorian. Beraz, agindu edo datu jakin bat cachean bilatzen denean, bietako bat: edo asmatu egiten da, bilatzen dena bertan badago, edo huts egiten da, ez badago (eta ondorioz, memoria-hierarkiako hurrengo mailara jo behar da). Oro har, asmatzea apustu baten emaitzetako bat da (jauzi-aginduetan egiten den bezala, esaterako). Atomikotasuna (atomicity) Eragiketa baten ezaugarria. Ziurtatu egiten da egin behar dena kanpoko prozesuen interferentziarik gabe egiten dela, dena jarraian. Esaterako, RMW (read-modify-write) motako agindu batek (Test&Set, adib.) memoria-posizio bat irakurri, balioa aldatu eta atzera idatzi egiten du posizio berean, eta, bitartean, ez dira eragiketak onartzen memoria-posizio horretan. Atomikotasun ezak arazoak sortzen ditu sistema paraleloetan aldagaiak partekatzen direnean, prozesadore bat baino gehiagok, bateratsu, aldagai berarekin lan egin nahi dutenean. Automata finitua(finite automate) Egoera jakin batetik bestera mugitzen den automata. Egoera-makina ere deitzen zaio. Egoera kopurua finitua da, eta erabat definituta dago, baldintza jakin batzuen arabera, nondik nora joango den automata. Autobanaketa(self-scheduling) Paraleloan exekutatu behar diren atazak (begizta baten iterazioak, adibidez) prozesuen artean banatzeko esleipen dinamikoetako bat. Prozesu bakoitzak ataza bat hartzen du ataza ilaratik, exekutatu egiten du, eta, bukatutakoan, lan gehiagoren bila doa ilarara, guztion artean ataza guztiak bukatu arte. Azelerazio-faktorea(speed-up) Bi konputagailu-egitura (edo programen exekuzioa) konparatzen direnean, zenbat bider den azkarragoa bata bestearekiko. Backoff Eragiketa bat errepikatu baino lehen denbora jakin bat itxaroten denean esaten da backoff teknika erabiltzen ari dela.     Baliogabetze-protokoloa(invalidation-based protocol) Multiprozesadore baten cacheetako datuak koherente mantentzeko gehien erabiltzen den estrategia edo politika. Cache batean baino gehiagotan dagoen datu baten gainean aldaketa bat egiten denean, beste kopia guztiak baliogabetu egiten dira, eta, ondorioz, kopia bakarra uzten da sistema osoan. Eragiketa horren kontrol-seinale nagusiari INV (invalidate) deritzo. Banaketa (scheduling) Aplikazio paralelo baten atazak prozesadoreei esleitzeko prozeduraren izena. Ale xeheko paralelismoan, begizta baten iterazioak hainbat prozesadoreren artean banatzeko prozedura. Atazen banaketa estatikoa edo dinamikoa izan daiteke. Eraginkortasunaren aldetik, banatzen den lan-kargak orekatua behar du izan (load balancing), hots, banatzen diren atazen exekuzio-denborak ahalik eta antzekoena izan beharko luke prozesadore guztietan. Banaketa dinamikoa (dynamic scheduling) Atazen banaketa programa exekutatzen ari denean egiten bada, dinamikoa dela esaten da. Oro har, ataza ilara bat izango da, eta prozesuek ataza bana (edo batzuk) hartuko dute exekutatzeko; amaitu ahala, beste bat (edo batzuk) hartuko dute, harik eta atazak prozesu guztien artean bukatu arte. Beraz, prozesadore bakoitzean zer exekutatuko den ez dago aurredefinituta. Banaketa estatikoa (static scheduling) Atazen banaketa programa konpilatzen denean egiten bada (exekuzioa hasi baino lehen) estatikoa dela esaten da; hala, prozesu bakoitzaren lana definituta dago exekuzioa hasi baino lehen. Banda-zabalera(bandwidth) Komunikazio-sare bati dagokionez (busa, maila...), loturek segundoko garraia dezaketen bit kopurua. Esaterako, 1 Gb/s. Begizta-trukea(loop-interchanging) Begiztak bektorizatzeko erabiltzen den tekniketako bat. Hainbat dimentsiotako bektoreak prozesatu behar badira, bektoreak edozein dimentsiotan definitzea ahalbidetzen du teknika horrek (dimentsio batean izan daitezkeen oztopoak gainditu ahal izateko). Esaterako, bi dimentsioko matrize bat bektorizatzeko, errenkadak zein zutabeak kontuan har daitezke.                   do i = 0, N-1             do j = 1, M-1                 do j= 1, M-1              do i= 0, N-1                 A(i,j) = A(i,j-1) + 1 â†’ A(i,j) = A(i,j-1) + 1                 enddo                     enddo                 enddo                     enddo   Begizten ordena-aldaketa erabiltzen da, halaber, kodea paralelizatu behar denean, kasu horretan sinkronizazio-eragiketak saihesteko edo atazen tamaina (alea) handiagotzeko. Bektoreak(vectors) Datu-egitura bat (hots, datu multzo egituratua). Bektore bat definitzeko hiru parametro erabili ohi da: hasiera-helbidea, bektorearen lehen osagaiaren helbidea; luzera, osagai kopurua; eta pausoa edo stride, ondoz ondoko bi osagairen arteko distantzia memorian. Eskuarki, pausoa konstantea da.   Bektore-aginduak(vector instruction) Bektoreak prozesatzeko agindu bereziak: LV V1,A(R1) edo ADDV V3,V2,V1 eta abar. Bektore-agindu bakar batekin N osagai prozesatzen dira. Agindu berri horiek eraginkorki exekutatu ahal izateko, bektore-prozesadoreek ezaugarri bereziak dituzte: bektore-erregistroak, unitate funtzional asko eta segmentatuta, modulu askotan tartekatutako memoria, memoriarako bus asko... Bektore-erregistroak (vector register) Bektoreak gordetzeko, prozesadore barruko erregistro bereziak (prozesadore eskalarren erregistroen orokortzea). Kasu arruntenetan, bektore-erregistro batean 64-128 osagai gordetzen dira, bakoitza, esaterako, 64 bitekoa; beraz, erregistro batek 128 Ã— 64 = 8 kilobit okupatzen du. Haien tamaina kontuan hartuta, erregistro eskalar baino gutxiago daude bektore-konputagailuetan (8, adibidez). Zenbait konputagailutan, bektore-erregistroen tamaina aldakorra da eta bektoreak gordetzeko espazioa banatu daiteke erregistro gutxi eta oso luzeak zein erregistro gehiago baino motzagoak definitzeko. Bektore-konpiladorea(vector compiler) Kode eskalarretik bektore-kodera itzultzen duen konpiladorea. Bektore-konputagailua (vector computer) Bektoreak prozesatzen espezializatutako konputagailu mota bat. Bektore- konputagailuak izan dira, duela gutxi arte, kalkulu-abiadura handienak lortu dituzten konputagailuak. Haien arkitektura optimizatuta dago bektoreak prozesatzeko, kontuan hartuta kalkulu zientifikoko arloan mota horietako kalkuluak direla denbora-gehien kontsumitzen dutenak. Gainera, teknologia aurreratuenak erabili dira beti makina horiek eraikitzeko. Besteak beste, hiru "familia" bereizi ohi dira: CRAY makinak, Japoniako makinak (Fujitsu, NEC...) eta minisuperkonputagailuak (Convex...). Bektorizazioa(vectorization) Goi-mailako lengoaia batean idatzitako programak bektore-aginduetara itzultzeko prozesua. Bektorizazio-prozesua biziki garrantzitsua da bektore- konputagailuetan kalkulu-abiadura handiak lortuko badira. Bektorizazioa konpiladorearen ardura da, baina erabiltzaileak ere lagundu dezake askotan. Prozesuaren bukaeran, bektore-kodearen eta kode eskalarraren nahastea lortuko da, kasu gehienetan ezin baita kode osoa bektore-aginduen bidez adierazi, bektorizazio-faktoreaf izanik (0 < f < 1). Bektorizazio-faktorea Algoritmo gehienetan ezin da kode guztia bektore-kode gisa idatzi. Programaren zati bat modu eskalarrean exekutatuko da, eta beste zati bat bektorialki. Bektorizazio-faktorea f = 1 denean, kode guztia bektorizatu da; f = 0 denean, ezin izan da ezer bektorizatu. Beowulf Behe-mailako cluster bat. Nodoak PC sinpleak dira (eskuarki LINUX sistema eragileekin); komunikazio-sarea ere sinpleena da: ethernet. Sistema paralelo merkeenak dira, eta egokiak izan daitezke hainbat aplikaziotan, non prozesuen arteko komunikazioa noizbehinka besterik egiten ez den. (VIII. â€“ X. mendetako anglo-saxoniar poema baten heroiaren izena, gizandi baten kontra borrokatu zuena; metafora gisa, kostu eta abiadura handiko MPP makinen kontrako borroka.) Bideratzea (routing) Paketeak helburuetara garraiatzeko egin behar den funtzioa, zeinaren bidez irteera-kanal egoki bat aukeratzen den, bidearen pauso bakoitzean. Paketeen helburu-helbidearen edo bideratze-erregistroaren arabera egiten da bideratzea. Paketeek beti bide bera hartzen badute iprozesadoretik j prozesadorera joateko, estatikoa da bideratzea. Bide desberdinak hartzen badituzte, sareko trafikoaren, egoeraren, historiaren... arabera, dinamikoa edo moldakorra da bideratzea. Bideratze-erregistroa(routing record) Paketeek goiburukoan daramaten kontrol-informazio jakin bat. Bideratze- erregistroan adierazten da, eskuarki, zenbat pauso eman behar diren sarean, dimentsio bakoitzean, helburura heltzeko (esaterako, 3 pauso X ardatzean eta 2 pauso Y ardatzean). Kontrol-informazio horren arabera, irteera-kanal egokia erabiliko da tarteko mezu-bideragailuetan. Broadcast Komunikazio-patroi berezi bat: mezu bera bidaltzen dai prozesadoretik beste prozesadore guztietara, eskuarki denak batera. Datu-koherentziaren testuinguruan, eragiketa zein kontrol-seinale bat, zeinaren arabera prozesadore batek aldagai baten balioa eguneratzen dituen sistema osoan zehar, datuen koherentzia mantentzearren. Busa Konputagailu bat osatzen duten osagaiak lotzeko eta haien arteko komunikazioa bideratzeko sare orokorra. Esaterako, memoria eta prozesadorea hiru busen bidez komunikatzen dira: kontrol-busaz, datu-busaz eta helbide-busaz. Busa osatzeko, euskarri fisikoa ("hariak") eta kontrol-protokolo bat behar dira. Buseko trafikoa Busean zirkulatzen den informazio kopurua. Eskuarki, MB/s gisa adierazten da; adibidez, 200 MB/s (edo 2 Gb/s). Buseko trafikoa parametro garrantzitsua da multiprozesadoreetan, prozesadore guztiek erabili behar baitute busa, baina berau ase gabe. Busy Koherentzia-eragiketak atomikoak izan daitezen erabiltzen den estrategietako batean, cacheko blokeak busy (= lanpetuta) egoeran mantentzen dira eragiketa osoa bukatu arte. Bloke bat busy egoera dagoen bitartean, berarengana bidalitako mezu guztiak errefusatu egingo dira, NACK (negative acknowledgement) motako paketeak itzuliz (edo ilara batean sartuko dira, geroago prozesatzeko). Butterfly Urrats anitzeko komunikazio-sare motako bat. Sarea osatzeko, kommutagailuak erabiltzen dira. Cache memoria(cachememory) Memoria-hierarkian, memoria nagusiaren eta erregistroen artean kokatzen dena. Memoria nagusia baino txikiagoa da (/100), baina azkarragoa da (Ã—10). Prozesadoreak behar duen informazioa ahalik eta latentzia txikienarekin eskaintzea da cachearen helburua, eta, horretarako, aldagaien erabileraren zoritasun eza erabiltzen da. Bitan banatu ohi da cache memoria: aginduetarako eta datuetarako; era berean, hainbat mailatan banatu daiteke, hierarkia bat osatuz: prozesadoreko txiparen barruan (L1), kanpoan (L2), eta abar. Cacheko datu-blokeen egoerak (cache block states) Cacheen koherentzia ziurtatzeko, kontrol-bit batzuk gehitzen zaizkie datu- blokeei, haien egoera adierazteko. Bost dira egoera nagusiak, eta bi ezaugarriren arabera sailka daitezke: kopia kopurua (bat edo asko) eta koherentzia MNarekin (bai ala ez): I â†’ Baliogabetua (invalid). Blokea ezabatu da eta ez da erabilgarria. E â†’ Esklusiboa (exclusive). Sistema osoan kopia bakarra dago (hau) eta bat dator (koherentea da) memoria nagusiko datuekin. M â†’ Aldatua (modified). Sistema osoan kopia bakarra dago (hau), baina aldatuta dago eta ez dator bat (ez da koherentea) memoria nagusiko datuekin. S â†’ Partekatua (shared). Kopia asko dago (edo izan dira) sisteman, eta denak dira koherenteak (berdinak) memoria nagusiko datuekin. O â†’ Jabea (owner). Kopia asko dago (edo izan dira) sisteman, eta, haien artean berdinak badira ere, ez datoz bat (ez dira koherenteak) memoria nagusiko datuekin. Cache-kontrolagailua(cachecontroller) Cache-eragiketak kontrolatzen dituen gailua. Multiprozesadoreetan, kontrolagailu horrek zelatariaren funtzioak betetzen ditu (snoopy), datuen koherentzia mantentzeko. CC-NUMA Memoria partekatuko konputagailu mota bat, zeinean memoria fisikoki banatuta baitago prozesadoreen artean (NUMA, edo DSM) eta datuen koherentzia hardwarez mantentzen baita (CC = cachecoherent). Chunk scheduling Paraleloan exekutatu behar diren atazak (begizta baten iterazioak, kasu) prozesuen artean banatzeko esleipen dinamikoetako bat. Atazak banatzean galtzen den denbora minimizatzeko, batik bat haien exekuzio-denbora txikia bada (ale xeheko paralelismoa, beraz), lan-esleipeneko eragiketa bakoitzean ataza (iterazio) bat baino gehiago hartzen dira exekutatzeko. Cluster Helburu orokorreko hainbat konputagailu (edo prozesadore) lotuz lortzen den konputagailu paraleloa. Oro har, MPP sistemak baino merkeagoak dira, baina motelagoak ere bai. Hala ere, kostu/abiadura erlazio oso ona dute, eta, hori dela eta, asko ugaldu dira laborategietan, unibertsitateetan eta enpresetan. Nodoen eta konexio-sareen arabera, cluster desberdinak lortzen dira. Sistema paraleloa osatzeko, konputagailu soilak zein SMP sistemak (edo cluster-ak) erabil daitezke. Helburuen arabera, hainbat motako cluster-ak defini daitezke: high performance cluster (kalkulurako makinak), high availability cluster-ak (zerbitzu bat etenik gabe eskaintzeko)... Compare&Swap RMW motako agindu atomiko bat. Hiru eragigai erabiltzen ditu: bi erregistro eta memoriako posizio bat. Erregistro baten eta memoriako posizioaren edukiak trukatzen ditu, bigarren erregistroaren eta memoriako posizioaren arteko konparazio baten arabera: if (Rx = M(A)) then Ry â†â†’ M(A). Constellation Cluster mota bat. Sistema paraleloaren nodo kopurua nodo bakoitzaren prozesadore kopurua baino askoz txikiagoa da. Crossbar Komunikazio-sare jakin bat. Crossbar-ean, nodo edo prozesadore guztiak guztiekin daude konektatuta. Beraz, une jakin batean, edozein permutazio (Piâ†’Pj) exekuta daiteke. Crossbar-ak hardware asko behar du eta, beraz, kostu handikoa da. Gainera, kostua P2-ren arabera hazten da. Erabilgarria da, oro har, prozesadore kopurua handia ez denean. Cut-through Paketeak tarteko bideragailuen artean aurreratzeko moduetako bat. Tarteko bideragailu bakoitzean, pakete baten goiburukoaren lehenengo flit-a heltzen denean, dagokion irteera-kanala aukeratzen da, eta, libre badago, birtransmititu egiten da hurrengo mezu-bideragailura, pakete osoa hartu arte itxaron gabe. Horrela, paketeen komunikazioa "segmentatu" egiten da. Lehenbiziko hurbilpen gisa, honela eman daiteke komunikazio-latentzia: T ~ L+D (L, paketeen luzera; D, distantzia). Data-race Programa paralelo baten prozesuen arteko sinkronizazioa ondo definituta ez badago, litekeena da exekuzio batetik bestera emaitza desberdinak izatea, aginduen arteko ordena erlatiboa, denboran zehar, ez baitago finkatuta. Arazo horri datu-lasterketa (data-race) deritzo. Datu-blokea (edo lerroa)(block / line) Memoria nagusitik cachera transferitzen den informazio-unitatea. Bloke bat hainbat hitzek osatzen dute (eskuarki 64 edo 128 byte), eta askotan memoriaren tartekatze-mailarekin dago erlazionatuta. Datu-dependentzia Bi aginduren artean datu-dependentzia bat dago, baldin eta biek datu (aldagai) bera atzitzen badute. Hiru motako datu-dependentziak daude: batetik, benetako dependentziak (wr â†’ rd), eta, bestetik, izen-dependentziak: antidependentziak (rd â†’ wr), eta irteera-dependentziak (wr â†’ wr). Deadlock Sistema paraleloetan gerta daitekeen arazo nagusietako bat, blokeoa. Oro har, sistema blokeatu egiten da, baldin eta bi "osagai" bakoitza bestearen erantzunaren zain geratzen badira. Komunikazio-sistemetan ere, arazo bera ager daiteke: paketeek ziklo bat osatzen dute, elkarri blokeatzen diote bidea, eta inork ez du aurrera egingo. Komunikazioa eten egin da. Denborizazioa Denbora jakin bat itxarotea ekintzaren bat gerta dadin edo ekintza bat errepikatu baino lehen. Esaterako, sekzio kritiko batean sartzeko bi saioren artean denbora jakin bat itxarotea, buseko trafikoa eta memoria-gatazkak saihesteko asmoz; edo pakete bat sarean blokeatuta geratu dela erabakitzeko denbora jakin bat itxarotea. Dependentzia((true) dependency) Bi aginduren artean dependentzia bat dago, baldin eta bigarrenak irakurri behar badu lehenbizikoak idazten duena. Esaterako, A= B + 1 C = A/ 2 Sinonimoa: RAW (read-after-write) dependentzia. Diametroa Komunikazio-sare batean, bi prozesadoreren artean dagoen distantzia maximoa.   Direktorioa (directory) Cache memorien atal bat, non edukiari buruzko informazioa gorde den: helbideak (edo helbideen zati batzuk), egoerak, kontrol-informazioa... Bilaketak egiteko erabiltzen da direktorioa, behar den datua edo agindua cachean dagoen ala ez jakiteko. DSM sistemetan, datu-blokeei buruzko koherentzia-informazioa gordetzen duen gailua Dirty(aldatuta) Cacheko direktorioetan erabili ohi den kontrol-bit bat. Hau da esanahia: blokearen edukia aldatu egin da eta emaitza ez da eguneratu memoria nagusian. DMA(direct memory access) Sarrera/irteerako prozedura azkarretako bat. DMA kontrolagailuak busetako kontrola eskuratzen du, eta zuzenean kargatzen ditu datuak memorian (diskotik, esaterako). Koherentziaren ikuspuntutik, arazoak sor daitezke, kargatzen diren bloke berriak cacheetan ere egon baitaitezke. Hori dela eta, zenbait kasutan, sarrera/irteerarako erreserbatutako blokeak "cachera eraman ezinak" markatzen ditu sistema eragileak. Doacross Doacross begizta erabiltzen da paralelizatu behar diren iterazioen arteko dependentziak badaude, eta, ondorioz, iterazioen (prozesuen) arteko sinkronizazioa gehitu behar bada. Doall Iterazioen artean datu-dependentziarik ez duen begizta bat; ondorioz, iterazioak edozein ordenatan exekuta daitezke, prozesuak sinkronizatu behar izan gabe. DOR bideratzea(dimension order routing) Paketeak bideratzeko teknika bat. Bideratze-erregistrotik abiatuta, paketeek dimentsio bateko pauso guztiak korritzen dituzte hurrengo dimentsioko bideari ekin baino lehen. 2 dimentsioko sareetan, "lehenik-X-gero-Y" ere deitzen zaio. Bideratze estatikoko teknika arruntena da, eta, zenbait saretan, mailetan adibidez, ez du blokeorik sortzen. DRAM(dynamic RAM) Konputagailu baten memoria nagusia egiteko erabiltzen den teknologia, RAM dinamikoa. RAM dinamikoa estatikoa baino motelagoa da (4-6 aldiz motelagoa), baina edukiera handiagokoa da. DSM Distributed shared memory. Memoria logikoki partekatua baina fisikoki banatua duen konputagailu paraleloa. Ondorioz, sistemaren memoria hierarkikoki antolatzen da: bertako atzipenak azkarrak izango dira, baina beste nodoetako memoriakoak askoz latentzia handiagokoak izango dira. Hori dela eta, NUMA (non- uniform memory access) izena hartzen dute. Egokitasuna (correspondence, mapping) Memoria nagusia baino txikiagoa da cache memoria. Beraz, datu-bloke bat kargatu behar denean, erabaki egin behar da non kargatu. Hiru dira aukera nagusiak: Zuzenekoa (direct-mapped): posizio bakar batean koka daiteke bloke bakoitza, haren helbidearen arabera. Esaterako, lau blokeko cache baterako, 0â†’0; 1â†’1; 2â†’2; 3â†’3; 4â†’0; 5â†’1... Hori dela eta, blokeak bilatzea azkarra da, toki jakin batean egongo dira eta, baina cachearen edukiera ez da modurik onenean aprobetxatzen. Izan ere, litekeena da bloke bat cachetik kendu behar izatea posizio horretan beste bloke bat kargatzeko, nahiz eta cachean toki asko libre izan. Guztiz_elkargarria_(associative): kontrako kasua da. Blokeak cacheko libre dagoen edozein posiziotan koka daitezke. Memoria-espazioaren erabilera optimizatu egiten da, baina bilaketa zaildu egiten da, blokeak edozein tokitan egon baitaitezke. Direktorioa memoria elkargarri batez egiten da. Multzoka_elkargarria (set associative): aurreko bien arteko erdibidea. Cachearen edukiera multzotan banatzen da. Bloke bakoitza multzo jakin batean kokatu behar da (zuzenekoa), baina, horren barruan, libre dagoen edozein posiziotan (elkargarria). Eguneratze-protokoloa(update-based protocol) Multiprozesadore baten cacheetako datuak koherenteak mantentzeko erabiltzen den estrategia edo politika. Cache batean baino gehiagotan dagoen datu baten gainean aldaketa bat egiten denean, beste kopia guztiak eguneratzen dira balio berriarekin, eta, ondorioz, zeuden kopia guztiak mantentzen dira, baina balio berriarekin. Eragiketa horren kontrol-seinale nagusiari BC (broadcast) deritzo. Ekoizle/kontsumitzaile eredua Prozesuen komunikazioko ereduetako bat. Prozesu batek, ekoizleak, datuak sortzen edo ekoizten ditu. Bestea(k), kontsumitzaileak, datu horiek erabili (kontsumitu) egiten ditu. Sinkronizazio egokia lortu behar da, eskuarki adierazle edo flag baten bidez, komunikazioak ondo funtziona dezan. Elkarrekiko esklusioa(mutual exclusion) Sinkronizazio-teknika bat. Kode zati bat elkarrekiko esklusioan exekutatzen da, sistema paralelo batean, baldin eta prozesu bakar batek exekuta badezake aldi berean kode zati hori. Kode horrek sekzio kritikoa osatzen du. Elkarrekiko esklusioa gauzatzeko, lock eta unlock sinkronizazio-funtzioak erabiltzen dira. Erdibiketaren banda-zabalera(bisection bandwidth) Sare bat bi parte berdinetan banatzeko kendu behar diren loturen banda- zabalera. Erdibiketaren banda-zabalerak mugatu egiten du sareak onar dezakeen trafikoa, komunikazioa zorizkoa denean, helburuetan zein denboran. Errekurrentzia(recurrence) Agindu batek bere buruarekin duen datu-dependentzia: i iterazioan, agindu berean iâ€“ d iterazioan sortu den emaitza erabili behar da. Eskalagarritasuna (hedagarritasuna, scalability) Sistema baten propietatea, zeinaren arabera sistema tamaina-aldaketetara ondo egokitzen den. Esaterako, sinkronizazio-mekanismo batek ondo eskalatzen du, trafikoaren ikuspuntutik, prozesadore kopurua bikoizten denean sortzen den sinkronizazio-trafikoa ere bikoizten bada; hau da, linealki hazten bada eta ez, adibidez, koadratikoki. Esteka (link) Lotura. Fisikoa izan daiteke â€”kable batâ€” edo logikoa â€”helbide batâ€”. Esaterako, datuen koherentzia mantentzeko, datu-blokeen kopia zerrendak erabiltzen dira zenbait sistematan. Zerrenda horien osagai (kopia) bakoitzak bi esteka (helbide) gordetzen ditu, zerrendako aurrekoa eta hurrengoa zein diren adierazteko.     Factoring Atazak esleitzeko estrategia dinamikoren bat. Prozesadore bakoitzak geratzen diren atazen parte proportzional bat hartzen du exekutatzeko (esaterako, X/ 2P, X izanik exekutatzeko geratzen den ataza kopurua, eta P prozesadore kopurua). Fence aginduak Multiprozesadorean erabiltzen den kontsistentzia-ereduaren arabera, zenbait unetan ordena hertsia ezarri behar da programa baten aginduen exekuzioan, memoria-aginduen desordena eta atomikotasun eza galarazteko. Ordena ezartzeko, agindu bereziak erabiltzen dira, "fence" (hesi) izenekoak. Hiru dira aukera nagusiak:write-fence, wr >> rd/wr ordena ezartzeko; read-fence, rd >> rd/wr ordena inposatzeko; etamemory-fence, ordena guztiak ezartzeko. Fetch&Op RMW motako agindu atomikoa. Aldagai bat irakurtzen da memoriatik, eta, eragiketaren bat egin ondoren, memorian idazten da, dena interferentziarik gabe. Eragiketaren arabera, agindu desberdinak definitzen dira; esaterako, Fetch&Incr A A := A + 1 Fetch&Add A,#b A := A + b FIFO First-input-first-output:lehena heldu, lehena atera. Prozesuak, mezuak, atazak eta abar kudeatzeko lehentasun-estrategia ezagunena: heldu diren ordenan prozesatzen dira (ilara bat osatzen da). Flit Mezu-bideragailuen artean transferitzen den informazio-unitate minimoa, zeinari informazio-jarioa kontrolatzeko estrategiak aplika dakizkiokeen. Gaur egungo sistemetan, flit-a 8/16 bitekoa da. Flynn-en sailkapena Sistema paraleloen sailkapen ezagunenetako bat. Prozesatzen diren datu-jarioen eta agindu-jarioen kopuruen arabera, bat edo asko, sailkatzen dira sistemak. Hiru kategoria bereizi ohi dira: (1) SISD sistemak (Single-Instruction-Single- Data, prozesadore bakarreko sistemak); (2) SIMD sistemak (Single-Instruction- Multiple-Data); esaterako, bektore-prozesadoreak edo prozesatze-matrizeak; eta (3) MIMD sistemak (Multiple-Instruction-Multiple-Data). Azkenak dira benetako sistema paraleloak. Forall Forall begizta erabiltzen da, baldin eta iterazioen artean dependentziak badaude, baina kasu partikular batean: dependentzia guztiak aurrera doaz dependentzia-grafoan. Hori dela eta, iterazioen arteko sinkronizazioa hesien bidez egin daiteke (doall + barrier ere deritzo begizta mota horri). Fork / Join Funtzio-paralelismoa adierazteko ohiko bi funtzioak. Fork eta Join sasiaginduen arteko atazak paraleloan exekutatuko dira (sekzio edo atal paralelo bat osatzen dute). Full bit vector Datu-bloke bati buruzko koherentzia-informazioa hitz bakar batean egituratzen denean, informazioa osatzeko aukera bat; koherentzia-hitz bat erabiltzen da bloke bakoitzeko, eta hitz horretan, blokearen egoeraz gain, P bit bat gordetzen dira, prozesadore bakoitzeko bat: 1, datu-blokearen kopia baldin badauka, eta 0, ez badauka. Full / empty bita Ekoizle/kontsumitzaile ereduan erabil daitekeen estrategiaren bat (hardwarean). Memoriako hitz bakoitzean kontrol-bit bat gehitzen da. Ekoizleak idazten du hitz horretan bit hori 0 bada, eta 1ean uzten du; kontsumitzaileak irakurtzen du hitz hori kontrol-bita 1 bada, eta 0an uzten du. Gather(bilketa) Konputagailu paraleloetan, prozesadoreetan banatuta dauden datuak prozesadore batean biltzeko komunikazio-funtzioa. Bektore-konputagailuetan, bektore- eragiketa bat, memorian barreiatuta dagoen bektore bat (pauso ez konstantekoa) bektore-erregistro batean biltzeko. Indize-bektore bat erabili behar da eragiketa horretan. Gertaerak(events) Sinkronizazio-mekanismo bat. Prozesuak zain geratzen dira gertaera jakin bat gertatu arte. Eskuarki, adierazleak erabiltzen dira gertaerak gauzatzeko. Gertaera-bektoreak (event vector) Begizta baten iterazioak paraleloan exekutatzen direnean, haien arteko datu- dependentziak sinkronizatzeko erabiltzen den adierazle-bektorea. Bektore horren i posizioan 1eko bat idazten da i iterazioaren exekuzioa bukatzen denean. Goiburukoa Pakete baten hasierako kontrol-eremua; eskuarki, pakete mota, nora doan eta antzeko informazioa darama. Gradua Sare baten nodoen (komunikazio-kudeatzaileen) konexio kopurua. Sare erabilienak gradu txikikoak dira (2-6). Nodo guztien gradua bera bada, sarea erregularra da. Guided self-scheduling Begizta baten iterazioak (oro har, atazak) banatzeko teknika bat. Iterazioak dinamikoki banatzen dira, programa exekutatzen den bitartean. Hasieran, begizta zati handiak banatzen dira, baina banaketa gero eta finagoa da, eta gero eta zati txikiagoak banatzen dira. Hau da banatzen diren zatien tamaina: (N â€“ i) / P; hots, exekutatzeko geratzen diren iterazio guztien (N â€“ i) parte proportzionala (/ P). Handshake Kontroleko protokolo mota bat (esku-ematea), bi gailuen arteko komunikazioa, funtzionamendua... sinkronizatzeko. Eskuarki, bi fasetan betetzen da: eskaera eta onarpena. Hedapen eskalarra(scalar expansion) Bektore-konpiladoreek erabiltzen duten teknika bat, begizta bateko aldagai eskalar laguntzaileak bektore bihurtzeko, kodea bektorizatu ahal izateko. Hesia (barrier) N prozesu elkarren artean sinkronizatzeko egitura. Hesi batean, kontagailu bat eta adierazle bat erabiltzen dira. Kontagailuak kontatzen ditu sinkronizazio- puntu horretara heldu diren prozesuak. Heltzen den lehenak hesia ixten du, adierazlean 1eko bat idatziz; azkenak hesia irekitzen du, adierazlean 0ko bat idatziz. Bitartean, prozesuak zain geratzen dira, hesia ireki arte (adierazlea 0 izan arte). Hiperkuboa (hypercube) Lehen belaunaldiko multikonputagailuen komunikazio-sarearen topologia. Kubo bitarra ere deitzen zaio. Hiperkuboko dimentsio bakoitzean bi prozesadore daude, 1 eta 0, eta lotura bana dute posizio bereko beste dimentsioko prozesadore guztiekin. Home / Fresh / Gone SCI koherentzia-protokolo estandarrean, direktorioaren hasieran, datu-blokeen hiru egoeren izenak: Home â†’ ez dago kopiarik cacheetan; Fresh â†’ kopiak badaude, baina koherenteak dira memoria nagusiko informazioarekin; Gone â†’ kopiak badaude, eta ez dira koherenteak memoria nagusiko informazioarekin. Hutsegitea / huts egin(miss) Cache memoria baten direktorioan egiten den bilaketaren emaitzaren bat: bilatzen dena ez dago. Hutsegitearen ondorioz, erabili nahi den hitza duen datu-bloke osoa ekarriko da cachera, atzipenen ingurutasuna aprobetxatzeko asmoz. Hutsegiteekiko tolerantzia(fault tolerance) Sistema bat hutsegiteekiko tolerantea da, baldin eta sistema osatzen duten osagaien bat matxuratzen denean ere funtzionatzen jarraitzeko gauza bada (agian ez eraginkortasun handienaz). Ezaugarri oso garrantzitsua da sistema paralelo masiboetan, hutsegiteen probabilitatea hazi egiten baita sistemaren osagai kopuruaren arabera. Idazketa-politika Aldagai bat idatzi behar denean erabiltzen den estrategia. Memoria-sistema hierarkikoki antolatuta dago â€”cachea eta memoria nagusiaâ€”, eta, beraz, datuen kopiak erabiltzen dira (gutxienez bi). Zer egin behar da kopia horiekin? Bi dira idazketa-politika nagusiak: write-through eta write-back. IEEE Estatu Batuetako ingeniari elektriko eta elektronikoen elkartea (The Institute of Electrical and Electronics Engineers). Hainbat aldizkari zientifiko, liburu, estandar eta abar publikatzen ditu. Indize-bektorea (vectorindex) Bektore "sakabanatuak" atzitzeko, indize-bektoreak erabiltzen dira, non, LV edo SV eragiketa egin baino lehen, bektore-osagaietako helbideak gorde diren. Indukzio-aldagaia (induction variable) Begizta batean, begiztako indizearen funtzio lineala den edozein aldagai laguntzaile. Bektorizatzeari ekin baino lehen, indukzio-aldagaiak ordezkatu egin behar dira aipatutako funtzioaz, bektoreen dependentziak analizatu ahal izateko. Ingurutasuna(locality) Memoriako atzipenek duten propietate bat. Izan ere, h helbidean ziklo jakin batean lan egiten bada, probabilitate handiz, h+1 helbidea erabiliko da hurrengo zikloan (espazio-ingurutasuna); era berean, probabilitate handiz, h helbidea erabiliko da berriz ziklo batzuk geroago (denbora-ingurutasuna).   Inklusio-printzipioa Ohikoa da, oraingo prozesadoreetan, cache memoriarekin hierarkia bat osatzea: prozesadorearen (txiparen) barruan eta kanpoan, esaterako. Inklusio- printzipioaren arabera, barruko cacheak kanpoko cachearen azpimultzo bat izan behar du. Beraz, kanpoko cachean bloke bat baliogabetzen bada, barrukoan ere kendu behar da. Intervention forwarding Koherentzia-protokoloen komunikazioa betetzeko estrategia baten izena. A-tik B- ra eskaera bat egiten bada, eta eskatzen dena C-n badago, eragiketa B-ren parte-hartzearekin beteko da, eragiketaren latentzia eta sortzen den trafikoa murrizteko: A â†’ B â†’ A; A â†’ C â†’ A ==> A â†’ B â†’ C â†’ B â†’ A INV Invalidate. Datuen koherentzia mantentzeko erabiltzen den kontrol-seinale edo - mezu bat: cache batean idatzi egin denez, datu-blokaren gainerako kopia guztiak baliogabetu behar dira; ondorioz, kopia bakarra geratuko da multiprozesadoreko cacheetan. Irteera-dependentzia(output dependency) Aginduen arteko datu-dependentzia mota bat (izen-dependentzia bat). Agindu batek aurreko agindu batek idatzitako aldagai beraren gainean idatzi behar du. Esaterako, A= B + 1 A= C / 2 Sinonimoa: WAW (write-after-write) dependentzia. Itxarote aktiboa(busy-waiting) Ekintza baten zain geratzen den prozesua itxarote aktiboan dago behin eta berriz analizatzen badu, begizta sinple batean, ea gertatu den gertatu behar dena (eskuarki, sinkronizazio-aldagai batek balio jakin bat hartzea). Jarioaren kontrola (flow control) Sareko mezu-bideragailuek erabiltzen duten estrategia, haien bufferrak gainezka ez daitezen. Arruntenalink level flow-controlizenekoa da; komunikazio- protokoloa honako hau izan daiteke: baduzu tokia? â†’ baduzu tokia? â†’ ï‚¬bai ï‚¬ ez mezu bat bidali â†’ itxaron   Horrez gain, paketeak aurreratzeko erabiltzen diren teknikak (SF / CT / WH) ere jarioaren kontrol gisa hartu ohi dira. Kalkulu-abiadura (performance) Konputagailu batek segundoko exekuta dezakeen "eragiketa" kopurua. Neurri nagusiak hauek dira: Mi/s (edo Mips, million instruction per second) eta Mflop/ s (edo Mflops, million floating operations per second). Esaterako, honela definitzen da kalkulu-abiadura bektore-konputagailu batean: non N prozesatu diren osagaiak (bektoreen luzera, esaterako), T exekuzio- denbora (s), eta Erag_Kop begiztan exekutatu den koma higikorreko eragiketa kopurua diren, hurrenez hurren. Kanal birtualak(virtual channels) Konputagailu paraleloen komunikazio-sarean mezuen blokeoak (deadlock) saihesteko, eta, ondorioz, bideratze dinamikoa ahalbidetzeko (eta, zenbait kasutan, mezuen latentzia eta sareko mezu-emaria hobetzeko) erabiltzen den teknika. Bideragailuen arteko lotura fisikoa hainbat kanal birtualetan banatzen da; kanal birtual bakoitzak sarrera/irteerako buffer desberdinak erabiltzen ditu, eta kanal birtual horietatik batzuk baino ez dituzte erabiliko paketeek, pakete motaren arabera. Horrela, pakete batek aurrera segi ezin badu, ez du kanal fisikoa blokeatzen, eta kanala libre geratzen da beste kanal birtual batean mugitzen den pakete baterako. Kateaketa(chaining) Prozesadore eskalarretan erabiltzen diren zirkuitulaburren orokortzea. Bektore osoa bektore-erregistro batean idatzi arte itxaron beharrean, zuzenean pasatzen da sortzen ari den unitate funtzionaletik behar den unitate funtzionalera. Koherentzia(coherency) Multiprozesadore baten memoria-sistema koherentea da, baldin eta datu partekatuen gainean egiten diren aldaketak modu bertsuan "ikusten" badira prozesadore guztietan. Koherentzia ziurtatzeko, bi dira protokolo mota nagusiak: baliogabetze-protokoloak eta eguneratze-protokoloak. Adibidez. X = 3 aldagaia P1, P2 eta P3 prozesadoreetan partekatzen da. P1ek aldatu egiten badu X aldagaia, X = 4 izateko, lehenago edo geroago, P2k eta P3k ikusi beharko dute balio berria. Baliogabetze-protokoloa erabiltzen bada, P1ek baliogabetu (INV) beharko ditu P2n eta P3n dauden kopiak. Horrela, berriz erabili beharko direnean, berriro eskuratu beharko dira, orain balio berriarekin. Eguneratze-protokoloa erabiltzen bada, P1ek abisatu egingo die P2ri eta P3ri X aldagaian izandako aldaketaz, eta balio berria emango die. Koherentzia-direktorioa(coherence directory) CC-NUMA motako prozesadoreetan, koherentzia mantentzeko erabiltzen den estrategiaren (eta gailuaren) izena. Blokeei buruzko informazioa koherentzia- direktorio izeneko gailuan gordetzen da. Bi dira aukera nagusiak direktorioa egituratzeko. Lehenbizikoan, direktorioa memoria nagusiarekin lotuta ageri da; bigarrenean, aldiz, direktorioko informazioa cache memorietan barreiatzen da. Kommutagailua(switch) Komunikazio-sare dinamikoen adreilua. Hainbat kommutazio-urratsetan antolatzen dira sare horiek. Kommutagailu sinpleenak 2 sarrera 2 irteerekin komunikatzen du. Sarrera/irteera kopurua kommutagailuaren gradua da. Komunikazio-patroia (communication pattern) Prozesadoreen arteko komunikazio-eskema adierazten du: nor norekin eta noiz komunikatzen den. Esaterako, zorizkoa bada, edozein prozesadore komunikatuko da edozein prozesadorerekin probabilitate berarekin. Askotan, komunikazioaren probabilitatea distantziaren arabera aldatzen da. Testuinguru jakin batzuetan, permutazioak dira komunikazio-patroi erabilienak. Komunikazio-patroiak mezuak denboran nola banatzen diren ere adieraz dezake Esaterako, broadcast batean, une jakin batean bidali behar da mezu bat prozesadore batetik gainerakoetara. Komunikazio-sarea(communication network) Oro har, sistema paraleloetan erabiltzen den sarea, prozesadoreak eta memoria, edo prozesadoreak elkarren artean, komunikatzeko. Sare sinpleena busa da, eta hori da sare erabiliena, prozesadore kopurua txikia denean, memoria partekatuko sistema paraleloa osatzeko. Prozesadore kopuru handiko sistemetan, aldiz, beste sare mota batzuk erabiltzen dira: bai kommutagailuen bidezko sareak (Omega, esaterako), bai eta puntutik punturako sareak ere (mailak, toruak, hiperkuboak, arbolak...) Kontsistentzia sekuentziala eredua (SC, sequential consistency) Sistema paraleloetan exekutatzen diren programen kontsistentzia mantentzeko eredurik hertsien edo zurrunena. Memoria-eragiketa guztien ordena lokala eta globala inposatzen da, eta, ondorioz, atomikotasuna ere bai. Esaterako, ezin da irakurri datu bat cachean datu hori idatzi zuen aginduaren eragina prozesu guztietara zabaldu den arte. Programen semantika "naturala" gordetzen bada ere, eraginkortasunaren aldetik ez da oso ona, oraingo prozesadoreetan erabiltzen diren hainbat optimizazio (hardwarez zein softwarez) galarazi egiten direlako. Modu batera edo bestera, prozesadore guztiek onartzen dute eredu hau. Kontsistentzia-eredua(memory consistency model) Kontsistentzia-ereduak honako hau adierazten du: helbide-espazio bakarra duten multiprozesadoreetan, memoria nola erabili behar den. Izan ere, hainbat prozesuk erabiliko dituzte memoria-espazio bera, komunikaziorako, sinkronizaziorako eta abarretarako. Kontrol-unitate bakarra ez dagoenez gero, adierazi egin behar da memoria-eragiketa horiek zein ordenatan exekutatuko diren eta memorian egindako aldaketak nola ikusiko diren prozesu/prozesadore guztietan. Kontsistentziaren arazoa koherentziarena baino zabalagoa da, edozein helbidetan egindako memoria-eragiketak kontuan hartzen baititu. Kontsistentzia-eredu malguak(relaxed memory consistency models) SC kontsistentzia-ereduak ezartzen dituen baldintza gogorrak arintzeko garatu diren kontsistentzia-eredu "arinagoak". Horrela, memoria-eragiketen arteko desordena batzuk onartu egiten dira, nahiz eta ordena hertsia ezartzeko aukera izan behar den, programaren zenbait puntutan, haren semantika garbia izan dadin. Ordena inposatzeko, fence motako agindu bereziak erabiltzen dira. Lasterketa (race) Oro har, eta egoera-makina edo automata finitu bati dagokionez, egoeren arteko trantsizioetan aurreikusita ez dagoen aldaketaren bat gertatzea. Esaterako, bi bloke M egoeran geratzea. Errore hauek sistema guztiz asinkronoa eta paraleloa delako sortzen dira, hots, ekintzak ez daude "ordenatuta" denboran eta, gainera, ez dira, berez, atomikoak. Koherentzia-protokoloak ondo diseinatu behar dira arazo hori saihesteko. Latentzia (latency) Oro har, eragiketa bat betetzeko behar den denbora; adibidez, agindu baten latentzia edo memoria-eragiketa baten latentzia. Komunikazioaren arloan parametro nagusietako bat da: pakete bat prozesadore batetik bestera garraiatzeko behar den denbora. Komunikazio-sareari ahalik eta latentzia txikiena izatea eskatu behar zaio, eta latentzia hori mezu-trafikoko egoera guztietan mantentzea. Limited bit vector Koherentzia-direktorioko informazioa hitz bakar batean egituratzen denean, informazioa osatzeko aukera bat. Direktorioaren tamaina txikiagotzeko asmoz, datu-bloke bakoitzeko erabiltzen den koherentzia-hitzean, ez da gordetzen bit bat prozesadore bakoitzeko, datu-bloke horren kopia duten prozesadoreen helbideak baizik. Ordainean, blokeen kopia kopurua mugatu egiten da: ez da onartzen kopuru maximo jakin bat baino kopia gehiago. List Construction Koherentzia-informazioa cacheetan banatzen denean, kopia zerrendak antolatuz, eta SCI estandarrari jarraituz, kopia bat zerrendari gehitzeko â€”buruan, hain zuzen ereâ€” exekutatu behar den prozeduraren izena. Livelock Hainbat gailuren eskaerak prozesatzen direnean gerta daitekeen arazoetako bat. Eragiketak behin eta berriz errepikatzen dira, baina ez dira inoiz bukatzen. Hemen ere, arazoa eragiketak paraleloak eta ez atomikoak izatean datza. Koherentziari dagokienez, kasu hau adibidez: bateratsu, bi prozesadorek idatzi behar dute cachean ez duten bloke beraren gainean, baina eragiketak "tartekatu" egiten dira: <Irakurri_blokea (P1) â€“ Irakurri_blokea (P2), Baliogabetu_blokea (P1), Baliogabetu_blokea (P2)>. Ondorioz, bi prozesadoreak blokerik gabe geratzen dira berriz, eta errepikatu egingo dute prozesu osoa, behin eta berriz. Komunikazioko arloan ere ager daiteke arazo hori: paketeak mugitzen dira, baina ez dira helburuetara heltzen, atzera-aurrera doaz eta. Arazoa bufferretako mezuak desbideratzen direnean ager daiteke, mezu berriak onartu ahal izateko. LL / SC Load Locked / Store Conditional. Agindu bikote bat, sekzio kritiko baterako sarrera antolatzeko. Aginduak ez dira atomikoak, baina bikote gisa RMW eragiketa atomiko bat osatzen dute. LL aginduak memoriako posizio bat irakurtzen du, eta, horrez gain, hardwareko adierazle bat aktibatzen du. SC aginduak memoria-posizio bat idazten du, baina aipatutako adierazlea aktibatuta badago baino ez; gainera, idazketa betetzen badu, helbide horri lotuta dauden sistemako adierazle guztiak ezabatzen ditu. Horrez gain, kontrol-kode bat itzuliko du idatzi den ala ez adierazteko. Load balancing Aplikazio bat exekutatzeko, prozesadoreen artean banatzen den lanaren oreka, exekuzio-denborari dagokionez. Aplikazio paralelo eraginkorrak lortu ahal izateko, atazen oreka garrantzitsua da; bestela, prozesadore batzuk azkar bukatuko dute eta ezer egin gabe geratuko dira, beste batzuk oraindik exekuzioan jarraitzen duten bitartean. Lock / unlock Sekzio kritiko bat kudeatzen duten bi errutinen ohiko izena. Sarraila-aldagai bat erabiltzen da bietan. Lock (itxi) errutinak sarraila aztertzen du; irekita badago, itxi egiten du eta sekzio kritikora pasatzen da; bestela, itxaroten geratzen da. Unlock (ireki) errutinak sarraila ireki egiten du sekzio kritikoa uzten denean. Loturak(links) Sare baten kableak edo bideak, nodoak (prozesadoreak, mezu-bideragailuak...) haien artean konektatzeko. Maila (mesh) Komunikazio-sare ezagun bat, gaur egun oso erabilia. Dimentsio bateko maila katea da: prozesadore guztiak kate batean konektatzen dira. Egitura orokortu daiteke bi (koadrikula bat), hiru (kubo bat)... dimentsioetara. n dimentsioko mailan, P = kn prozesadore konektatzen dira, k dimentsio bakoitzeko prozesadore kopurua izanik.P handia denean, sare horren diametroa n(kâ€“1) da, eta batez besteko distantzia nk/3. Sistema komertzialetan, 2D eta 3D mailak erabiltzen dira.   Memoria banatua edo pribatua(distributed memory) Multiprozesadoreen ereduetako bat. Sistemaren memoria banatuta dago prozesadoreen artean, eta prozesadore bakoitzak dagokion memoria zatia baino ez du erabiltzen. Prozesadoreen arteko komunikazioa mezu-emate esplizituaren bidez egiten da. Memoria elkargarria(associative) Memoria elkargarria da bilaketa edukiaren arabera egiten bada, eta ez helbidearen arabera. Hiru eragiketa definitzen dira memoria elkargarrietan: bilaketa, irakurketa eta idazketa. Bilaketaren emaitza bitarra da: bai (1), bilatzen dena memorian badago; eta ez (0), ez badago. Memoria elkargarriak erabil daitezke, esaterako, cache memoriako direktorioan, egitura elkargarria denean, hots, memoria nagusitik ekarritako blokeak edozein posiziotan koka badaitezke. Memoria-hierarkia(memory hierarchy) Konputagailu baten memoria modu hierarkikoan antolatzen da, edukieraren eta abiaduraren arabera. Mutur batean, disko edo zinta magnetikoak daude, edukiera handikoak eta atzipen motelekoak (segundoak). Ondoren, disko gogorra koka daiteke, edukiera txikiagokoa (>100 GB), baina azkarragoa (ms). Memoria nagusiak osatzen du hurrengo maila, atzipen-denborak 50-100 ns eta ohiko edukiera 1-4 GB izanik. Cache memoriak osatzen du hurrengo maila, eta gainera, askotan, hainbat azpimailatan banatuta (barne-cachea, kanpo-cachea...). Edukiera txikiagoa da, 1-4 MB adibidez (barne-cachean, esaterako, 32 + 32 kB), baina erantzun-denbora <10 ns-koa da. Azkenik, prozesadoreko erregistro-multzoa dago, non hitz bakar batzuk gordetzen diren, baina atzipena oso azkarra den (erloju-zikloa). Memoriaren eta prozesadorearen artean dagoen abiadura-diferentziaren eragina moteltzea da hierarkiaren helburua, gehien erabiltzen diren datu/aginduak erantzun-denbora txikienarekin eskuratu ahal izateko. Memoria-moduluak (memory module) Memoria-sistemako helbide-espazioa hainbat memoria-modulutan tartekatu ohi da. Hala, irakurketa/idazketak batera egin daitezke, modulu desberdinetan badira (esaterako, ondoz ondoko helbideak!). Bektore-prozesadoreetan, modulu kopuru handian tartekatzen da memoria, eragiketa bakar batekin hainbat atzipen (N) abiatzen direlako. Memoria nagusia(main memory) Izenak dioenez, laneko memoria orokorra. Sinonimo gisa, RAM. Oraingo konputagailuetan, memoria nagusia 1-4 GB-koa da. Memoria partekatua (shared memory) Multiprozesadoreen ereduetako bat. Eredu horretan, prozesadoreek sistema osoko edozein memoria-posizio erabil dezakete, bertako nodokoa zein kanpoko nodoetakoa, helbide-espazioa bakarra baita. Memoriako banda-zabalera(memory bandwidth) Memoria irakurtzean, segundoko lor daitekeen byte kopurua; esaterako, 500 MB/s. Ahalik eta handiena izatea da egokiena. Memoriako busak(memory bus) Memoriara "joateko" (rd edo wr) bide fisikoak. Bektore-konputagailuetan, beharrezkoa da bus asko izatea, LV/SV agindu bat baino gehiago batera exekutatu ahal izateko. Bus kopuruak eragina handia du kalkulu-abiaduran. MESI / MOSI / MOESI... Datuen koherentzia mantentzeko protokolo batzuk; haien izenak, maiz, erabiltzen dituzten egoeren araberakoak dira: MESI, MOSI... Mezu-bideragailua(message router) Prozesadoreen arteko komunikazioa kudeatzen duen gailua. Sare estatikoetan (mailak, adibidez), paketeak bideragailuz bideragailu doaz helburura heldu arte. Oro har, hau da bideragailu baten egitura: paketeak hartzeko eta bidaltzeko hainbat sarrera- eta irteera-portu; buffer multzo bat, paketeak gordetzeko, behar duten irteera libre izan arte; eta bideratze-funtzioa gauzatzen duen atala, non sarreraâ†’irteera esleipena egiten den. Mezu-ematea(message passing) Prozesadoreen arteko komunikazioa gauzatzeko teknika bat. Memoria partekatzen ez denean, prozesadoreak mezuen bidez komunikatzen dira. Mezua, gehienetan, tamaina finkoko hainbat paketetan banatzen da, eta pakete bakoitzak goiburuko bat darama, helburura heltzeko behar den informazioarekin. Sareko mezu- bideragailura bidaltzen dira paketeak, eta handik, pausoz pauso, bideragailuz bideragailu, helburura joango dira. Mflop/s (Mflops) Kalkulu-abiadurako unitate nagusia. Segundoko exekutatzen diren koma higikorreko eragiketa kopurua adierazten du (milioiak). MIMD Flynn-en sailkapenaren arabera, konputagailu mota bat: Multiple-Instruction- Multiple-Data. Sistema paralelo orokor gisa hartzen da: prozesadore askok programa asko edo, eskuarki, programa baten hainbat zati, exekutatzen dituzte, batera. MPI(Message Passing Interface) Memoria banatuko sistemetarako aplikazio paraleloak programatzeko API estandar nagusia. Prozesuen arteko komunikazioa mezu-ematearen bidez egiten denez, hainbat komunikazio-funtzio â€”puntutik puntura, kolektiboak...â€” eta modu â€”blokeakorra, buffered, berehalakoa, sinkronoa...â€” eskaintzen ditu. MPP Massively Parallel Processor. Prozesadore kopuru handia duen konputagailu paraleloen izena, memoria partekatukoa zein banatukoa. Bi ezaugarri nagusitan bereizten da SMP sistemetatik; batetik, prozesadoreen arteko komunikazio-sarea ez da bus bat, sare orokorrago bat baizik (maila, hiperkuboa...); eta, bestetik, memoria partekatua izanik ere, atzipen-denbora ez da berdina hitz guztietan, fisikoki banatuta dagoelako. Memoriako helbide-espazioa bakarra denean, (cc)NUMA edo DSM ere deritze. Multicast Komunikazio-patroi bat. Prozesadore batek mezu bera bidaltzen du, eskuarki une berean, prozesadore azpimultzo batera (ez guztietara, broadcast-ek egiten duen modura). Multikonputagailua(multicomputer) Memoria banatuko sistema paraleloen izen orokorra. P prozesadore konektatzen dira komunikazio-sare orokor baten bidez, baina ez dute memoria partekatzen. Prozesadoreen arteko komunikazioa mezu-ematearen bidez egiten da. Askotan, MPP ere deritze.     Multiprozesadorea(multiprocessor) Prozesadore bat baino gehiagoko konputagailua, oro har. Eskuarki, 2-16 prozesadoreko sistemetan erabiltzen da izen hori, zeinetan memoria partekatzen den eta konexio-sarea bus bat (edo, agian, kommutagailuen bidezko sare bat) den. NACK Negative acknowledgment. Kontrol-mezu bat, zeinaren bidez eskaera jakin bat errefusatu egiten den. Esaterako, koherentziako eragiketen atomikotasuna bermatzeko erabiltzen da. Eragiketa bukatu ez den bitartean, blokea egoera iragankor batean utzi da (direktorioan, esaterako) eta, hala irauten den bitartean, errefusatu egingo dira bloke horren gainean eskatzen diren eragiketa guztiak. NUMA Non-uniform memory access. Prozesadore kopuru handiko eta memoria partekatuko konputagailuen izena. Partekatua bada ere, memoria fisikoki banatuta dago, eta, ondorioz, atzipen-denbora ez da bera hitz guztietarako. Atzipena nodoaren barruan geratzen bada, denbora txikiagoa izango da, eta handiagoa kanpora, sarera, atera behar bada. Askotan, DSM edo MPP gisa ere ezagutzen dira. Omega sarea Kommutagailuz osatutako sare dinamiko ezaguna. P prozesadoreko Omega sareak logkP kommutazio-urrats edo etapa dauzka, eta urrats bakoitzean P/ k kommutagailu (k kommutagailuen gradua izanik, 2 edo 4 eskuarki). Kommutazio- urratsak konektatzeko, permutazio bat egiten da, tartekatze perfektu (perfect shuffle) izenekoa, alegia. OpenMP SMP sistemetarako aplikazio paraleloak programatzeko API estandar nagusia. Harien (thread-en) arteko komunikazioa aldagai partekatuen bidez egiten da; beraz, begiztak paraleloan exekutatzeko eta atal paraleloak sortzeko egiturez gain, sekzio kritikoak, hesiak eta abarreko sinkronizazio-funtzioak erabiltzeko aukera ere eskaintzen ditu. Ordezkapen-politika(replacement) Askotan, egokitasun-politika zein den, bloke bat cachean kargatzeko, han dagoen beste bloke bat kendu edo ordezkatu egin behar da. Ordezkapen-politikak cachetik kendu behar den blokea zehazten du, eta hainbat estrategia erabil daitezke: datu-bloke zaharrena, denbora gehien erabili gabe dagoena, zorizkoa... Helburua, noski, cacheko asmatze-tasa handiena izatea da beti. Or-wired Or funtzio logikoa gauzatzeko teknika bat. Sarrera guztiak lerro komun batean konektatzen dira. Gutxienez bat aktibatzen denean, irteera komun hori aktibatu egiten da. Aukera hori izateko eskuarki hiru egoerako gailuak erabiltzen dira. Paketeak Pakete-kommutazioa erabiltzen denean, mezuak tamaina finkoko paketetan banatzen dira. Pakete bakoitzak kontrol-informazioa darama helburura heltzeko. Mezua osatzen duten paketeak helburuan bilduko dira gero, mezua berreskuratzeko. Pakete-kommutazioa(packet switching) Bi prozesadoreren arteko komunikazio-bidea eraikitzeko teknika bat. Izan ere, pakete-kommutazioa erabiltzen denean ez da bide bat eraikitzen igorlearen eta hartzailearen artean komunikazioari ekin baino lehen; hori egin beharrean, paketeak sarera pasatzen dira eta, paketeek beraiek daramaten kontrol- informazioaren arabera, helbururantz joango dira (posta-zerbitzuan egiten den moduan). Paralelismoa (parallelism) Gauza bat baino gehiago batera egiten direnean, paraleloan egiten direla esaten da. Exekuzio-abiadura handiagoak erdiesteko erabiltzen da paralelismoa, eta maila askotan ustia daiteke: adibidez, aginduen exekuzioan (aginduen segmentazioa - ILP), datuen prozesamenduan (SIMD prozesadoreetan) edo programen exekuzioan (multiprozesa-doreetan). Konputagailuen arloan, gai aurrerenetako bat da paralelismoa: P prozesadorek lan egiten dute programa baten exekuzioan, exekuzio-denbora laburtzeko. Ideialki, algoritmo baten exekuzioan P prozesadore erabiltzen badira, exekuzio-denbora P aldiz txikiagoa izango litzateke. Zoritxarrez, arazo asko sortzen dira, eta muga hori ez da erdiesten kasu orokorretan. Konputagailu azkarrenak sistema paraleloak dira; esaterako, oraingo konputagailurik azkarrenak, IBMren Roadrunner konputagailua, 129.600 nukleo ditu eta 1,105 Pflop/s-ko kalkulu-abiadura lortu du (www.top500.org, 2009ko ekaina). Partekatze faltsua (false sharing) Prozesadoreek partekatzen dituzten datuekin erabili behar da koherentzia- protokoloa. Baina koherentzia-protokoloak datu-blokeei aplikatzen zaizkie, eta ez hitzei. Hori dela eta, bi prozesadorek aldagai desberdinak erabiltzen badituzte, baina aldagai (hitz) horiek datu-bloke berean badaude, koherentzia- protokoloaren ikuspuntutik datuak partekatu egiten dira: partekatze faltsua dagoela esaten da. Partial Store Ordering Kontsistentzia-eredu malguetako bat; wr>>rd eta wr>>wr ordenak ez errespetatzea onartzen da. Payload Pakete edo mezu bakoitzean doan datu atala. Atal horrez gain, kontrol- informazioa ere garraiatu behar da paketeetan. Hori dela eta, d datu-flit transmititzeko, d+k flit transmititu beharko da. Peak performance Konputagailu baten kalkulu-abiadura gorena. Maximo hori ez da askotan oso adierazgarria, maximotik nahiko urrun izango baita benetako abiadura ohiko kasuetan. Maximoa hori zein den jakiteko, nahikoa da koma higikorreko unitate funtzionaleko kopurua eta erloju-maiztasuna biderkatzea (datu bat zikloko, unitate funtzional guztietan batera). Peeling(lerrokatzea) Begiztak paralelizatzeko teknika bat. Begizta batetik abiatuta, beste begizta bat sortzen da, iterazio desberdineko aginduak nahasiz. Hau da helburua: begizta berrian parte hartzen duten aginduen arteko datu-dependentzia guztiak 0 distantziakoak izatea, horrela sinkronizazio-beharra desagerrarazi egiten baita. Jatorrizko begiztako hasierako eta bukaerako agindu batzuk prozesadore bakar batean exekutatu behar dira. Perfect shuffle(tartekatze perfektua) Komunikazio-eskema bat, zeinean, une jakin batean, prozesadore guztiak bikoteka komunikatzen diren. Komunikazio-eskemak permutazio bat osatzen du. Permutazio honetan, komunikazioko helburua iturburu-helbideko biten biraketa da, bit bat ezkerrera (edo eskuinera). Esaterako (011) â†’ (110). Grafikoki adierazita, honela lor daitezke helburuak: erdibitu prozesadore multzoa bi zatitan, eta berrordenatu prozesadoreak tartekatze perfektua erabiliz: [0, 1, 2, 3] [4, 5, 6, 7] â†’ [0, 4, 1, 5, 2, 6, 3, 7] Permutazioak (permutation) Komunikazio-patroi multzo bat, zeinetan, une jakin batean, prozesadore guztiek bikoteka komunikatu behar duten. Adibidez: 0â†’1, 1â†’2, 2â†’3, 3â†’4, 4â†’5, 5â†’6, 6â†’7 eta 7â†’0. Komunikazioaren helburuak prozesadoreen permutazio gisa eman daitezke, eta hortik dator izena. Komunikazio mota horiek arruntak dira SIMD sistemetan. Phit Zenbait testuingurutan, bi bideragailuren arteko kanalen zabalera (physical unit). Gaur egun arrunta da phit = flit = 8 edo 16 bit izatea. Post Ekoizle/kontsumitzaile ereduan erabiltzen den puntutik punturako sinkronizazio- funtzioa. Adierazle edo gertaera jakin bat aktibatzen du, zerbait gertatu dela (datu bat kalkulatu da, esaterako) abisatzeko. Programazio sinkronizatua Aldagai partekatuen erabilera "babesteko" sinkronizazio-eragiketak erabiltzen dituen programazio-estiloa, ohikoa bestalde. Purge Koherentzia-informazioa cacheetan banatzen denean, kopia zerrendak antolatuz, eta SCI estandarrari jarraituz, kopia guztiak baliogabetzen dituen eragiketaren izena (INV). Râˆž eta N1/2 Bektore-konputagailuen errendimenduko bi parametro klasikoak. Râˆž parametroak programa baten kalkulu-abiadura maximoa adierazten du, bektoreak oso luzeak (infinitu) direnean. N1/2 parametroak kalkulu-abiadura maximoaren erdia (Râˆž/2) lortzeko behar den bektore-tamaina minimoa adierazten du. Antzeko esanahiarekin erabiltzen dira bi parametro horiek sistema paraleloetan ere, kalkulu-abiadura maximoa eta problemaren tamaina abiadura maximoaren erdia lortzeko, edo komunikazio-abiadura maximoa eta mezuen luzera minimoa abiadura maximoaren erdia eskuratzeko. RdEx Prozesadore batek idazketa bat egin nahi du cachean ez duen hitz baten gainean; beraz, blokea eskuratu egin behar du eta gainerako kopiak baliogabetu. Horretarako, RdEx (read-exclusive) izeneko kontrol-mezua bidaliko du direktoriora (SMP sistemetako BR + INV kontrol-seinaleen baliokidea). Read-modify-write Atomikoki exekutatu behar den agindu mota bat: memoriako posizio bat irakurtzen da, aldatu, eta, ondoren, memorian idazten da. Eragiketa osoa inongo interferentziarik gabe betetzen da. Mota horretako aginduak dira, esaterako, Test&Set, Fetch&Op eta abar. Release Consistency Kontsistentzia-eredu malguenetako bat. Sinkronizazio motako memoria- eragiketekiko ordena ezartzen da, ez besterik; gainera, bi motatan banatzen dira sinkronizazio-eragiketak: sa, acquire (esaterako, lock), eta sr, release (esaterako, unlock). Ordena hauek bakarrik errespetatzen dira: sa >> rd, wr eta rd, wr >> sr (eta sinkronizazioen artekoak noski). Reply forwarding Koherentzia-protokoloen komunikazioa betetzeko estrategia baten izena. A-tik B- ra eskaera bat egiten bada, eta eskatzen dena C-n badago, eragiketa B-ren parte-hartzearekin beteko da, eragiketaren latentzia eta sortzen den trafikoa murrizteko asmoz, honela: A â†’ B â†’ A; A â†’ C â†’ A ==> A â†’ B â†’ C â†’ A Roll-Out Koherentzia-informazioa cacheetan banatzen denean, kopia zerrendak antolatuz, eta SCI estandarrari jarraituz, kopia bat zerrendatik (cachetik beraz) ezabatzeko exekutatu behar den prozeduraren izena. Router / Routing / Routing recordâ€¦ Ikus mezu-bideragailua / bideratzea / bideratze-erregistroa... Sarraila (lock) Semaforo gisa erabiltzen den sinkronizazio-aldagaia, esaterako sekzio kritiko baterako sarrera kontrolatzeko. Eskuarki aldagai bitar bat da: 0, bidea irekita dago; 1, bidea itxita dago. Arrunta da mota horretako aldagaiak erabiltzea lock eta unlock errutinetan. Sarrailak erabiltzen direnean, atomikotasuna bermatu egin behar da. Sarraila-bektoreak (lock vector) Sekzio kritikorako sarrerak kudeatzeko teknika bat. Prozesuek sarraila pribatu bana (sarraila-bektore baten osagai bana) erabiltzen dute sekzio kritikoan sartzeko. Sekzio kritikoa uzten duen prozesuak hurrengo prozesuaren sarraila irekiko du. Beraz, sekzio kritikoan ateratzea eta sartzea bi prozesuren artean bakarrik gertatzen da, eta, ondorioz, buseko trafikoa (sarraila dela eta) murrizten da. Scatter (barreiaketa) Konputagailu paraleloetan, prozesadore batean dauden datuak (matrize bat, esaterako) prozesadore guztietara banatzeko komunikazio-funtzioa, prozesadore bakoitzak datuen parte bat izan dezan. Bektore-konputagailuetan, bektore- erregistro batean dagoen bektore bat (pauso ez konstantekoa) memoriara barreiatzeko eragiketa. Indize-bektore bat erabili behar da eragiketa horretan. SCI (Scalable Coherent Interface) IEEE erakundeko estandar bat, prozesadoreen konexio-interfaze osoa definitzen duena. Zehazten dituen gaietako bat datu-koherentzia mantentzeko protokolo jakin bat da. Hau da protokolo horren ezaugarri nagusia: koherentziako informazioa cacheetara banatzen da, eta datu-blokeekin esteka bikoitzeko zerrendak osatzen dira. Sekzio kritikoa(critical section) Algoritmo bat hainbat prozesutan banatuta izan arren, nahitaez seriean exekutatu behar den kode zati bat. Sekzio kritikoa kudeatzeko (prozesu bakar bat dagoela kode hori exekutatzen ziurtatzeko) lock eta unlock errutinak erabiltzen dira. Self-scheduling (ikus autobanaketa) SIMD(Single-Instruction-Multiple-Data) Flynn-en sailkapenaren arabera, multiprozesadore mota bat. Prozesadoreek modu sinkronizatuan exekutatzen dituzte programen aginduak, datu desberdinen gainean. Zenbait aplikaziotan, eredu hori oso eraginkorra da (esaterako, irudien tratamendua). Sinkronizazioa(synchronization) Sistema paralelo batean, prozesuen arteko komunikazio mota bat, kontrolekoa. Algoritmo gehienetan, paraleloan exekutatu ahal izateko, prozesuen lana sinkronizatu egin behar da, batzuetan kode zati batzuk seriean exekutatzeko, beste batzuetan prozesuen arteko datu-ematea gauzatzeko (ekoizle/kontsumitzaile eredua), edo prozesu guztiak programaren puntu jakin batean biltzeko. Sinkronizazioa sarrailen, gertaeren eta hesien bidez, edo, bestela, komunikazio-funtzioen bidez, gauzatzen da. Sinkronizazio-kontagailua Begizta baten iterazioak paraleloan exekutatzen direnean, haien arteko datu- dependentziak sinkronizatzeko erabiltzen den kontadorea. Dependentzia baten kontadorean k balioa badago, k arteko iterazio guztiak bukatu dira (dependentzia jakin horri dagokionean), baina k+1 iterazioa ez; beste iterazioei buruz ez da ezer esaten. Sinkronizazio-kontagailuek gertaera- bektoreek baino askoz memoria gutxiago behar dute, nahiz eta horiek bezain malguak ez izan. SISD(Single-Instruction-Single-Data) Flynn-en sailkapenaren arabera, prozesadore bakarreko konputagailua. SMP Symmetric multiprocessor. Komunikazio-sare gisa busa erabiltzen duten memoria partekatuko multiprozesadoreen beste izen bat. Memoriaren erabilerari egiten dio erreferentzia izenak: simetrikoa, denbora bera behar da edozein hitz eskuratzeko. Snoopy (ikus zelataria) SPMD Single-Program-Multiple-Data. Programazio paraleloko eredu bat. Programa bera exekutatzen dute prozesadore guztiek, datu desberdinekin. Ez da SIMD eredua bezalakoa, exekuzioa ez baitago sinkronizatuta. Prozesadore guztietan programa bera izanagatik, exekuzioak ez du zertan berdina izan behar, prozesadoreek identifikadore (pid) bana daramatelako eta exekuzio-bide desberdinak har ditzaketelako pid-ren arabera: if (pid==0) {...} else if (pid==1) {...} else ... SRAM(static RAM) Konputagailu baten cache memoria egiteko erabiltzen den teknologia, RAM estatikoa. RAM estatikoa dinamikoa baino azkarragoa da (4-6 bider azkarragoa), baina edukiera txikiagokoa da. Starvation Hainbat gailuren zerbitzu-eskaerak kudeatzen dituen algoritmo batek izan dezakeen arazoetako bat: "gosetea". Lehentasun-irizpideak direla medio, gailu jakin batek ez du inoiz baimena lortzen bere eragiketa egiteko, beste bati egokitzen baitzaio beti txanda. Adibidez, komunikazio-sistemak modu berean tratatu beharko lituzke prozesadore guztiak, eta aukera berdina eman mezuak sarean injektatzeko. Bestela, litekeena da prozesadore batzuek sarea paketeekin betetzea, eta beste batzuei paketeak bidaltzea ezinezkoa gertatzea (lehentasun-eskema desegokiaren ondorioa, beraz). Store-and-forward Mezuak edo paketeak sarean zehar aurrera egiteko teknika bat. SF erabiltzen denean, pakete osoa hartu arte itxaron egiten da, paketea hurrengo bideragailura birtransmititu baino lehen. Hori dela eta, komunikazio-latentzia proportzionala da korritu behar den distantziarekiko eta paketearen luzerarekiko (lehen hurbilpenean): Tsf ~ L Ã— D. Stride edo pausoa Bektore baten ondoz ondoko bi osagairen arteko distantzia memorian. Eskuarki, konstantea da. Esaterako, memoria-posizio hauetan dagoen bektoreko pausoa 8 da: 1000, 1008, 1016, 1024... Strip mining Bektore-erregistroetako tamaina dela eta, bektore-eragiketa bat hainbat zatitan banatzeko teknika. Erregistroen tamaina Lmax bada, osagai gehiagoko bektore- eragiketak egiteko, begizta bat antolatu beharko da, iterazio bakoitzean Lmax osagai prozesatzeko. Swap RMW motako agindu atomikoa. Erregistro baten eta memoriako aldagai baten edukiak trukatzen ditu, modu atomikoan: Rx â†â†’ A. Test&Set RMW motako agindu atomikoa. Memoriako aldagai bat erregistro batean uzten du, eta memoriako posizio horretan 1eko bat idazten du: Rx := A;A := 1. Test-and-Test&Set Test&Set aginduak erabiliz, sekzio kritiko baterako sarrera kontrolatzeko teknika bat. Sarrera bi fasetan banatzen da. Lehenbizikoan (test), sarraila- aldagaiaren balioa aztertzen da, besterik gabe; sarraila irekita badago, bigarren fasera igarotzen da (test&set), eta T&S agindu atomikoa exekutatzen da sarraila ixteko eta sekzio kritikora igarotzeko asmoz. Throughput Mezu-emaria. Komunikazio-sare batek segundoko garraia dezakeen pakete (edo byte) kopuru maximoa (baldintza egokietan). Ohiko kasuetan, trafiko-maila baxua denean, sareak pakete guztiak garraiatzen ditu haien helburuetara, eta portaera hori lineala da trafikoarekiko. Aldiz, balio maximo jakin bat gaindituta, sareak ezin du kudeatu pakete kopuru hori eta ase egiten da (hiriko trafikoarekin gertatzen den moduan). Sare egoki batek throughput handia izan beharko luke. Topologia Komunikazio-sare baten forma edo egitura fisikoa. Torua(torus) Sare estatikoen topologia arrunta. n dimentsioko torua dimentsio bateko eraztunaren orokortzea da. Toru bat sortzeko, maila bateko ertzetako prozesadoreak banan-banan lotzen dira, eraztunak osatzeko (dimentsioka). n dimentsioko toruan P = knprozesadore konektatzen dira, non k dimentsio bakoitzeko prozesadore kopurua baita. P handia eta bikoitia denean, toruaren diametroa nk/2 da, eta batez besteko distantzia nk/4. Sistema komertzialetan, 2 eta 3 dimentsioko toruak erabiltzen dira. Total Store Ordering / Processor Consistency Kontsistentzia-eredu malguetako bat: wr>> rd ordena ez errespetatzea onartzen da (load aurreratu eredua, beraz). Bigarrenean, PC, gainera, memoria-eragiketen atomikotasuna ez da bermatzen. Trapezoid self-scheduling Banaketa dinamikoko estrategia bat. Banatzen diren begizta zatiak gero eta txikiagoak dira, GSS teknikarekin gertatzen den modu berean, baina esleipen- eragiketa bakoitzean, zatiketa bat egin beharrean (/ P) hurrengo zatiaren tamaina kalkulatzeko, kenketa bat egiten da (â€“ k). Turn model Bideratze moldakorreko teknika bat. Paketeen blokeoak gainditzeko (pakete- zikloak saihesteko), pakete batek bidean zehar egin ditzakeen biraketetatik bat debekatzen da. Esaterako, bi dimentsioko kasurako, ziklo bat osa daiteke lau biraketa hauek egiten dituzten paketeekin: Nâ†’E, Eâ†’S, Sâ†’W eta Wâ†’E. Bat debekatuta, ez da posible pakete-ziklo hori osatzea (eta, beraz, blokeoa sortzea). Adibide bat:west first â†’ debekatzen da SW (edo, kontrako noranzkoan, NW) biraketa bidean zehar. Ondorioz, pakete batek mendebaldera jo behar badu, bidaiaren hasieran agortu beharko du bide zati hori. Txartelak(ticketak) Sekzio kritikorako sarrerak kudeatzeko teknika bat. Sarraila eskuratzeko lehian ibili beharrean, prozesuek txartel bat hartzen dute sekzio kritikoa exekutatu nahi dutenean, zeinean txanda-zenbaki bat esleitzen baitzaie, eta, gero, haien txandaren zain geratzen dira. Sekzio kritikoa uzten duenak, txanda aldagaia gehitzen du, hurrengo prozesu bati bidea emateko. Helburua sekzio kritikoan sartzeko sortzen den lehia (eta, ondorioz, buseko trafikoa) murriztea da. Urrats anitzeko sarea(multistage network) Kommutagailuen bidezko sare nagusiak. Kommutagailuak hainbat urrats edo etapatan banatzen dira. Urrats baten irteerak "berrordenatu" egiten dira hurrengo etapako sarreretan konektatu baino lehen. Berrordenatze edo permutazio horien arabera sare desberdinak lortzen dira. Adibide bat: Omega sarea. Uztartze-maila (coupling level) Multiprozesadore batean exekutatzen diren prozesuen arteko "komunikazio-maila" adierazten da termino horrekin. Uztartze-maila txikia bada (loosely coupled systems), komunikazio gutxi izango da prozesuen artean (adibidez, konputagailu- sare batean gertatzen dena, non erabiltzaileen arteko komunikazioa noizbehinkakoa den â€”posta-mezu bat, adibidezâ€”); handia bada, aldiz, prozesuak oso maiz komunikatuko dira elkarren artean (tightly coupled systems). Valid Cacheko direktorioko kontrol-bit bat (datu-bloke bakoitzean). Datu-blokeko informazioa erabilgarria dela adierazten du. VL erregistroa(vectorlength) Bektoreen osagai kopurua gordetzen duen erregistro berezia; LV edo SV aginduak exekutatu baino lehen egokitu behar da. VL da izen arrunta, nahiz eta, makinen arabera, desberdina izan daitekeen. Bektoreak edozein luzeratakoak izan daitezke; bektore-erregistroetako tamaina baino txikiagoak badira (VL < Lmax), VL osagai prozesatuko dira; aldiz, luzeagoak badira (VL > Lmax), bektore- eragiketa batean Lmax osagai baino ez dira prozesatuko, eta, bektore osoa prozesatzeko, begizta bat antolatu beharko da. VM erregistroa (vector mask) Maskara-erregistroa, bektore-erregistro boolear berezia, non bektore-konparazio baten emaitza (N adierazle, beraz) kargatzen den. Bektoreen gaineko eragiketak kontrolatzekoerabiltzen daVM erregistroa, aldaketak VM erregistroan adierazten diren posizio jakinetan baino ez baitira gertatuko. Esaterako, kasu honetan: do i = 0, N-1 if (A(i)=0) then A(i) = 2 enddo A(i) = 2 egin baino lehen, if aginduaren konparazioa egiten da, eta emaitza VM erregistroan kargatzen da. Gero, SV agindua posizio jakin batzuetan bakarrik beteko da, konparazioan baiezkoa eman duten posizioetan, alegia. VS erregistroa (vector stride) Bektore baten pausoa gordetzen duen erregistro berezia; LV edo SV aginduak exekutatu baino lehen egokitu egin behar da, bektore-osagaien arteko distantzia adierazteko. Wait Ekoizle/kontsumitzaile ereduan erabiltzen den puntutik punturako sinkronizazioaren parte bat. Kontsumitzailea zain dago adierazle edo gertaera jakin bat aktibatu arte. Weak Ordering Kontsistentzia-eredu malguenetako bat. Memoria-eragiketen ordena edozein izan daiteke, hauena izan ezik: s >> rd, wr; rd, wr >> s; s >> s. Hau da, sinkronizazio-eragiketak fence moduan tratatzen dira. Wormhole Paketeak sarean zehar aurrera egiteko teknika bat. Wormhole eta cut-through teknikak, funtsean, berdinak dira: paketeen goiburuko-informazio nahikoa hartu denean, paketea birtransmititzen hasten da, pakete osoa hartu arte itxaron gabe. Desberdintasuna gatazken kudeaketan bilatu behar da. Wormhole moduan, pakete baten goiburukoak aurrera segi ezin badu, behar duen kanala okupatuta dagoelako, transmisioa gelditu egiten da. Horrela, pakete baten flit-ak "hormatuta" geratzen dira sarean zehar. Cut-through moduan, aldiz, nahiz eta aurrera jarraitzea ezinezkoa den, paketea hartzen segitzen da, eta bideragailuan bertan metatzen da. irteera berrio libre izan arte. Write-back Cacheko idazketa-politikaren bat. Cachean hitz bat aldatu (idatzi) behar bada, hortxe bertan bakarrik aldatzen da, eta memoria nagusiko kopia ez da eguneratuko. Izan ere, memoria nagusia ez da eguneratuko cacheko blokea ordezkatu arte; une horretan, aldiz, bloke osoa idatziko da memoria nagusian (aldatuta badago), kontrol-informazioa (aldatuta / ez aldatuta) blokeka eramaten baita, eta ez hitzez hitz. Write-once Koherentzia-protokolo bat, zeinean aldagai baten lehenengo idazketan write- through idazketa-politika erabiltzen den, baina hurrengoetan (jarraian) write- back politika. Horrela idazketa-politika bakoitzaren ezaugarririk onenak aprobetxatu nahi dira. Write-through Cacheko idazketa-politikaren bat. Cachean hitz bat aldatu (idatzi) behar bada, eguneratu egin behar da, halaber, hierarkiako hurrengo mailan, kasu honetan memoria nagusian. Horrela, cacheko kopia eta memoria nagusiko kopia beti koherente mantentzen dira. Zelataria Komunikazio-sare gisa bus bat erabiltzen duten multiprozesadoreetan, datuen koherentzia mantentzeko gehien erabiltzen den gailuen izen generikoa. Busa sare partekatua eta zentralizatua denez, busean agertu behar dute datu- transferentzia eta aldaketa guztiek. Prozesadoreen cache-kontrolagailuek tai gabe zelatatuko dute busa, eta horrela jakingo dute "alboko" prozesadoreetan datu-blokeetan egindako aldaketez, bertako datu-blokeen egoerak egokitu ahal izateko. Horregatik du zelatari (snoopy, kuxkuxero) izena. Zerrenda estekatua (linked list) Koherentziako direktorioak antolatzeko estrategia bat. Koherentzia-informazioa ez da gordetzen, dena batera, toki jakin batean. Hori egin beharrean, informazio hori datu-blokeko kopiekin batera gordetzen da, cacheetan bertan. Datu-blokearen egoeraz gain, bi erakusle edo esteka gordetzen dira, hurrengo kopia eta aurreko kopia non dauden adierazteko; horrela, datu-bloke bakoitzaren kopia zerrenda estekatua, eta banatua, osatzen da. Zirkuitu-kommutazioa(circuit switching) Bi prozesadoreren arteko komunikazio-bidea eraikitzeko teknika bat. Komunikazioari ekin baino lehen, kontrol-mezu berezi bat bidaltzen da igorletik hartzailera, eta, bidean zehar, mezu horrek erreserbatu egiten ditu behar diren baliabideak bidea osatzeko. Helburura helduta, eta bidea eraikita beraz, baieztapen-mezu bat bidaltzen da atzera, zeinaren bidez bidea irekita dagoela abisatzen zaion igorleari. Gero, transmisioa hasten da, orain arazorik gabe, bide osoa erreserbatu baita mezu horretarako (adibide ezagun bat telefoniakoa da). ZKH proba Aginduen arteko dependentziak detektatzeko erabiltzen den proba sinplea. Bektoreak atzitzeko indizeak funtzio linealak direnean baino ez da erabiltzen. Adibidez, kasu honetan: do i = 1, L A(a*i+b) = A(c*i+d) + 1 enddo ZKH probaren arabera, ez dago dependentziarik, baldin eta (d â€“ b) / ZKH(a, c) ïƒ Z, hau da, zenbaki osoa ez bada. Zenbaki osoa bada, dependentzia egon daiteke, eta aztertu egin behar da ea begiztako mugen barnean dagoen. Zuzentasuna(fairness) Oro har, erabiltzaile askoren baliabide-eskaerak kudeatzen dituen edozein gailuk/algoritmok izan beharko lukeen propietatea: erabiltzaile guztiei aukera berdinak, edo behintzat arautuak, ematea.   26 Bertsiorik sinpleenean, multiplexore batzuk eta haiek kontrolatzeko logika baino ez da erabili behar kommutagailu bat egiteko.  27 Simetria lortzeko, lotura guztiek tamaina berekoak izan beharko lukete, ez irudikoa bezala; ariketa gisa, marraz ezazu lotura guztiak tamaina berekoak dituen 4Ã—4-ko toru bat (folded torus izenekoa).  28 Nodo baten helbide absolututik abiatuta, erraz lortzen dira haren koordenatuak; adibidez, 8Ã—8 tamainako maila batean, 50 helbideko prozesadorearen koordenatuak hauek dira: x1 = 50 / 8 = 6; x0 = 50 mod 8 = 2. P50 â†’ (6, 2).  29 Dakizunez, gauza bera erabaki behar da, esaterako, prozesadore supereskalarren erreserba-guneak diseinatu behar direnean (aginduak zain daude unitate funtzionalen erreserba-guneetan eragigaiak prest izan arte). Testuinguru horretan ere, ondorioak berdinak dira.  30 Internet-eko kasuan, esaterako, paketeak bertan behera uzten dira. Trafikoa handia bada, sarea ez da batere fidagarria (reliable) izango; hori dela eta, TCP/IP protokoloa erabili behar da (itxarote-denbora jakin bat pasa ondoren, paketeak birtransmititu egiten dira). Oro har, egoera hori ezin da onartu sistema paraleloetan.  31 Adi unitateekin. Batetik, L eta B, biak bytetan edo bitetan; eta, bestetik, L/ B eta tr, biak nanosegundotan (edo mikrosegundotan).  32 Oro har, flit-aren tamaina (paketea prozesatzeko informazio minimoa) k byte bada, 1/B â€”eta bukaeran(Lâ€“1)/Bâ€” izan beharrean, k/B eta (Lâ€“k)/B izango dira.  33 Bestela, komunikazioa hurbileko nodoetan kontzentratzen bada, pakete gehiago onartu litezke sarean, erdibiketako loturak erabiliko lituzketen paketeak gutxiago liratekeelako, Bestalde, sareko topologiaren mugak baino ez ditugu kontuan hartu; izan ere, muga gehiago kontuan hartu behar dira kasu errealetan, nabarmenki prozesadoreen eta bideragailuen arteko interfazean ageri daitezkeenak.  34 Origin 3900 multikonputagailua da azken bertsioa (2003). Prozesadorea MIPS R16000 da (800 MHz). Sistemaren topologia zer edo zer aldatu da (crossbar/ hiperkuboa); erdibiketaren banda-zabalera, esaterako, 210 GB/s da orain, aurreko bertsioen halako hiru.  35 Bloke baten egoera cachean E-tik M-ra aldatzen denean, ez zaio direktorioari abisatzen aldaketaz, trafiko gutxiago sortzearren. Izan ere, cacheetan dauden datu-bloke gehienak pribatuak izango dira (kopia bakarra) eta bakan batzuk baino ez partekatuak; datu pribatuek, jakina, ez dute koherentzia-protokoloan parte hartzen, eta berdin dio zein egoeratan dauden direktorioan.  36 Mezu horrek ez du zerikusirik koherentziarekin, eraginkortasunarekin baizik. L- k 2b eta 3b mezuak heldu arte itxaron egin behar du, blokea egokia den ala ez jakiteko. Baina (1) 2b mezua heltzen bada lehena, exekuzioari ekin diezaioke L- k, modu espekulatiboan, (itxaron gabe); eta (2) blokea E egoeran baldin bazegoen R-n eta ordezkatu bada, ezin izango da R-tik bidali; beraz, H-tik bidali beharko da, eta kasu horretan eragiketaren latentzia handiagoa izango da. Edonola ere, trafikoa (kontuz!) hazi egingo da blokea R-tik askotan birbidali behar bada. Beraz, garrantzitsua da "asmatze-tasa" handiak izatea hipotesi horretan (E = E izatea, eta ez E = M).  37 Eragiketa ez zegoen bukatuta oraindik (esaterako, L-ren ACK mezua falta zen); hala ere, idazketa lokala zen, eta agian aurrera jarraitzea erabaki da, edo testuinguru-aldaketa bat egin da beste prozesu bat exekutatzeko.  38 SCI estandarrak edozein topologia onartzen du: katea, eraztuna, sare hierarkikoak, urrats anitzeko sareak (Omega) eta abar. 64 k prozesadoreraino onartzen ditu: helbideak 64 bitekoak dira, 16 bit prozesadore bat adierazteko, eta gainerako 48 bitak memoria-helbide bat adierazteko.  39 Exclusive / Stale egoera bikotea aplikazio batzuetan ageri den partekatze-kasu arrunt bati erantzun egokia emateko erabiltzen da. Izan ere, askotan bloke bat bi prozesadoreren artean baino ez da partekatzen. Batek idazten duenean, bestearen kopia Stale (zaharra) egoeran uzten da, baina ez da lotura ezabatzen. Hala, bigarrenak blokea berriz erabili behar duenean, badaki nora joan behar duen haren bila, memoria nagusiko direktorioa kontsultatu behar izan gabe.  40 Ordena horretan egin behar da: lehenik, direktorioko informazioa egokitu, eta gero kopiak baliogabetu; bestela, lasterketa-arazoak gerta litezke. Hain zuzen ere, baliogabetzeari ekin badiogu eta, tartean, bloke hori eskatzeko mezu bat heltzen bada direktoriora, H-tik bertatik bidaliko litzateke blokea (Fresh!), eta, azkenean, koherentzia ez litzateke mantenduko (bloke baten bi kopia desberdin!).  41 Dakigunez, arkitektura paraleloak bi motakoak dira: memoria partekatua eta memoria banatua. Kapitulu honetan, memoria partekatuko eredua hartuko dugu kontuan, eta eredu horretarako "programazio-estandar" bat dago, OpenMP, non hurrengo ataletan aztertuko ditugun hainbat teknika erabiltzen baitira. Beste eredurako (memoria banaturako) ere, programazio-estandar bat dago, MPI izenekoa, komunikazio-funtzio (send/receive) asko eskaintzen duena prozesuen arteko komunikazioa gauzatzeko.  42 Begizten exekuzio paraleloa adierazteko aukerak ari gara aztertzen, ez exekuzioen eraginkortasuna. Izan ere, begizta hori ez da oso egokia paraleloan exekutatzeko, sinkronizazioaren kostua agindu sinple horien exekuzio-denbora baino askoz luzeago izango baita; gainera, beste faktore batzuk ere kontuan hartu behar dira (garrantzitsuena, segur aski, cachea nola erabiltzen den). Geroxeago aztertuko dugu eraginkortasunaren arazoa.  43 Agindu horiek ez dute dependentziarik begizta berrian exekutatzen diren aginduekin; beraz, begizta baino lehen (ohikoa) edo begizta eta gero exekuta daitezke (edo batzuek hasieran eta besteak bukaeran).  44 Oro har, tartekatze-mailakbada, honela banatuko da begizta: do i = pid*k, N-1, P*k  do j = i, i+k-1   45 Begizta-iterazioak sinkronizatu behar badira, ez da egokia ondoz ondoko iterazioak banatzea. Beraz, antzeko estrategia erabili behar da, baina iterazio tartekatuak dituzten begizta zatiak banatuz, tartekatze-maila prozesadore kopurua izanik.  46 ïƒ©N/Pïƒ¹ kalkulatzea baino errazagoa ohi da (N+Pâ€“1)/P kalkulatzea (zatiketa hutsa). Bestalde, zatien tamaina k baino handiagoa izatea interesatzen bazaigu (agian, azken zatiarena izan ezik), (N+kPâ€“1)/P tamainako zatiak esleitu behar dira (N = banatzeko geratzen den iterazio kopurua).  47 Moore-ren legearen arabera, konputagailuen eboluzioa, arlo askotan, ez da lineala, esponentziala baizik; hala, txipen transistore kopurua, memorien edukiera, erloju-maiztasuna, kalkulu-abiadura, transmisio-abiadura, eta abar, bikoiztu egiten dira denbora tarte jakin batean. Azken 20-30 urteetan, arau hori zehatz bete da, baina ez dago garbi etorkizunean ere beteko den, orain arte erabili diren teknologiek beraien muga fisikoetatik oso hurbil daudelako. 
