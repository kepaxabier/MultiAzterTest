                                        KONPUTAGAILUPARALELOAK                             AbiaduraHandikoKonputazioa                                  A. Arruabarrena ‚Äî J. Muguerza                  Konputagailuen Arkitektura eta Teknologia saila             Informatika Fakultatea ‚Äî Euskal Herriko Unibertsitatea                                   KONPUTAGAILUPARALELOAK                             AbiaduraHandikoKonputazioa                                           A. Arruabarrena ‚Äî J. Muguerza                  Konputagailuen Arkitektura eta Teknologia saila             Informatika Fakultatea ‚Äî Euskal Herriko Unibertsitatea                                         2011ko iraila                                                                                                                                         AURKIBIDEA     Sarrera 1 1.kapitulua. Bektore Konputagailuak 7 1.1. Zer dira bektore-konputagailuak? 7 1.1.1. Zenbait arazo 10 1.1.1.1. Bektore-konputagailu baten memoria 10 1.1.1.2. Unitate funtzionalak 11 1.1.1.3. Bektore-erregistroak 11 1.1.1.4. Programak 12 1.1.2. Arkitektura eta makina-lengoaia 13 1.2. Datu-dependentziak 15 1.2.1. Kateaketa (chaining) 16 1.2.1.1. Kateaketa bi agindurekin 17 1.2.2. Aginduen exekuzioko taulak 18 1.3. Egiturazko dependentziak 19 1.3.1. Memoriako busak (LV/SV unitate funtzionalak) 20 1.3.2. Gatazkak memoria-moduluetan 22 1.3.2.1. Memoria-eragiketa bakarra 22 1.3.2.2. Memoria-eragiketa bat baino gehiago 25 1.3.3. Bektore-erregistroen luzera (strip mining) 29 1.4. Bektore-konputagailuen kalkulu-abiadura 30 1.4.1. Kalkulu-abiadura bektoreen luzeraren arabera 30 1.4.1.1. R‚àû eta N1/2 30 1.4.1.2. Azelerazio-faktorea(speed-up) 33 1.4.1.3. Nb 34 1.4.2. Kalkulu eskalarraren eragina: Amdahl-en legea 34 1.5. Bektore-kodea sortzeko teknika nagusiak 37 1.5.1. Aginduen arteko datu-dependentziak 38 1.5.2. Bektorizazioa 40 1.5.2.1. Dimentsio bakarreko bektoreak 40 1.5.2.2. Dimentsio anitzeko bektoreak 44 1.5.2.3. Begizta bat bektorizatu ahal izateko baldintza 46 1.5.2.4. Datu-dependentziak analizatzeko proba 46 1.5.3. Optimizazioak 50 1.5.3.1. Aurreranzko ordezkapen globala (global forward substitution) 50 1.5.3.2. Indukzio-aldagaiak 51 1.5.3.3. Antidependentziak (WAR) 52 1.5.3.4. Irteera-dependentziak (WAW)53 1.5.3.5. Begizta-trukea (loop-interchanging)54 1.5.3.6. Hedapen eskalarra (scalar expansion)57 1.5.3.7. Begizten fusioa (loop fusion)57 1.5.3.8. Begizten kolapsoa (loop collapsing)58 1.5.3.9. Beste zenbait optimizazio 59 1.5.4. Maskara- eta Indize-bektoreak 60 1.5.4.1. Maskaren erabilera 60 1.5.4.2. Indize-bektoreak 61 1.6. Laburpena 64 2.kapitulua.Konputagailu Paraleloak (oinarrizko kontzeptuak) 69 2.1. Sarrera 69 2.2. DM-SIMD konputagailuak 71 2.3. MIMD konputagailuak 73 2.3.1. Memoria partekatua (shared memory)73 2.3.2. Memoria banatua edo pribatua (distributed memory)74 2.3.3. Memoria logikoki partekatua baina fisikoki banatua (distributed shared memory)75 2.3.4. Clusters, constellations... eta abar 76 2.4. Arazoak 77 2.5. Sistema paraleloen eraginkortasuna. Amdahl-en eta Gustafson-en legeak 79 3. kapitulua. Datuen koherentzia SMP Konputagailuetan83 3.1. Problemaren nondik norakoa eta kontzeptuen berrikuspena 83 3.1.1. Datuen koherentzia prozesadore bakarreko konputagailuetan 84 3.1.2. Datuen koherentzia memoria partekatuko multiprozesadoreetan 85 3.1.3. Partekatze faltsua 87 3.1.4. Koherentziaren definizioa 87 3.2. Zelatatze motako koherentzia-protokoloak 88 3.2.1. Bloke baten egoerak, eta kontrol-seinaleak 90 3.2.2. Baliogabetze-protokoloak 94 3.2.2.1. Hiru egoerako protokolo bat, MSI 94 3.2.2.2. Illinois protokoloa, MESI 97 3.2.2.3. Berkeley protokoloa, MOSI 99 3.2.2.4. Baliogabetze-protokoloen laburpena 101 3.2.3. Eguneratze-protokoloak 101 3.2.3.1. Firefly protokoloa, MSE(I)102 3.2.3.2. Dragon protokoloa, MOES(I)104 3.2.4. Zelatatze-protokoloen laburpena 105 3.3. Zelatatze-protokoloen gauzatzea 105 3.3.1. Arazoak 105 3.3.1.1. Cachearen direktorioa 106 3.3.1.2. Idazketa-bufferrak 107 3.3.1.3. Bus-eskaerako protokoloa 108 3.3.1.4. Atomikotasuna: koherentzia-kontrolagailuaren egoera 109 3.3.2. Illinois koherentzia-protokoloa berriz 110 3.3.2.1. Lasterketak: egoera iragankorrak, kontrol-seinaleak 110 3.3.2.2. Deadlock, livelock eta starvationarazoak 112 3.4. Zelatari hierarkikoa 113 3.4.1. Irakurketak 115 3.4.2. Idazketak 116 4. kapitulua.Prozesuen Sinkronizazioa SMP Konputa-gailuetan 119 4.1. Sarrera 119 4.2. Elkarrekiko esklusioa (mutual exclusion) 123 4.2.1. Test&Set eta Swap aginduak 125 4.2.1.1. Test&Set agindua 125 4.2.1.2. Swap agindua 125 4.2.1.3. Trafikoaren analisia 126 4.2.1.4. Test&Setwith backoff prozedura 127 4.2.1.5.Test-and-Test&Set prozedura 128 4.2.1.6. Ezaugarrien laburpena 130 4.2.2. Load Locked / Store Conditional eta Compare&Swap aginduak 131 4.2.2.1. LL eta SC aginduak 132 4.2.2.2. Compare&Swap agindua 134 4.2.2.3. Zenbait arazo LL eta SC aginduekin 135 4.2.3. Fetch&Op aginduak 136 4.2.4. Trafikoa murrizteko hobekuntzak 137 4.2.4.1. Txartelak 137 4.2.4.2. Sarraila-bektoreak 139 4.3. Puntutik punturako sinkronizazioa gertaeren bidez (events) 141 4.4. Hesien bidezko sinkronizazioa (barriers) 142 4.4.1. Hesi sinple batv142 4.4.2. Hesi berrerabilgarriak 143 4.4.3. Eraginkortasuna 145 4.5. Laburpena 146 5. kapitulua.Memoriaren Kontsistentzia Konputagailu Paraleloetan 149 5.1. Sarrera 149 5.1.1. Prozesadore bakarreko sistemak 149 5.1.2. Multiprozesadoreak 150 5.1.3. Programen semantika eta aginduen exekuzio-ordena 151 5.1.4. Aginduen atomikotasuna 153 5.1.5. Kontsistentzia-ereduak 154 5.2. Kontsistentzia sekuentziala (SC, sequential consistency) 155 5.2.1. Memoria-eragiketen ordena eta atomikotasuna 156 5.2.2. Eragina hardwarean eta konpiladorean 158 5.3. Eredu malguak (relaxed) 159 5.3.1. Total Store Ordering (TSO) / Processor Consistency (PC)160 5.3.2. Partial Store Ordering(PSO)162 5.3.3. Eredu malguenak 162 5.3.3.1. Weak Ordering (WO)163 5.3.3.2. Release Consistency (RC)164 5.4. Laburpena eta perspektibak 166 6. kapitulua.Konputagailu Paraleloen Komunikazio Sarea. Mezu Ematearen bidezko Komunikazioa. 169 6.1. Sarrera 169 6.2. Sarearen topologia 171 6.3. Kommutagailuen bidezko sareak 173 6.3.1. Kommutagailua (switch)174 6.3.2. Crossbar sarea 174 6.3.3. Urrats anitzeko sareak (multistage)175 6.3.3.1. Omega sarea 176 6.3.3.2. Bideratzea Omega sarean 178 6.3.3.3. Irteera-gatazkak eta blokeoak 179 6.3.3.4. Beste komunikazio mota bat: broadcast-a.181 6.3.3.5. Beste zenbait sare 181 6.3.3.6. Laburpena 183 6.4. Mezu-bideragailuen bidezko sareak 184 6.4.1. Mezu-bideragailuak 184 6.4.2. Sare-topologia erabilienak 185 6.4.2.1. Dimentsio bakarreko sareak: katea eta eraztuna (chain, ring) 186 6.4.2.2. Mailak eta toruak (mesh, torus)186 6.4.2.3. Hiperkuboak (hypercube)188 6.4.2.4. Arbolak eta arbola sendoak (fat tree)189 6.4.2.5. Topologien laburpena 191 6.4.2.6. Lotura fisikoak 192 6.5. Komunikazioa sarean zehar 193 6.5.1. Mezuak 193 6.5.2. Norekin eta noiz komunikatu behar da? Komunikazio-patroiak 195 6.5.3. Bidea eraikitzea (switching strategy)197 6.5.4. Mezuak bideratzea (routing)199 6.5.4.1. Bideratze-erregistroa 199 6.5.4.2. Bide-aukeratzea: estatikoa edo moldakorra 203 6.5.5. Informazio-jarioaren kontrola (flow control)205 6.5.5.1. Mezuak aurrera joateko teknikak: Store-and-forward, Wormhole eta Cut- through 206 6.5.5.2. Baliabide-gatazkak: paketeetarako bufferrak 209 6.5.6. Komunikazioaren eraginkortasuna: mezuen latentzia eta mezu-emaria 213 6.5.6.1. Sareko komunikazio-denbora 214 6.5.6.2. Trafikoa kontuan hartuz 216 6.5.6.3. Mezu-emari maximoa 218 6.5.6.4. Analisi globala 220 6.5.7. Zenbait komunikazio-arazo 221 6.5.7.1. Pakete-blokeoak (deadlock). Kanal birtualak. Biratze kontrolatuak (Turn model). Paketeen injekzioa kontrola-tzea. Bide seguruen erabilera 222 6.5.7.2. Livelock eta Starvationarazoak 228 6.5.8. Komunikazio-protokoloak 229 6.6. Konputagailu paraleloen eboluzioa 231 Eranskina. Batez besteko distantzien kalkulua hainbat topologiatarako 235 7.kapitulua.Datuen Koherentzia DSM Konputagailuetan 241 7.1. Sarrera 241 7.2. Koherentzia-direktorioak 243 7.2.1. Sarrera eta sailkapena 243 7.2.1.1. Arazoak 245 7.2.2. Direktorioen egitura 246 7.2.2.1. Memoria nagusiaren ondoko direktorioak 246 7.2.2.2. Cache memorietan banatutako direktorioak 251 7.2.3. Koherentzia-trafikoaren optimizazioa 254 7.2.4. Eragiketen atomikotasuna: lasterketak 257 7.3. Koherentzia-protokoloen gauzatzea: bi adibide 259 7.3.1. SGI Origin multikonputagailuetako koherentzia-protokoloa 259 7.3.1.1. Irakurketak 260 7.3.1.2. Idazketak 263 7.3.1.3. Memoria nagusiaren eguneratzeak 268 7.3.2. SCI koherentzia-protokolo estandarra (Sequent NUMA-Q)269 7.3.2.1. SCI: egoerak eta eragiketak 270 7.3.2.2. Irakurketak 272 7.3.2.3. Idazketak 273 7.3.2.4. Memoria nagusiaren eguneratzeak 277 7.3.2.5. Atomikotasuna eta lasterketak 277 7.4. Laburpena 279 8.kapitulua.Begizten Paralelizazioa eta Atazen Banaketa 281 8.1. Sarrera 281 8.1.1. Oinarrizko ideiak begizten paralelizazioari buruz 287 8.2. Begizten paralelismo-maila adierazteko egitura nagusiak 290 8.2.1. Iterazioen arteko dependentziarik gabeko begiztak: doall begiztak 290 8.2.2. Iterazioen arteko dependentziak dituzten begiztak 291 8.2.2.1. Forall begiztak (sinkronizazio globala)292 8.2.2.2. Doacross begiztak ("puntutik punturako" sinkronizazioa) 293 8.2.3. Antidependentzien eta irteera-dependentzien eragina 298 8.2.4. Adi if aginduekin 299 8.3. Sinkronizazioaren gauzatzea 300 8.3.1. Sinkronizazioa kontagailuen bidez 301 8.3.2. Kontagailu bakar bat prozesadore bakoitzeko 303 8.4. Begiztak eraginkorki paralelizatzeko optimizazio nagusiak 304 8.4.1. Dependentziak ezabatu edo minimizatu 304 8.4.2. Begizten fisioa 305 8.4.3. Aginduen berrordenatzea 306 8.4.4. Dependentzien lerrokatzea (peeling)307 8.4.5. Hari independenteak sortzea (switching)308 8.4.6. Sinkronizazioko eragiketa kopurua txikiagotzea 309 8.4.7. Begizten tratamendua (berrordenatzea...)311 8.4.7.1. Begizta-trukea 311 8.4.7.2. Noranzko-aldaketa 313 8.4.7.3. Desplazamenduak (skew)314 8.4.7.4. Begizten kolapsoa eta koalestzentzia 315 8.5. Atazen banaketa (scheduling) 316 8.5.1. Banatzen diren iterazioak: ondoz ondokoak edo tartekatuak 316 8.5.2. Banaketa estatikoa edo dinamikoa 318 8.5.2.1. Banaketa estatikoa 318 8.5.2.2. Banaketa dinamikoa: autobanaketa (self eta chunk scheduling), autobanaketa gidatua (GSS) eta trapezoidala (trapezoid self-scheduling)319 8.6. Atal paraleloak: Fork / Join 323 8.7. Eraginkortasunaren analisia 324 9.kapitulua.Abiadura Handiko Konputagailuak. OpenMP eta MPI: Programa Paraleloak Sortzeko Tresna Nagusiak (sarrera) 327 9.1. Abiadura handiko konputagailuak 328 9.2. OpenMP eta MPI: programa paraleloak sortzeko tresna nagusiak (sarrera) 331 9.2.1. OpenMP 332 9.2.2. MPI 336   Bibliografia 341 Glosategia 345                                           Sarrera                          Zein eguraldi izango dugu bihar bailara honetan? Nola eboluzionatzen dira galaxiak? Nolakoa da atomoen elkarrekintza klorofila-molekula batean? Hegazkineko hegoen portaera egokia izango da turbulentzia baten barruan? Galdera horiei, eta beste askori, erantzun egokia emateko, zientzialariek eta ingeniariek konputagailuak erabiltzen dituzte, konputagailuak baitira, gaur egun, laborategiko tresna nagusiak. Zientzia eta teknika arloetan exekutatzen diren programetan egin behar den kalkulu kopurua itzela da, ia mugaezina, eta gainera ahalik eta denbora laburrenean egin behar da (ordu baten barruan eroriko den euri erauntsia bihar asmatzea ez da errenta!); zoritxarrez, nahiz eta prozesadoreak gero eta azkarragoak izan, erabiltzaileen beharrak handiagoak dira beti. Behar horiei irtenbide bat emateko, hau da, prozesadoreen exekuzio- abiadura handitzeko, hiru arlo jorratu dira, nagusiki, konputagailuen historian zehar: teknologia elektronikoa, sistemaren egitura edo arkitektura, eta software-teknologia. Teknologia elektronikoaren bidez lortu da transistore kopuru itzela txip bakar batean integratzea: dagoeneko 1.000 milioitik gora (eta gero eta gehiago). Aurrerapen hori dela eta, gero eta "gailu" gehiago integratzen dira prozesadorearekin batera txip bakar batean: unitate funtzional bereziak, erregistroak, cache memoria... baita hainbat prozesadore edo nukleo (core) ere. Era berean, erloju-maiztasunak gero eta handiagoak dira, 1-4 GHz-eko tartean dagoeneko ("lasterketa" hori dagoeneko gelditu bada ere). Beraz, oinarrizko zikloaren denbora oso txikia da (F = 1 GHz ‚Üí T = 1 ns), eta, ondorioz, eragiketa gehiago egin daitezke segundo bakoitzeko. Sistemaren arkitekturaren aldetik, dagoeneko "klasikoak" diren estrategiak erabiltzen dira: aginduen exekuzio segmentatua, supereskalarra edo VLIW motakoa (txip bakar batean integratzen diren nukleoak sinpleagoak ohi dira); memoriaren egitura hierarkikoa, cachea ere hainbat mailatan banatuta, memoria-atzipen azkarrena erdiesteko; erregistro-multzoaren erabilera egokia, datuak eskuratzeko behar den denbora minimizatzearren; eta abar. Konpilazio-teknikak ere asko aurreratu dira. Aginduen arteko datu- eta kontrol- dependentzien eragina minimizatzea da helburu nagusia, unitate funtzionalen latentzia ‚Äîeragiketak betetzeko behar den denbora‚Äî "ezkutatu" ahal izateko (denbora hori lan baliagarria egiteko aprobetxatuz). Hala ere, prozesadoreak oso azkarrak izan arren ‚Äîazkarrenek 10 Gflop/s-ko kalkulu-abiadura erraz gainditzen dute‚Äî, ez dira behar adinakoak hainbat aplikaziotarako, haien artean, adibidez, eguraldiaren iragarpena, prozesu fisikoen eta kimikoen simulazioak, aeronautikako diseinuak, prospekzio geologikoak, material berrien diseinua, ingeniaritzako garapenak, biologiako, genetikako eta farmaziako ikerkuntzak, irudien prozesamendua eta abar. 1986-2002 urteetan, prozesadoreen errendimenduaren hobekuntza-tasa urteko % 52 (!) izan zen, baina tasa hori asko jaitsi da, % 20ra, azken urteetan: prozesadore bakar batekin lor daitekeen kalkulu-abiadura bere muga fisikoetara (eta ekonomikoetara) heldu da. Beraz, aipatutako aplikazioetarako behar diren kalkulu-abiadura handiak lortzeko (Teraflop/s, Petaflop/s..., hau da, segundoko 1012, 1015... koma higikorreko eragiketa), arlo berriak jorratu behar dira. Konputagailuen eboluzioan eman behar den hurrengo "jauzia" argi dago: aplikazioen exekuzioaprozesadore askoren artean banatzea; hau da, paralelismoa eta sistema paraleloak erabiltzea. Gainera, txipak fabrikatzeko teknologiak erraztu egiten du aukera hori: prozesadore (txip) bat eginda, aise egiten dira milaka, prezio onean gainera. Beraz, zergatik ez erabili 100, 1.000, 10.000... prozesadore problema bat ebazteko? Teorian, eta P prozesadore nola erabili jakingo bagenu, P aldiz azkarrago exekutatuko genituzke programak. Zoritxarrez, ez dugu hori lortuko, arazo berri asko agertuko baitira: nola banatu behar da lana prozesadoreen artean? sinkronizatu behar al dira prozesuak? nola gauzatuko da haien arteko komunikazioa?... Aukera asko dagoP prozesadore konputagailu bakar bat gisa egituratzeko. Ezaugarri batzuk komunak dituzte eta beste batzuk, aldiz, ez. Arkitektura edo egitura horiek sailkatzeko saio bat baino gehiago egin da. Ezagunena eta erabiliena, sinplea eta zaharra izanda ere (1966), Flynn-en sailkapena da. Bi parametro kontuan hartzen dira sailkapen horretan: agindu-jarioen kopurua ‚Äîhots, programa-kontagailuen kopurua‚Äî eta datu-jarioen kopurua. Irudian, Flynn- en sailkapenaageri da.                                                   datu-jarioak                                         bakarra                 asko   agindu-jarioak    bakarra              SISD                   SIMD                       asko                                      MIMD   ‚ñ™ SISD (Single-Instruction-Single-Data) motako konputagailuak Programa bakar batek datu multzo bakar batekin lan egiten du; beraz, prozesadore bakarreko ohiko sistemak dira hauek (konputagailu pertsonalak, lan- estazioak...). Zenbait kasutan, prozesadore bat baino gehiago dago horietako makina batean, baina, eskuarki, modu independentean egiten dute lan. Aipatu dugunez, oraingo prozesadoreek "segmentatuak" dira. Aginduen exekuzioa hainbat fasetan banatzen da ‚Äîbilaketa, deskodeketa, eragigaien irakurketa, memoria, unitate aritmetikoa, emaitzen idazketa...‚Äî, eta fase edo urrats bakoitzean agindu bat (edo batzuk, prozesadore supereskalarren kasuan) ari da prozesatzen; beraz, une oro hainbat agindu ari dira exekutatzen batera, fase desberdinetan: agindu-mailako paralelismoa erabiltzen da (ILP, Instruction Level Parallelism). Gainera, hardwarearen zein konpiladorearen laguntzaz, prozesadorea gauza da aginduen jatorrizko exekuzio-ordena aldatzeko, exekuzio ahalik eta eraginkorrena (azkarrena) erdiesteko. Irakurleak kontzeptu horiek guztiak badakizkiela kontsideratuko dugu.   ‚ñ™ SIMD (Single-Instruction-Multiple-Data) motako konputagailuak Mota honetako konputagailuetan, agindu bera exekutatzen da batera prozesadore guztietan, baina datu desberdinak prozesatzen dira. Sistema hauetan, beraz, datu-mailako paralelismoa (DLP, Data Level Parallelism) ustiatzen da. Bi arkitektura bereizi ohi dira: array processors izeneko makinak (distributed memorySIMD) eta bektore-konputagailuak (shared memorySIMD). Lehenbiziko kasuan, prozesadore asko eta "oso sinpleak" (esaterako, bit bateko 16 k prozesadore) erabili ohi ditu konputagailuak, eta prozesadore guztiek programa bera exekutatzen dute, modu sinkronizatuan, baina datu desberdinak prozesatuz. Mota horretako makina asko egin ziren 80-95 urte bitartean, eta oso eraginkorrak dira zenbait aplikaziotan (irudiak eta seinaleak prozesatzeko, zenbakizko kalkulua egiteko...), baina agortu den eredua da eta ez dira jadanik fabrikatzen (antzeko ideiak eta egiturak hiru dimentsioko ingurune birtualak sortzeko erabiltzen ari badira ere). Bai, ordea, bektoreak prozesatzen espezializatutako bigarren motako makinak, bektore-konputagailuak, alegia.   ‚ñ™ MIMD (Multiple-Instruction-Multiple-Data) motako konputagailuak Arkitektura paraleloen kasu orokorra da. Prozesu asko exekutatzen dira konputagailuan, datu multzo desberdinen gainean. Adi: ez da soilik SISD motako makina multzoa, prozesadoreetan exekutatzen diren programak ez baitira independenteak. Hori da eredua abiadura handiko konputazioa eskuratzeko: paralelismo masiboko konputagailuak, non P prozesadore (kopuru handia) elkarlanean aritzen diren problema bat ebazteko; hau da, hari-mailako paralelismoa ustiatzen da (TLP, Thread Level Parallelism). Oro har, hari-mailako paralelismoak datu-mailakoak baino aukera gehiago eskaintzen du exekuzio-abiadura handiagotzeko. Hala ere, sistema eraginkorrak lortu ahal izateko, irtenbide egokia bilatu beharko zaie prozesadore bakarreko sistemetan ageri ez diren hainbat arazo berriri. Hurrengo kapituluetan ikusiko dugunez, bi motako arkitekturak bereiz daitezke MIMD sistemetan:   ‚Ä¢ Memoria partekatuko sistemak: prozesadore guztiek memoria-espazio bera erabiltzen dute. Memoria zentralizatuta (SMP, symmetric multiprocessors) edo banatuta (DSM, distributed shared memory) egon daiteke. Hala, prozesuen arteko komunikazioa aldagai partekatuen bidez egiten da.   ‚Ä¢ Memoria pribatuko sistemak: prozesadore bakoitzak memoria-espazio pribatua erabiltzen du. Kasu honetan, prozesuen arteko komunikazioa mezu-ematearen bidez egiten da.   Hurrengo kapituluetan, MIMD motako konputagailu paraleloak aztertuko ditugu. Lehenbizikoan, ordea, SIMD gisa sailka daitezkeen konputagailu berezi eta oso eraginkorrak analizatuko ditugu: bektore-konputagailuak. Horien arkitektura berezia da, eta leku garrantzitsua lortu dute konputazioaren historian. Bigarren kapituluan, sistema paraleloen aurkezpen xumea egingo dugu: eredu eta arkitektura nagusiak, arazo behinenak, Amdahl-en legea... Hirugarren kapituluan, SMP sistemen datuen koherentzia aztertuko dugu: zelatatze- protokoloak; laugarrenean, prozesuen arteko sinkronizaziorako agindu eta prozedura bereziak: T&S, LL, SC...; eta bosgarrenean, memoria-sistemaren kontsistentzia-ereduak: kontsistentzia sekuentziala eta eredu malguak. Seigarren kapituluan, prozesadoreen arteko komunikazioa ahalbidetzen duten sareen topologia, egitura eta erabilera aztertuko ditugu, bai eta prozesadoreen arteko komunikazioen eraginkortasuna ere. Zazpigarrenean, datuen koherentzia analizatuko dugu berriro, baina DSM sistemetan: koherentzia-direktorioak. Zortzigarrenean, begizten paralelizazioa eta iterazioen banaketa analizatuko ditugu. Azkenik, konputagailu paraleloen eboluzioa, merkatua, oraingo egoera eta etorkizuna ikusiko ditugu (top500 zerrenda), bai eta, gainetik bada ere, sistema paraleloak programatzeko oinarrizko tresnak ere: OpenMP (memoria partekatuko SMP sistemetarako) eta MPI (mezu-ematea, DSM zein MPP sistemetarako).                                         ‚ñ™ 1‚ñ™                                BektoreKonputagailuak                  1.1. ZER DIRA BEKTORE KONPUTAGAILUAK? Sarreran aipatu dugunez, MIMD motako makinak dira problema orokorrak paraleloan ebazteko arkitekturarik egokienak. Hala ere, problema garrantzitsu jakin batzuetarako, eraginkortasun handiko exekuzioak lor daitezke beste arkitektura mota bat erabiliz. Kalkulu zientifikoko programen exekuzio-denbora gehiena begiztak exekutatzen xahutzen da. Esaterako:   do i = 0, N-1 C(i) = A(i) + B(i) enddo   N oso handia bada (N = 109 esaterako), benetan sinplea den begizta horren exekuzio-denbora oso luzea izango da. Prozesadore eskalar batean exekutatzen bada, hau bezalako kodea exekutatuko da (adibidez): beg: FLD F1,A(R1) FLD F2,B(R1) FADD F3,F2,F1 FST C(R1),F3  ADDI R1,R1,#8 SUBI R2,R2,#1 BNZ R2,beg   Prozesadore eskalar batean, kasurik onenean, agindu bat zikloko exekutatuko da, hau da, gutxienez 7 ziklo beharko ditugu begizta-iterazio bat exekutatzeko; ondorioz, programaren exekuzio-denbora osoa TE=7N ziklo izango da1. Bi ezaugarri berezi ditu aurreko begiztak. Batetik, prozesatzen diren datu- egiturak oso erregularrak dira: A, B eta C bektoreak; eta, bestetik, begizta- iterazio guztiak edozein hurrenkeratan exekuta daitezke, ez baitago inongo datu-dependentziarik haien artean. Defini dezagun zer diren, testuinguru honetan, bektoreak. Hiru parametro hauen bidez definitzen den datu-egitura da bektorea:   ‚Ä¢ hasiera-helbidea: bektorearen aurreneko osagaiaren memoria-helbidea. ‚Ä¢ luzera: bektorearen osagai kopurua. ‚Ä¢ pausoa(stride): ondoz ondoko bi osagairen arteko distantzia memorian.   Adibidez, 1000, 1002, 1004, 1006, 1008, 1010, 1012 eta 1014 memoria-posizioetan metatzen den bektorea (osagai bat memoria-posizio bakoitzeko) honela definitzen da:   hasiera-helbidea = 1000 luzera = 8 pausoa = 2   Prozesadore eskalar batek, izenak dioen moduan, datu eskalarrekin (zenbaki soilekin) egiten du lan. Zientzia- eta ingeniaritza-alorretan, aldiz, bektoreak oso maiz erabiltzen dira, eta aurrekoa bezalako programak behin eta berriz exekutatu behar izaten dira, eta, ondorioz, denbora asko behar izaten da. Zergatik ez erabili arkitektura eta makina-lengoaia bereziak, zuzenean bektoreak prozesatzeko? Esaterako, zergatik ez idatzi aurreko programa beste modu honetan? LV V1,A(R1) ; irakurriAbektorea LV V2,B(R1) ; irakurriBbektorea ADDV V3,V1,V2 ; batu bi bektoreak (emaitza,V3erregistroan) SV C(R1),V3 ; idatzi emaitzaCbektorean   Zer adierazi (exekutatu) nahi dugu LV V1,A(R1) aginduarekin? Bada, honako hau (segmentazio-eskema adibide bat baino ez da2):      LV V1,A  BD    Ir    AM     M     M     M      Id    (R1)                         Ir    AM     M     M      M      Id                               Ir    AM     M      M      M      Id                                     Ir    ...    ...    ...    ...                                            Ir     AM     M      M     M    Id   Adierazpena sinplifikatzeko, honela ere adieraz daiteke bektore-agindu baten exekuzioa:      LV V1,A  BD    Ir    AM    M    M    M    Id    Id    ...    ...      Id    (R1)   Hau da, agindu bakar batekin bektore osoa (N osagai) irakurtzen da memoriatik, ez osagai bakar bat! Horretarako, memoriak tartekatua izan behar du; hala, beste arazorik izan ezean, osagai bat eskuratu ahal izango dugu memoriatik ziklo bakoitzean, eta bektore-erregistro batean idatzi. Honela geratuko litzateke aurreko programaren exekuzioa (unitate funtzionalen latentziak adibide jakin bat baino ez dira):   LV V1,A  BD Ir AM M  M  M   Id  ... (Nziklo)... (R1) LV V2,B     BD Ir AM M  M   M   Id  ... (Nziklo) ... (R1) ADDV           BD .  .  .   .   Ir   A   A   Id  ... (Nziklo) ... V3,V1,V2 SV C              BD Ir AM  .    .   .   .   Ir   M   M    M  Id  ... ...  Id (R1),V3          1  2  3  4  5  6   7    8   9  10   11  12   13  14  15  ... ... 14+N  t h N   (oraingoz, demagun irakur daitezkeelaADDVetaSVaginduetako eragigaiak taulan markatu ditugun zikloetan, 8an eta 11n, alegia). Exekuzio-eredua hori bada, analisi sinple bat egin daiteke programaren exekuzio-denbora kalkulatzeko (sinplifikazio asko ari gara egiten; geroxeago formalizatuko ditugu kalkuluak): azken aginduaren idazketa faseari ekin baino lehen, ziklo kopuru jakin bat behar da, hasiera-denbora, th; eta gero, exekuzioa bukatzeko, N ziklo behar dira, bektore-osagai bakoitzeko bat. Beraz: TB= th+ N Adierazpen hori prozesadore eskalar baterako lortu dugunarekin konparatzen badugu, garbi ageri da abantaila. Esaterako, bektoreen osagai kopurua N = 128 bada eta th = 14 ziklo bada, honako exekuzio-denbora hauek izango ditugu:   TE=7N = 896 ziklo TB= th+ N = 142 ziklo (aurrekoaren % 16)   Ez da hori abantaila bakarra. Batetik, begiztari dagozkion kontrol- dependentzia3 guztiak desagertu dira, definizioz begizta bera desagertu baita bektore-kode berrian. Bestetik, 4 agindu baino ez da exekutatu behar, eta ez 7N, begizta eskalarrekoak. Hori dela eta, agindu-cachea askoz gutxiago erabiliko da, eta, ondorioz, buseko trafikoa txikiagoa izango da. Baina, jakina, hori guztia ez dator musu-truk. Egia esan, gauza asko aztertu eta analizatu behar ditugu xeheago aurreko exekuzio-eskeman, agindu berezi horiek exekutatzeko beharko diren baliabideak ezagutzeko. 1.1.1. Zenbait arazo 1.1.1.1. Bektore-konputagailu baten memoria Bektore-prozesadore batek modu intentsiboan erabiltzen du memoria. Esaterako, aurreko adibidean, hiru aginduk erabiltzen dute batera memoria: bi LV eta SV bat; eta, gainera, agindu bakoitzak N "hitz" irakurri edo idatzi behar ditu memorian! Bi arazo konpondu behar dira:   1. Zenbat bus daude memoriarako? Memoria-sistema eta prozesadorea datu-bus baten bidez komunikatzen dira. Memoriako bektore-agindu bakar batek N hitzeko transferentzia eskatzen du, eta, beraz, N ziklotan zehar okupatuko du busa (demagun hitz bakar bat transferitzen dela ziklo bakoitzean). Ondorioz, komunikazio-bus bakarra balego, agindu bakar batek erabili ahal izango luke memoria, eta gainerakoek itxaron egin beharko lukete aurrekoak bukatu arte, busa erabili ahal izateko. Ondorioz, exekuzio-denbora ez litzateke N ordenakoa izango, baizik eta kN-koa (k = 2, 3..., memoria-aginduak).   2. Ez al da gatazkarik izango memoria-moduluen erabilera dela eta? Nahiz eta memoria-espazioa tartekatua izan (hainbat memoria-moduluren artean), litekeena da memoria-modulu berean izatea behar diren bektore-osagaiak. Beraz, atzipen bati ekiteko, itxaron egin beharko genuke aurreko atzipena bukatu arte. Hortaz, exekuzio-denbora handiagoa izango litzateke. Izan ere, bektore-konputagailu baten memoria-sistema oso garrantzitsua da: memoriarako bide (bus) askobehardira, eta memoriak tartekatutaegonbehardu,moduluaskotan, atzipen-gatazkak minimizatu ahal izateko. 1.1.1.2. Unitate funtzionalak Aurreko exekuzio-eskema aztertu ondoren, argi eta garbi ageri da unitate funtzionalek segmentatuak izan behar dutela. Agindu bakar batekin (ADDV, esaterako) N eragiketa (batuketa) exekutatzen dira, zikloko bat. Batugailua segmentatuta ez balego, ez litzateke posible izango datu bat zikloko lortzea. Era berean, mota bakoitzeko unitate funtzional bat baino gehiago izatea egokia izango da, agindu batek N ziklotan zehar okupatuko baitu unitate funtzionala. 1.1.1.3. Bektore-erregistroak Zer dira bektore-erregistroak? Zer tamainakoak dira? Nola irakurtzen eta idazten dira? Bektore-erregistro batean, bektore baten osagaiak gordetzen dira. Osagai bakoitza, eskuarki, koma higikorreko eskalar bat da, 64 bitekoa esaterako. Beraz, bektore bat gordetzeko, 64ÔÇ¥N bit behar ditugu. Erregistroen edukiera, jakina, ez da mugagabea. Kasurik arruntenetan, 64 edo 128 bektore-osagai gordetzeko gauza dira (Lmax); hots, bektore-erregistro batean 64 (edo 128) ÔÇ¥ 64 = 4 (edo 8) kilobit gordetzen dira. Tamainari erreparatuz, aise ulertzen da erregistro-multzoan erregistro asko ez izatea. Eskuarki, 8-16 erregistro izango ditugu (16 ÔÇ¥ 8 = 128 kilobit). Zenbait konputagailutan, erregistroen tamaina moldakorra da; hau da, erregistro- multzoko "memoria-espazioa" luzera txikiko erregistro asko edo luzera handiko erregistro gutxi definitzeko erabil daiteke.           Zer egin prozesatu behar ditugun bektoreen tamaina Lmax maximo hori (64 edo 128) baino handiagoa bada? Bada, begizta bat osatu behar da, eta iterazio bakoitzean Lmax osagai prozesatu (strip mining). Berriro agertuko dira, beraz, kontrol-dependentziak, nahiz eta orain 64 (128) alditik behin izan. Aurreneko bektore-konputagailuetan, bektore-erregistroak "bloke" bat gisa tratatzen ziren; hala, esaterako, bektore baten osagai guztiak idatzi arte ezin zen erregistroaren edukia irakurri. Oraingo bektore-konputagailuetan, aldiz, bektore-erregistro bat osatzen duten elementuak independenteki helbidera daitezke, eta, ondorioz, erregistro baten lehenengo osagaiak irakurri egin daitezke oraindik osagai guztiak idatzita ez badaude ere. Bestalde, bektore bat idazteak hainbat ziklo behar dituenez, agindu bat baino gehiago izango dira idazten, aldi berean, erregistro-multzoan. Nahitaez, erregistroetarako idazketa-bus bat baino gehiago (asko) beharko ditugu (era berean, irakurketa-bus ugari ere beharko ditugu). Bektore-konputagailuenerregistroak, beraz,gailu konplexuak dira. 1.1.1.4. Programak Zer programa mota exekuta daiteke bektore-konputagailu batean? Bektore- konputagailuak optimizatuta daude bektoreak prozesatzeko. Baina, programa errealetan, bektoreak prozesatzeaz gain kode eskalarra ere prozesatu beharko da. Nola egiten da hori? Zer eragin dauka kalkulu-abiaduran? Gero ikusiko dugun moduan, kalkulu eskalarraren eragina oso handia izan daiteke sistema osoaren errendimenduan. Bestalde, azter dezagun berriro zer egiten dugun bektoreak prozesatzen ditugunean. Kontuan hartu adibide hau:   do i = 0, N-1 A(i) = A(i) + 1 enddo Eskalarki exekutatzen bada, eta sinplifikatuz, honako hau izango litzateke aginduen hurrenkera (L = load; S = store; + = batuketa; i = bektorearen i osagaia):   L0 +0 S0 / L1 +1 S1 / L2 +2 S2 / L3 +3 S3 / ... / LN‚Äì1 +N‚Äì1 SN‚Äì1   Bektore gisa exekutatuz gero (LV-ADDV-SV), beste hurrenkera hau izango genuke:   L0 L1 L2 ... LN‚Äì1 / +0 +1 +2 ... +N‚Äì1 / S0 S1 S2 ... SN‚Äì1   Hau da, begizta bektorialki exekutatzen bada, ez da errespetatuko aginduen jatorrizko hurrenkera. Zoritxarrez, hainbat kasutan ezin da hurrenkera hori aldatu, errespetatu egin behar baitira aginduen arteko datu-dependentziak. Beraz, kasu horietan ezin izango dugu begizta bektorialki exekutatu. Programa bat bektore moduan exekuta daitekeen ala ez erabakitzeko, datu-dependentziak sakon analizatu behar dira; ikusiko dugun moduan, bektore-konpiladoreak asko lagunduko digu langintza horretan.   Aurreko guztia laburbilduz: balizko eraginkortasun handiko eredua definitu badugu ere, arazo asko gainditu beharko ditugu kalkulu-abiadura handiak lortzeko. 1.1.2. Arkitektura eta makina-lengoaia Bektore-konputagailuen arkitekturak askotarikoak dira, fabrikatzaileen arabera. Hasierako bektore-konputagailuek ez zituzten erregistroak erabiltzen, eta eragiketa guztiak memoriarekin egiten ziren. Eredu horri "Memoria-Memoria" (M/ M) deritzo. Baina laster bektore-erregistroak gehitu ziren, eta hala dira oraingo bektore-prozesadore guztiak: bektore-eragiketen eragigaiak erregistroetatik hartzen dira eta emaitzak erregistroetan uzten dira (R/ R eredua). Hurrengo irudian, bektore-konputagailu baten eskema logikoa ageri da. Bi atal bereiz daitezke: atal eskalarra eta atal bektoriala. Prozesadore eskalarra aginduak bilatzeaz eta deskodetzeaz arduratzen da. Agindua arrunta bada, eskalarra, berak exekutatuko du, behar diren erregistroak erabiliz; bektoriala bada, aldiz, bektore-prozesadoreari pasatuko dio kontrola, agindua exekuta dezan. Besterik adierazi ezean, kontrol-unitatea Tomasulo eredukoa (desordena / desordena) izango da.                             Aipatu dugunez, bektoreak prozesatuko baditugu ere, errealitatean kode eskalarraren eta bektorialaren nahastea izango dugu programa gehienetan. Beraz, agindu eskalarrak zein bektorialak erabili beharko ditugu. Agindu eskalarrak ez ditugu aipatuko, ohikoak baitira. Bektore-agindu asko dago, formatu askotarikoak, konputagailuen arabera. Hona hemen adibide ohikoenak (geroxeago aztertuko ditugu beste batzuk):   OPV Vi,Vj,VkVi = Vj OP Vk (OP = ADD,SUB,MUL,DIV...) Bi bektoreren arteko eragiketa. Emaitza bektore bat da.   OPVS Vi,Vj,FkVi = Vj OP Fk OPVI Vi,Vj,#bVi = Vj OP #b (OP = ADD ,SUB,MUL,DIV...) Bektore baten eta eskalar baten arteko eragiketa. Emaitza bektore bat da.   LV Vi,A(Rj) Irakurri egiten da memorian (A+Rj) hasiera-helbideko bektorea, eta Vi erregistroan uzten da (helbideratze-modu gehiago egon daiteke).   SV A(Rj),ViAntzekoa, baina bektore bat memorian idazteko. Hiru parametro eman behar dira bektore bat identifikatzeko: hasiera-helbidea, luzera eta pausoa. Hasiera-helbidea LV/SV aginduetan bertan adierazten da (helbideratze-moduen arabera). Bektorearen luzera eta pausoa, aldiz, lehenago adierazi behar dira. Bi erregistro berezi erabiliko ditugu horretarako: VL (vector length), luzera emateko (zenbat osagai), eta VS (vector stride), pausoa zehazteko. VL-ren edukia Lmax (erregistroen tamaina maximoa) baino handiagoa bada, Lmax osagai prozesatuko dira. Adibidez, honako agindu hauek exekutatu behar ditugu bektore bat irakurtzeko:   MOVI VL,#64 ;bektorea 64 osagaikoa da MOVI VS,#8 ;pausoa 8 da   LV V1,A(R1)   Hala, bektore baten 64 osagai kargatuko dira V1 erregistroan, A+R1, A+R1+8,A+R1+16,A+R1+24... helbidekoak.   Zenbait konputagailutan, bektoreen pausoa esplizituki adierazi behar da aginduan bertan, eta horretarako erregistro-multzoko erregistro orokor bat erabiltzen da.   1.2. DATU DEPENDENTZIAK Prozesadore (super)eskalarretan gertatzen den bezala, datu-dependentziek mugatu egiten dute bektore-prozesadoreen kalkulu-abiadura. Bi aginduren artean datu- dependentzia dagoela esaten dugu, baldin eta bigarrenak lehenengoak sortuko duen emaitza erabili behar badu; beraz, eragigaia eskuratzeko, bigarren agindua gelditu egin beharko da aurrekoaren exekuzioa bukatu arte. Datu-dependentzien eragina arintzeko, zirkuitulaburrak (unitate funtzionalen arteko konexio bereziak) erabiltzen dira prozesadore eskalarretan (forwarding). Bektore- prozesadoreetan ere antzeko ideia erabiltzen da. Hurrengo adibideetarako, honako segmentazio-eskema hau erabiliko dugu (Tomasulo):   LV/SV ‚Üí BD Ir AM M M M Id ADDV ‚Üí BD Ir A A Id 1.2.1. Kateaketa(chaining) Bi agindukateatu egiten direla esaten da, baldin eta lehenengoak sortzen dituen bektore-osagaiak bigarrenak erabiltzen baditu, sortu ahala, bektore- erregistroan gorde arte itxaron gabe. Ikus dezagun adibide sinple bat:   do i = 0, N-1 LV V1,A(R1) A(i) = A(i) + 1 ‚Üí ADDVI V2,V1,#1 enddo SV A(R1),V2   Programa horrek datu-dependentzia garbiak ditu: LV ‚Üí ADDVI (V1) eta ADDVI ‚Üí SV (V2). Nola exekutatzen da, bada, programa hori? Bi aukera ditugu: aginduen arteko kateaketa egin gabe, edo aginduen arteko kateaketa eginez.   a. Kateaketa_egiten_ez_bada, bigarren aginduak itxaron egin behar du lehenengoa bukatu arte, dagokion bektore-erregistroa (V1) irakurri ahal izateko. Irudian, exekuzioaren eskema bat ageri da (aztertu noiz exekutatzen diren Ir faseak).   LV V1,A  BD Ir AM M  M  M  Id ... Id  (R1)  ADDVI       BD .  .  .  .  .  ... .  Ir A  A  Id ... Id  V2,V1,#1  SV A           BD Ir AM .  .  ... .  .  .  .  .  ...  .  Ir  M   M   M  Id ...  (R1),V2   zikloak       ‚Üê 6‚Üí      ‚Üê N‚Üí  ‚Üê 3‚Ü   ‚Üê N‚Üí     ‚Üê 4‚Üí  ‚Üê N   Beraz, honako exekuzio-denbora hau lortzen da: TB=13 + 3N ziklo.   b. Aldiz, kateaketa_egiten_bada, sortu ahala erabiltzen dira bektore-osagaiak hurrengo unitate funtzionalean; hots, prozesadore eskalarretan ohikoa den Id ‚Üí Ir zirkuitulaburra egiten da.  LV V1,A(R1)       BD  Ir AM M  M  M  Id Id ... (Nziklo) ... ADDVI V2,V1,#1        BD .  .  .  .  Ir A   A  Id  Id   ... (Nziklo... SV A(R1),V2              BD Ir AM .  .  .   .  Ir   M    M  M  Id  ... ...  Id zikloak ‚Üê‚Üê‚Üê                             ‚Üê N‚Üí         6‚Ü3‚Ü4‚Üí   Orain, beste hau izango dugu exekuzio-denbora: TB=13+N ziklo. Portaera hori kualitatiboki ere azter daiteke. Esaterako, honela exekutatuko da aurreko programa (LV / ADDV / SV), denboran zehar, kateaketaren arabera:           kateaketa erabili gabe:T~ 3Nkateaketa erabiliz: T~N   Desberdintasuna ageri-agerian dago. Lehenbiziko kasuan, exekuzio-denbora 3N ordenakoa da; bigarrenean, aldiz, N ordenakoa baino ez. Esaterako, N = 64 bada, exekuzio-denbora 13 + 3√ó64 = 205 ziklotik 13 + 64 = 77 ziklora jaisten da (% 38). Beraz, eraginkortasuna lortzeko bektore-konputagailuetan, aginduak kateatzeko aukera izatea ia ezinbestekoa da.   1.2.1.1. Kateaketa bi agindurekin Aurreko adibidean, agindu bakar batekin egin da eragigaien kateaketa: ADDVI agindua LV aginduarekin, edo SV agindua ADDVI aginduarekin. Kasurik konplexuenean, ordea, bi datu-jario erabili beharko genituzke kateaketarako. Ikus adibide hau (C = A + B):   LV V1,A  BD Ir AM M  M  M   Id   Id  ... (Nziklo)... (R1) LV V2,B     BD Ir AM M  M   M    Id  Id  ... (Nziklo) ... (R1) ADDV           BD .  .  .   .    Ir   A   A  Id   Id  ... (Nziklo) ... V3,V1,V2 SV C              BD Ir AM       .    .   .  Ir   M    M   M   Id  ... ...  Id (R1),V3          1  2  3  4  5  6   7    8    9  10  11   12  13   14  15          14+N   Hirugarren aginduak (ADDV) lehenengoak eta bigarrenak sortzen dituzten V1 eta V2 bektoreak erabili behar ditu. Baina bi bektore horiek ez datoz "sinkronizatuta", lehenengoa 7. zikloan eta bigarrena 8. zikloan sortzen baitira (eta hortik aurrera gainerako osagaiak). Beraz, 7. zikloan ez dago prest bigarren eragigaiaren lehenengo osagaia, eta 8.ean "galdu" egin da lehenengoarena (ez da galdu, noski, bektore-erregistroan gordetzen ari baita). Kateaketa egiteko, honako hau egin beharko da: eragigai bat unitate funtzionaletik hartu, eta bestea idazten ari den erregistrotik (V1). Hori egin ahal izateko, erregistro-multzoak onartu egin behar du erregistro bat irakurtzea idazten ari den aldi berean (ohikoa da oraingo bektore- konputagailuetan: flexible chaining edo kateaketa malgua); hori egiterik ez badago, kateaketarako aukera galdu egingo da (beste soluziorik erabiltzen ez bada, behintzat) eta itxaron egin beharko da eragigaien idazketa bukatu arte. 1.2.2. Aginduen exekuzioko taulak Bektore-programen exekuzioa urratsez urrats analizatzea astuna da. Hori dela eta, exekuzio-eskema horiek egin beharrean, taula batean bilduko ditugu aginduen exekuzioan zehar gertatzen diren ekintza edo datu nagusiak:   ‚Ä¢ Exekuzioaren hasiera: zenbat ziklo igaro diren, hasieratik, unitate funtzionala erabili baino lehen. Exekuzioaren hasiera arrunta izan daiteke (eragigaiak erregistroetatik irakurri ondoren), edo kateaketaren bidezkoa. Azken kasu horretan,   while(adi==0) {}‚Üí wait(adi)   Erraza da funtzio horiek orokortzea adierazle- edo gertaera-bektoreak erabili ahal izateko:   post(adi,i)‚Üí aktibatu gertaera-bektoreareniosagaia:adi(i):= 1 wait(adi,i)‚Üí itxaron gertaera-bektoreareniosagaia 1 izan arte   4.4. HESIEN BIDEZKO SINKRONIZAZIOA(barriers) Programa baten exekuzio paraleloan beharrezkoa da, hainbat unetan, prozesu multzo bat elkarrekiko sinkronizatzea, denak batera; adibidez, prozesu guztiak exekuzio-puntu jakin batetik igaro direla ziurtatzeko. Sinkronizazio-eragiketa horretarako, hesiak erabiltzen dira. Sinkronizazio-hesiak eraikitzeko, sarrailak, kontagailuak eta adierazleak erabiltzen dira. Hesi batean P prozesu sinkronizatzen dira. Hesira heltzen diren prozesuek kontagailu bat gehitzen dute, elkarrekiko esklusioan, eta, gero, zain geratzen dira, prozesu guztiak hesira heldu arte. Azken prozesuak, kontagailuaren balioa P egiten duenak, hesia ireki egingo du, adierazle bat aktibatuz, eta, hala, prozesu guztiak itxarote-begiztatik aterako dira. Ikus ditzagun adibide batzuk. 4.4.1. Hesi sinple bat Adibidez, honako errutina hau erabil daiteke sinkronizazio-hesi bat egiteko. hesi_egitura motako struct partekatu (shared) bat erabili dugu, non hiru aldagai ezagutarazten baititugu: sarraila bat (sekzio kritiko bat antolatzeko), kontagailu bat, eta hesiaren egoera adierazten duen adierazle bat: 0, itxita; 1, irekita. Horrez gain, nire_kont aldagai pribatua ere erabiltzen da, hesira zenbat prozesu heldu diren jakiteko.   struct hesi_egitura { intsar; sarrailarako aldagaia int kont; hesira heldu den prozesu kopurua int egoera; hesiaren egoera }; structhesi_egituraH; hesia ezagutarazteko  HESIA (H,P) P= prozesu kopurua { LOCK(H.sar); sartu sekzio kritikoan if (H.kont==0)H.egoera = 0; lehenengoa naiz, itxi hesia H.kont++; nire_kont = H.kont; zenbat heldu diren hesira UNLOCK(H.sar); utzi sekzio kritikoa  if (nire_kont==P) azkena naiz { H.kont = 0; kontagailua hasieratu H.egoera = 1; ireki hesia } else while(H.egoera==0) {}; itxaron hesia ireki arte }   Hesia exekutatzen dutenean, prozesuek H.kont kontagailua gehitzen dute, sekzio kritiko baten barruan; gainera, hesira heldu den aurreneko prozesuak (H.kont = 0) itxi egiten du hesia (H.egoera = 0). Ondorioz, prozesuak zain geratzen dira begizta batean, harik eta hesia ireki arte. Helduko den azken prozesuak (H.kont = P) irekiko du hesia (H.egoera = 1), eta, ondorioz, zain zeuden prozesuak sinkronizazio-hesitik aterako dira, eta programa exekutatzen jarraituko dute. Sekzio kritikoaren barruan kontagailua gehitu eta gero, nire_kont aldagaia erabili dugu, gero hesira zenbat prozesu heldu diren jakiteko eta hesia ireki behar den edo ez erabakitzeko. Kodea idatzita dagoen moduan, ezin dugu H.kont kontagailua erabili horretarako, beste prozesu bat egon daitekeelako, une horretan, kontagailu hori gehitzen. H.kont aldagaia erabili nahi badugu funtzio horretarako, if aginduaren konparazioa sekzio kritikoaren barruan egin beharko genuke, eta, gero, sekzio kritikoa bi adarretatik (then eta else) bukatu (unlock). 4.4.2. Hesi berrerabilgarriak Arazoren bat aurreko hesiarekin? Bai, baldin eta behin eta berriz erabili behar bada (esaterako, begizta baten barruan): kalkulua / hesia / kalkulua / hesia... Ez ahaztu: liburutegiko (edo erabiltzailearen) sinkronizazio-funtzio bat da hesia, eta prozesuek behin eta berriz erabiliko dute exekuzioan zehar. Demagun sinkronizazio-hesia exekutatzen ari dela. Azken prozesuak hesia irekitzen duenean, prozesu guztiek hesitik atera eta programaren exekuzioarekin jarraituko dute. Exekutatuko den kodean hesi bera berriro erabiltzen bada, esaterako, begizta baten barruan, beste sinkronizazio-eragiketa baterako, litekeena da prozesu bat hesian berriro sartzea, bigarren aldiz, beste prozesu bat oraindik lehenbizikotik atera gabe dagoenean, ez baitu "jakin" hesia ireki dela (adibidez, exekuzioan ez zegoelako). Hesian bigarren aldiz sartu den lehenbiziko prozesuak hesia itxi egingo du (une horretan H.kont = 0 delako), dagokion adierazlea desaktibatuz (H.egoera = 0). Hori dela eta, oraindik lehenbiziko sinkronizazio-hesian geratu d(ir)en prozesuak ezingo du hesia abandonatu, berriro itxi egin delako; gainera, bigarren hesian sartuko direnak ere han geratuko dira betiko, inoiz ez baitira P prozesuak sartuko, bat (edo gehiago) atzean geratu da eta. Sistema blokeatu egin da.   Nola gainditu arazo hori? Aukera batzuk daude; esaterako,   a. Beste kontagailu bat erabil daiteke, hesitik ateratzen diren prozesuak kontatzeko. Hala, prozesu batek ezin izango du hesian berriro sartu harik eta guztiak aurreko hesia utzi arte. Prozedura hori erabiliz, batetik, sinkronizazioaren latentzia handiagoa izan daiteke (zenbait kasutan, itxaron egin behar da hesian sartu baino lehen; hala ere, hesiaren latentzia azken prozesuak markatzen duela kontuan hartu behar dugu); eta, bestetik, hesian sartzeko lehia (sortuko den trafikoa) ere handiagoa egin daiteke, prozesuak bildu egingo baitira hesian berriz sartzeko.   b. Hesia irekita dagoela adierazteko, hesitik hesira aldatzen den balio bat erabil daitezke (sense reversal, bit alternante). Nahikoa da bi baliorekin, 0 eta 1, ez baita posible hesi jakin baten bi aktibazio baino gehiago batera izatea. Hala, lehenbiziko hesia irekita dagoela adierazteko, 0 balioa erabiltzen da; hurrengo hesirako, 1 balioa; hurrengorako, 0a, eta abar. Prozesuek aldagai pribatu bana erabiliko dute balio hori kudeatzeko; beraz, ez dago aldagai partekatu bat (aurreko H.egoera) hesiaren egoera adierazteko.   Adibidez, honela izan daiteke sinkronizazio-hesia bigarren estrategiari jarraituz: irt_balaldagaia pribatua da, bat prozesuko; hesitik atera ahal izateko adierazlearen uneko balioa adierazten du.   HESIA (H,P) { irt_bal = !(irt_bal); egokitu hesitik ateratzeko balioa  LOCK(H.sar); H.kont++; nire_kont = H.kont; UNLOCK(H.sar);  if (nire_kont ==P) azkena naiz { H.kont = 0; hasieratu kontagailua H.egoera = irt_bal; ireki hesia } else while(H.egoera!=irt_bal){};itxaron hesia ireki arte }  4.4.3. Eraginkortasuna Sinkronizazio mota honetan erabiltzen diren eraginkortasun-irizpideak aurrekoak berak dira: latentziak txikia izan behar du (ez da eragiketa asko egin behar hesian sartzeko); trafiko gutxi sortu behar da; eraginkortasuna mantendu egin behar da prozesadore kopurua hazten denean (scalability); eta abar. P prozesuko hesi batek sortzen duen datu-trafikoa dela eta, honako balioespen hau egin daiteke. Demagun hesi-egituraren aldagaiak (sar, kont eta egoera) datu-bloke desberdinetan daudela (partekatze faltsua saihesteko). Oro har, Pi prozesuak lau datu-bloke eskuratu behar ditu: sar aldagaiarena, sekzio kritikoan sartzeko; kont aldagaiarena, kontagailua gehitzeko; egoera aldagaiarena, itxarote-begiztan geratzeko; eta, azkenik, egoera aldagaiarena berriz, itxarote-begiztatik ateratzeko, azken prozesuak baliogabetuko baitu bloke hori hesia irekitzean. Beraz, datu-trafikoa 4P ordenakoa izango da (zehatzago, 4P‚Äì2 datu-bloke, aurreneko eta azken prozesuek bloke bat gutxiago eskatuko baitute). Denboran zehar begiratuta, datu-trafiko hori honela banatuko da eskuarki: 2 - 3 - 3... - 3 - P‚Äì1; hau da, hesian sartzeko sortzen den trafikoa denboran banatzen da (baldin eta hesian sartzeko lehiarik ez badago; bestela, lock funtzioak trafiko gehiago sortuko luke, aurreko ataletan ikusi dugun moduan), baina azken P‚Äì1 eskaerak aldi berean sortuko dira, prozesu guztiak (azkena izan ezik) zain daudelako hesitik ateratzeko; une horretan, beraz, blokeak zerbitzatzeko latentziak handiagoak izango dira. Aurreko kasuetan bezala, honetan ere hainbat hobekuntza egin daitezke; aldagai bera atzitzen duten prozesuen kopurua txikiagotzea da helburua. Esaterako, hesia arbola moduan antola daiteke; esaterako, prozesuak binaka sinkronizatzen dira, dagozkien datu-egiturak erabiliz; gero, bikote bakoitzeko bat, binaka ere sinkronizatzen dira; eta abar (bus batean ez da ezer irabazten, trantsizio guztiak busean azaltzen dira eta; sarea deszentralizatua bada, abantailak handiak izan daitezke). Hala ere, ikusi ditugun hesiak ondo dabiltza SMP makinetan, eta eskuarki ez da beharrezkoa, salbuespenak salbuespen, beste egitura mota bat. Sinkronizazio-hesiak hardwareaz ere egin daitezke, kontrol-bus berezia baldin badago. Hori egiteko, zelatarientzako sh kontrol-lerroa gauzatzeko erabiltzen den estrategia bera erabili behar da (ANDwired).   4.5. LABURPENA Ohikoa da paraleloan exekutatzen diren prozesuen exekuzioa sinkronizatu behar izatea, aldagai partekatuen erabilera egokia izan dadin. Hainbat kasutan, sekzio kritikoak eratu egin behar dira, eta horretarako makina-mailako agindu atomiko bereziak erabili behar dira, zeinen bidez aldagai baten irakurketa eta idazketa modu atomikoan betetzen den. Beste batzuetan, sinkronizazioa gertaeren bidez gauzatu behar da, banan-banan, adierazleen bidez, edo prozesu multzo bat sinkronizatzeko, hesien bidez. Sinkronizaziorako erabiltzen diren agindu atomikoak "baliokideak" dira, eta prozesadore jakin batean denak edo batzuk bakarrik izango ditugu. Hala ere, horietako bat erabiliz besteen portaera "simula" daiteke. Esaterako, errutina bat egin daiteke LL/SC aginduak erabiliz F&I edo T&S aginduen portaera simulatzeko. Baina, ezin da ahaztu batzuk besteak baino egokiagoak izan daitezkeela, sortzen den trafikoaren arabera (idazketetan baliogabetzen diren datu-blokeak). Adibidez, T&S agindua erabiliz egindako lock errutina soila egokia da sekzio kritikoan sartzeko lehiarik ez badago, baina ez da batere eraginkorra lehia handia espero bada. Datu-trafikoa arazo larria da SMP sistemetan, eta, beraz, hainbat estrategia garatu dira sinkronizazio-funtzioek sortzen duten trafikoa murrizteko: backoff, test-and-test&set, txartelak, sarraila-bektoreak... Izan ere, programatzailearen ardura da aplikazioari dagokion estrategiarik egokiena aukeratzea, dela bibliotekako (sistemako) funtzioak erabiliz, dela sinkronizazio-funtzio bereziak idatziz.                                             ‚ñ™ 5‚ñ™                  MemoriarenKontsistentziaKonputagailuParaleloetan                5.1. SARRERA 5.1.1. Prozesadore bakarreko sistemak Zein ordenatan exekutatzen dira programa baten aginduak prozesadore batean? Erantzuna ez da erraza; gehiegi pentsatu gabe, honako erantzun hau eman daiteke: programan idatzitako ordenan, jakina! Haatik, badakigu hori ez dela egia. Exekuzio-eredua Von Neumann izan arren, hainbat hobekuntza erabiltzen dira, hala hardwarean nola softwarean, zeinek aginduen exekuzio-ordena aldatu egiten duten. Esaterako, hardwareak ez du beti errespetatzen aginduen jatorrizko ordena (scoreboard edo Tomasulo desordena/desordena exekuzio- ereduak; agindu-bufferren erabilera prozesadore supereskalarretan, eta abar). Ildo berean, baina softwarearen ikuspuntutik, badakigu konpiladoreek berrordenatu egiten dutela kodea, exekuzio eraginkorragoak lortzeko (list scheduling, loop unrolling, trace scheduling, software pipelining...). Aginduen berrordenatze horretan, memoria-eragiketei dagokie alderdirik kezkagarriena. Konputagailu baten memoriak bildu beharko luke, zehatz-mehatz, exekutatzen ari den programaren "uneko egoera", hau da, programaren exekuzioa noraino heldu den eta lortutako emaitzak. Hala ere, jakin badakigu ez dela hori errealitatean gertatzen. Adibidez, cache memoria erabiltzen denez, memoria nagusia ez dago beti gaurkotua; LD eta ST aginduen arteko desordena onartzen da ("load aurreratu eta zirkuitulaburra egin" ereduan, esaterako); idazketa- bufferrak erabiltzen dira, CM‚ÜíMN transferentziak egiten diren bitartean prozesadorea geldituta ez uzteko; konpiladoreak berak ken ditzake kodetik hainbat memoria-eragiketa eta, haien ordez, erregistroetako balioak erabili (esaterako, begiztak zabaltzen direnean eta errekurrentziak daudenean), eta abar. Izan ere, hobekuntza horietan guztietan datza prozesadoreen kalkulu- abiaduraren hazkundearen zioetako bat. Beraz, ez da erraza programa baten aginduen exekuzio-ordena jakitea, aginduak berrordenatzen direlako eraginkortasun handiena lortu ahal izateko. Jakina, programa ordena hertsian exekutatuz lortuko liratekeen emaitzak berak lortu behar dira, beti. Esaterako, aldagai bat irakurtzen denean, beti lortu behar da azken idazketari dagokion emaitza. Aipatu ditugun optimizazio guztiak erabiltzen badira ere, programen exekuzioaren kontrola "zehatza" da prozesadore bakarreko sistemetan, kontrol- unitatea bakarra baita. Zoritxarrez, ez da gauza bera gertatzen multiprozesadoreetan, kontrol-unitate asko, banatuta, baitaude. 5.1.2. Multiprozesadoreak Prozesadore bakarreko sistemetan konponduta dagoena, arazo larri bihurtzen da multiprozesadoreetan, kontrola deszentralizatuta dagoelako, hainbat prozesadoretan. Beraz, zein ordenatan exekutatzen dira programen aginduak sistema paraleloetan, osorik hartuta? Edozein ordenatan exekutatuta, emaitza egokia da? Prozesuen arteko komunikazioa memorian egiten bada (demagun hala dela), aurreko galderak beste honetan laburbil daitezke: zein ordenatan exekutatzen dira memoria-eragiketak sistema paraleloetan? Aginduen exekuzio-ordenarekin lotzen den arazoari, eta, oro har, sistema paraleloa osatzen duten prozesadoreek memoria-edukiari buruz duten irudiaren arazoari, memoriaren kontsistentzia deritzo. Hirugarren kapituluan aztertu dugun koherentziaren arazoa ere gai berari dagokio, baina modu mugatuagoan. Gogoratu; koherentzia-protokolo baten erabilerak ziurtatzen ditu: ‚Ä¢ cache lokal bateko aldagai baten gainean egiten diren aldaketak cache guztietan agertuko direla, noizbait. ‚Ä¢ aldagai batean egiten diren aldaketak ordena berean agertuko direla beste prozesadoreetan. Beraz, koherentzia-protokolo bat erabiliz, aldagai baten gainean egiten diren aldaketa guztiak hurrenkera berean ikusiko dute prozesadore guztiek. Hala ere, koherentzia-ereduak ez digu ezer esaten aldagai desberdinen gainean egiten diren idazketen ordenari buruz (zein ordenatan ikusiko diren sistemako prozesadoreetan). Arazoa, beraz, koherentziarena baino orokorragoa da. 5.1.3. Programen semantika eta aginduen exekuzio-ordena Lehenik eta behin, ondo aztertu behar da programa paraleloen semantika, emaitzak ez baitira, askotan, intuitiboki espero ditugunak. Izan ere, algoritmo bat hainbat prozesadoreren artean banatzen denean, ondo kontrolatu behar da aldagai partekatuak nola erabiltzen diren. Aginduen exekuzio-ordena funtsezkoa da programa paraleloen semantika definitzeko. Esaterako, zein izango da bi prozesadoretan exekutatzen den programa honen emaitza P2n? Ba al dauka semantika garbia programak?(hasieran,A=B= 0)                                   P1     P2                                  A = 1; print B;                                 (wr1)  (rd1)                                 B = 2; print A;                                 (wr2)  (rd2)    Lau konbinazio posible ditugu emaitzetarako: BA = 00; 01; 21; eta 20. Aginduak denboran zehar tartekatzen diren ordenaren arabera, lau aukera horietatik lehenengo hirurak "logikoak" lirateke. Esaterako, BA = 01 inprimatuko du P2k, aginduak denboran zehar ordena honetan exekutatzen badira:                                 P1     P2                                  A = 1; ...                                 ...    print B;                                 B = 2; ...                                 ...    print A;    Aldiz, laugarren konbinazioak, hots, BA = 20, ezinezkoa ematen du: B = 2 inprimatzen bada, A = 1 inprimatu behar da, nahitaez. Baina, egon adi! konbinazio hori agertuko da, baldin eta P2k aginduak desordenatzea erabakitzen badu, bi aldagai independente irakurtzen baititu (ohiko exekuzio-eredua desordena/desordena da). Izan ere, idatzita dagoen moduan, aurreko programa paraleloa anbiguoa izan daiteke. Aurreko kapituluan ikusi dugunez, programa paraleloen semantika, eskuarki, sinkronizazio-eragiketen bidez zehazten da. Adibide honetan ageri da kasu bat: P2k, A = 1 inprimatu beharko luke, beti.                            P1         P2                           A = 1;     while(PREST==0){};                          (wr1)      (rd1)                          PREST = 1; print A;                          (wr2)      (rd2)    Zoritxarrez, aldagai partekatuen erabilera sinkronizatuta ere, oraindik arazoak izan ditzakegu aginduen exekuzio-ordenarekin. Bi programetako datu- dependentziek ziurtatu beharko lukete emaitza zuzena; baina datu-dependentzia horiek programen (prozesadoreen) artean ageri dira, eta ez programa bakoitzaren barruan!   wr1(A) rd1(PREST) wr2(PREST) rd2(A)   Prozesadore bakoitzean aginduen ordena errespetatzen bada, hots, bi idazketen eta bi irakurketen arteko ordena errespetatzenbada (wr1 >> wr2; rd1 >> rd223), wr1 ‚Üí rd2 dependentzia berez errespetatuko da, honako hau beteko baita: wr1 >> wr2 ‚Üí rd1 >> rd2 ÔÉû wr1 ‚Üí rd2. Baina ordena lokala errespetatzen ez bada (hau da, konpiladoreak edo hardwareak kodea desordenatzen badu), baliteke A = 0 inprimatzea. Aginduen ordenaren arazoa beste adibide honetan ere ikusten da (hasieran F1 = F2 = 0):                           P1              P2                          F1 = 1;         F2 = 1;                         if (F2==0) then if (F1==0) then                         < kodea >       < kodea >                         ...             ...    Hauek dira agindu horien arteko dependentziak:   wr1(F1) wr2 (F2) rd1(F2) rd1 (F1)   "Logika" sekuentzialaren arabera, ez da posible bi prozesadoreak then adarreko kodea exekutatzea, nahitaez errespetatu behar baitira wr1 >> rd1 eta wr2 >> rd2 ordenak; baina kodea desordenatzen bada prozesadore bakoitzean (eta ez dago arazorik hori egiteko, ez baitago inongo dependentziarik prozesadore bakoitzeko aginduen artean), litekeena da bi prozesadoreak kode zati hori exekutatzea. Adibideetan aipatu ditugun ordena-aldaketak guztiz normalak dira prozesadore bakarreko sistemetan; are gehiago, beharrezkoak dira gutxieneko eraginkortasuna lortuko badugu. 5.1.4. Aginduen atomikotasuna Memoria-aginduak atomikoak dira, baldin eta, hasten direnetik bukatu arte, beste memoria-eragiketari ekiten ez bazaio. Gainera, bukaera modu globalean ulertu behar da; hots, agindua bera eta haren ondorioak multiprozesadorean (esaterako, idazketa ez da bukatzen harik eta idatzi den datu-blokearen kopia guztiak baliogabetu diren arte). Ikus dezagun adibide bat.                            P1         P2                           A = 1;     while(PREST==0){};                          (wr1)      (rd1)                          PREST = 1; print A;                          (wr2)      (rd2)  Aginduen arteko ordenari eutsita ere, badago oraindik beste arazo bat. Koherentzia-protokoloak P1en egiten diren bi idazketak (aldaketak) P2n ere ikusiko direla ziurtatzen du, bainaez du esaten zein ordenatan ikusiko diren, bi helbide desberdinekoak direlako24. PREST aldagaiaren balio berria A aldagaiarena baino lehen ageri bada P2n, A = 0 inprimatuko da. Hori gerta daiteke P1en idazketakatomikoak ez badira, hau da, programa exekutatzen jarraitzen bada (wr2) aurreko idazketa (haren ondorioak) oraindik bete gabe izanik. Hau da, beraz, ondorioa: programa paraleloen "zuzentasuna" ziurtatzeko, itxaron egin beharko genuke memoria-eragiketa bat "bukatu" arte hurrengoari ekin baino lehen. Arazoa, hala ere, orokorragoa da. Adibide honetan ere islatzen da atomikotasunaren beharra (A = B = 0):                        P1     P2             P3                        A = 1; while(A==0){};                             B = 1;                                            while(B==0){};                                            C = A;   P1ek A idazten duenean, balio berria P2ra eta P3ra zabalduko da. A-ren balio berria P2n agertzen denean, B = 1 exekutatuko da, eta, ondorioz, B-ren balio berria ere P3ra zabalduko da. Bi aldaketa horietatik, zein ikusiko da lehenago P3n? Aurrena P2n egindako aldaketa (B berria) bada, litekeena da P3n C = 0 exekutatzea, eta ez C = 1. Beraz, memoria-eragiketen atomikotasuna arazo globala da, prozesadore baten barruan ez ezik, sistema osoan mantendu behar baita. 5.1.5. Kontsistentzia-ereduak Sistema paraleloetan exekutatzen diren programek prozesadore bakar batean exekutatzen direneko emaitza bera eman behar dute: sistema paraleloak kontsistentea izan behar du. Aurreko adibideetan ikusi dugunez, arazoa memoria- eragiketekin ageri da (batik bat, aldagai partekatuekin), aldaketen ordena eta atomikotasuna dela eta. Sistema-softwarearen egileek zein aplikazioen programatzaileek programa paraleloen aginduen exekuzio-ordena eta atomikotasuna zehazten dituen eredu bat behar dute, kodean egin daitezkeen hobekuntzak jakiteko eta programen portaera modu egokian ulertu eta interpretatu ahal izateko. Memoriaren kontsistentzia- eredu batek memoria-espazio koherentea definitzen du, sistemako prozesu guztietarako, memoria-eragiketen arteko ordena-erlazioak adieraziz. Hurrengo ataletan, multiprozesadoreetan erabiltzen diren kontsistentzia-eredu nagusiak azalduko ditugu: batetik, kontsistentzia sekuentziala, eta, bestetik, kontsistentzia-eredu malguak.   5.2. KONTSISTENTZIA SEKUENTZIALA(SC,sequential consistency) Aipatu dugunez, kontsistentzia ez da arazoa prozesadore (kontrol-unitate) bakar bat erabiltzen denean: agindu-jario bakarra dago, eta ordena "kontrolpean" dago. Konpiladoreak hainbat aldaketa egin ditzake aginduen ordenan (irakurketak aurreratzea, esaterako), eta hardwarea dago prozesadorea blokeatzeko edo aginduak geldiarazteko, datu- eta kontrol-dependentziei aurre egiteko. Prozesadore bakarreko "ordena hertsiko" eredua multiprozesadoreetara zabalduz, kontsistentzia sekuentziala (SC) izeneko eredua lortzen da. Multiprozesadore bat sekuentzialki kontsistentea da, baldin eta (a) aginduen ordena lokala mantentzen bada prozesadore bakoitzean, eta (b) aginduen ordena sistema osoan (globala) prozesadore bakoitzeko aginduen tartekatze jakin bati badagokio. SC eredua da programatzaile batek eskuarki espero duena, intuitiboena. Bi baldintza ezartzen ditu eredu horrek:   1. Prozesadore bakoitzean, aginduen ordena lokala mantendu behar da. Ordena lokala mantentzeak LD eta ST aginduak ezin direla desordenatu esan nahi du. Mantendu egin behar dira, beraz, lau ordena-erlazio hauek, edozein helbidetarako eta prozesadore bakoitzean: wr >> rd;wr >> wr;rd >> rd;eta rd >> wr. Esaterako, hurrengo adibidean, lehenbiziko bi exekuzio-ordenak SC ereduarekin bat datoz; beste biak, ordea, ez, aginduen jatorrizko ordena lokala (memoria- eragiketak) errespetatzen ez baita.          P1                   P2                Batera, denboran zehar                                           SC bai SC ez          a                    c           a a a c          b                    d           b c d d                                           c b c b                                           d d b a    2. Ordena globala ere mantendu behar da, eta horrek esan nahi du ezin dela memoria-eragiketa bat exekutatu harik eta aurrekoa (edozein prozesadoretan), eta haren ondorioak, bukatuta izan arte. Hori ziurtatzeko, memoriako eragiketek atomikoak izan behar dute (write atomicity = idazketa guztiek, edozein posiziotan, ordena berean ageri behar dute, prozesadore guztietan). Beraz, ez da onartzen honako exekuzio hau:         Bi baldintza horien beharra egiaztatu dugu, dagoeneko, aurreko ataletako adibideetan. Beraz, eta laburbilduz, memoriaren kontsistentziaren arazoa erabat desagertzen da SC ereduan, exekuzio-ordena jakin bat, lokala zein globala, eta atomikotasuna ezarri direlako. Memoria-eredua, beraz, ordena hertsiarena da, eta programen portaera espero dena izango da. Irudian, eredu horren memoria- eskema logikoa ageri da: memoria-eragiketak atomikoki zerbitzatzen dira, ordena hertsian.               5.2.1. Memoria-eragiketen ordena eta atomikotasuna Prozesadore bakoitzean ordena lokala ezartzea erraza izan daiteke, baldin eta aurreko memoria-agindua noiz bukatu den badakigu; aldiz, zailagoa izan daiteke memoria-eragiketen atomikotasuna (ordena globala) ziurtatzea, prozesadoreek cache pribatu bana erabiliko dutela kontuan harturik. Hauek izango lirateke SC eredua betetzeko eginkizunak:   1. Prozesadore bakoitzean, LD eta ST aginduen arteko ordena gorde behar da (erraz bete daiteke, prozesadore bakoitzeko aginduen ordena kontrol-unitate bakar baten mende dagoelako).   2. Ordenaz gain, bertako aginduen atomikotasuna ziurtatzeko, prozesadore bakoitzeko memoria-eragiketak noiz bukatzen diren jakin behar da, hurrengoei ekin ahal izateko. Irakurketa (LD) baten bukaera detektatzea erraza da: datuak eskuratzen direnean, hain zuzen ere. Idazketekin, aldiz, arazo gehiago dago. Izan ere, idazketa (ST) bat exekutatzen denean, prozesadoreak ezin du hurrengo memoria-eragiketa exekutatu idazketa zein haren ondorioak (kopien baliogabetzea edo eguneratzea) prozesadore guztietan bete diren arte (write completion). Baliogabetze/eguneratze guztiak egin direla ziurtatzeko, koherentzia- protokoloak konplexuagoa behar du izan, erantzunak gehitu behar baitira: ACK seinaleak edo mezuak (acknowledgement, onartzea). Bloke baten kopia baliogabetu/eguneratu duten prozesadoreek ACK bana bidali behar dute; erantzun horiek guztiak bildu direnean, eragiketa bukatu egin da (arazoa: nola jakin zenbat kopia dagoen?).         3. Prozesadore guztiak kontuan hartuta, atomikotasuna (ordena globala) ziurtatzeko, bi baldintza bete behar dira: (a) Batetik, aldagai beraren gaineko idazketak hurrenkera berean ikusi behar dira prozesadore guztietan. Adibidez,                                     P1     P2     P3              P4                                    A = 2; A = 3; while(B‚â†1){}; while(B‚â†1){};                                   B = 1; C = 1; while(C‚â†1){}; while(C‚â†1){};                                                 reg1 = A;       reg2 = A;    A aldagaiaren eguneratzeak (2 eta 3) P3ra eta P4ra desordenatuta heltzen badira, kontsistentzia ez da beteko, balio desberdinak esleituko baitira reg1 eta reg2 erregistroetara, eta A-ren idazketa ez dela atomikoa izan emango du. Multiprozesadoreko konexio-sarea bus bat denean, koherentzia-protokoloak (zelatariak) eta busa egoki erabiltzeak ziurta dezakete idazketen ordena. Laster ikusiko dugunez, sare orokorragoak erabiltzen direnean, direktorioak erabili behar dira koherentzia zein ordena ziurtatzeko.   (b) Eta, bestetik, irakurketa (LD) bat exekutatu baino lehen, itxaron egin behar da aldagai horren azken balioa idatzi zuen agindua, eta haren ondorioak prozesadore guztietan, bukatuta izan arte (oro har, beste prozesadore batean). Koherentzia-protokoloa baliogabetzekoa bada, ez da zaila aurreko baldintza betetzea: bertako kopia baliogabetuta dago, eta, beraz, beste kopia bat eskatu behar da; kopia hori eragiketa bukatuta dagoenean zerbitzatuko da. Kopiak eguneratzen badira, ordea, koherentzia mantentzeko prozesuak, idazketa dela eta, konplexuagoa izan behar du: aldagaia eguneratzeko seinalea sortu ondoren (1), itxaron egin behar da baieztapen guztiak heldu arte (2); azkenik, aldagaia erabil daitekeela adierazteko mezua bidali behar zaie kopia guztiei (3), eragiketa sistema osoan bukatutzat emateko. Konplexutasun hori dela eta, eguneratzeko koherentzia-protokoloak ez dira eskuarki erabiltzen.       5.2.2. Eragina hardwarean eta konpiladorean Kontsistentzia sekuentziala ziurtatzen duten baldintzak ‚Äîordena eta atomikotasuna mantendu beharra, alegia‚Äî oso gogorrak dira. Memoria-eragiketa bat "bukatu" arte, prozesadoreak ezin du hurrengo memoria-eragiketa exekutatu; eta memoria-aginduak % 25 - % 35 dira! Gainera, cache memoriaren erabilera konplikatu egin da, eta prozesadore bakar baterako eskuarki erabiltzen diren hainbat hobekuntza ezin dira erabili. Adibidez, memoria-eragiketen atomikotasuna eta ordena direla eta, ezin dira idazketa-bufferrak erabili; azken batean, idazketa-bufferrak erabiltzeak hurrengo LD aginduen aurreratzea dakar. Era berean, konpiladoreak ezin du kodea berrordenatu, horrekin memoria-eragiketen ordena aldatzen bada. Eta, zoritxarrez, ezin da memoriaren erabilera optimizatu erregistroak erabiliz (LD/ ST aginduak aurrezteko). Esaterako, optimizazio hau gaizki dabil multiprozesadore batean:                       P1            P2      P1      P2                      A = 1;        A = 0;  r1 = 1; A = 0;                      B = A;                A = r1;                                            B = r1;                       (2 ST / 1 LD)         (2 ST)  Jatorrizko programan, B aldagaiak 1 edo 0 balioak izan ditzake; bigarrenean, aldiz, B = 0 balioa ez da inoiz lortuko, A irakurtzen ez baita (funtsean, LD aginduen aurreratzea). Beraz, ezin da optimizazio hori onartu SC kontsistentzia-ereduan. SC ereduaren "albo-ondorio" horiek arintzeko edo, zenbait aukera daude. Esaterako, LD aginduak modu espekulatiboan exekuta daitezke, aurreko ST aginduak bukatu baino lehen. Azkenean dena ondo atera bada, aurrera jarraituko da, arazorik gabe; bestela, tartean blokea baliogabetu edo eguneratu bada, atzera jo beharko da (roll-back, jauzi-aginduen latentzia gainditzeko egiten den modu berean). Nolanahi ere, oraintxe ikusiko dugunez, SC eredua inposatzen dituenak baino murriztapen gutxiagorekin ere manten daiteke sistema paraleloen kontsistentzia.   5.3. EREDU MALGUAK(relaxed) Kontsistentzia ziurtatzeko SC ereduaren baldintzek multzo nahikoa osatzen dute, baina ez beharrezkoa. Gainera, eraginkortasunaren ikuspuntutik, sistemaren gainean duten eragina handia da, hainbat eta hainbat hobekuntza debekatzen direlako, eta memoria-eragiketa guztien bukaera arte itxaron behar delako. Eraginkortasuna hobetzeko, beraz, eredu malguagoak garatu behar dira, eta, horretarako, agindu-ordenaren beharraren analisi finagoa egin behar da. Aipatu dugunez, memoria-aginduen arteko ordena lau kasu hauetan laburbiltzen da: rd >> rd25rd >> wr26wr >> rdwr >> wr  Kontsistentzia-eredu sekuentzialak aurreko ordena guztiak betetzen direla ziurtatzen du. Kontsistentzia-eredu malguek, aldiz, onartzen dituzte horietako batzuk ez errespetatzea. Kontsistentzia-eredu malgu bat definitzeko, beraz, honako hau adierazi behar da:   ‚Ä¢ Memoriako aginduetan zein ordena errespetatzen den eta zein ez. ‚Ä¢ ST (idazketa) eragiketaren atomikotasuna betetzen den ala ez, LD agindu baten exekuzioa baimendu ahal izateko, ST aginduaren eragina oraindik prozesadore guztietan gauzatu ez bada ere.   Nolanahi ere, kontsistentzia-eredu malgu bat erabiltzen denean, aukera izan behar da beti hobekuntza horiek bertan behera uzteko, ordena hertsia ezartzeko. Horretarako, eskuarki makina-mailako agindu bereziak erabiltzen dira (oro har, bibliotekako funtzioen bidez). Agindu berri horiek ordena-hesiak (fence) deitzen dira, eta kontrol-gune gisa erabiltzen dira. Ordena-hesi motako agindu batek hurrenkera jakin bat inposatzen du, ez baitu uzten hurrengo memoria- aginduei ekitea, aurreko guztiak bukatu arte. Agindu berezi horiek desberdinak dira prozesadoreen arabera: MEMBAR, STBAR, SYNC... Oro har, hiru mota hauetan sailkatu ohi dira:   ‚Ä¢ Write-fence: aurreko idazketa guztiak bukatu direla eta hurrengoak ez direla hasi ziurtatzeko (beraz, wr >> wr ordena ezartzeko). ‚Ä¢ Read-fence: gauza bera, baina irakurketekin (eskuarki, LD aginduen aurreratzea mugatzeko erabiltzen dira). ‚Ä¢ Memory-fence: berdin, baina bi eragiketetarako, rd eta wr.  Definizioz, kontsistentzia sekuentziala erabiltzen denean, memoria-eragiketa guztiak fence motako agindu bihurtzen dira. 5.3.1. Total Store Ordering (TSO)/ Processor Consis-tency(PC) Idazketen latentzia "ezkutatzea" da lehenbiziko hobekuntzaren helburua, eta, horretarako, ST agindu bat bukatzeke dagoela, onartzen da hurrengo LD aginduak exekutatzea; hau da, LDaginduak aurreratu daitezke: ez da ziurtatzen wr >> rd ordena. TSO eta PC ereduen arteko desberdintasun bakarra hau da: Processor Consistency deiturikoan, ez da ziurtatzen memoria-eragiketak atomikoak direnik. Hau litzateke eredu horri dagokion memoria-egitura (eskematikoki):                   TSO ereduan, ilara bat erabiltzen da ST (eta SWAP, T&S...) aginduetarako (idazketak), eta haien artean ordena mantentzen da (FIFO). LD aginduek aurreratu dezakete ilara hori eta memoria irakurri (edo zirkuitulabur bat erabili), dependentziarik ez badago, noski. Edonola ere, ST aginduek ezin diete LD aginduei aurrea hartu, eta, halaber, ezin dira bi LD agindu desordenatu. Izan ere, LD aginduek "blokeatu" egiten dituzte hurrengo memoria-eragiketak. Adibide gisa, honela ulertu behar da bi programa hauen exekuzioa, erabilitako kontsistentzia-ereduaren arabera:                         P1                P2                        X = balio_berria; Y = balio_berria;                       Y_kopia = Y       X_kopia = X   SC ‚Üí gutxienez batek,Y_kopiakedoX_kopiak,balio_berriaizango du. TSO ‚Üí litekeena daY_kopiazeinX_kopiaez hartzeabalio_berria.   Definizioz, TSO/PC kontsistentzia-eredu malguan ez da kontsistentzia sekuentziala mantentzen; beraz, ez da ziurtatzen programen portaera egokia izango dela kasu guztietan. Hori dela eta, litekeena da programetako zenbait puntutan ordena hertsia (SC) ezarri behar izatea. Eta, horretarako, arestian aipatu ditugun agindu bereziak (fence motakoak) erabili behar dira. Agindu mota hori prozesadorearen agindu-multzoan ez badago, read-modify-write motako aginduak erabil daitezke (T&S esaterako) ST (LD) memoria-agindu arruntak erabili beharrean, ezen horiek irakurketa eta idazketa bana egiten baitute, eta, ondorioz, ezin dira desordenatu TSO/PC kontsistentzia-eredua erabiltzen denean; esaterako:   ST ... LD‚Üí SWAP ... LD desordenatu daitezke ezin dira desordenatu TSO kontsistentzia-eredua egokia da idazketen latentzia gainditzeko, eta, gainera, eredu horretan ondo funtzionatzen dute beti adierazle baten bidezko ohiko sinkronizazioek: write A;write FLAG//read FLAG;read A. Hori dela eta, hainbat makinatan erabili da: Sequent Balance, Encore Multimax, (IBM 370), SparcCenter2000, SGI Challenge eta Pentium Pro (PC) eta abarretan. 5.3.2. Partial Store Ordering(PSO) Kontsistentzia-eredu malguagoa lortzen da, baldin eta idazketen arteko ordena ere ez bada errespetatzen (idazketa >> irakurketa ordenaz gain); hau da, ez dira ziurtatzen bi ordena-erlazio hauek: wr >> rd, wr. Memoria-egitura aurreko ereduarena da, baina ST aginduetarako ilarak ez dira FIFO moduan kudeatzen; beraz, idazketen ordena ez da ziurtatzen. Adi egon: kontsistentzia-eredu hori erabiltzen denean, gerta daiteke sinkronizazio arruntenak ere (ekoizle/kontsumitzaile, adierazle baten bidez) gaizki funtzionatzea. Beraz, kontu handiz analizatu behar da eredu hori erabiltzea merezi duen, eta ebaluatu, beti bezala, irabaz daitekeena eta galtzen dena. Aurreko ereduan bezala, memoria-aginduen ordena hertsia (orain wr >> wr ordena ere) ezarri behar bada programa baten puntu jakin batean, haren esanahia ziurtatzeko, dagoeneko azaldu ditugun agindu bereziak (fence motako aginduak) erabili behar dira. Kontsistentzia-eredu hori erabili da, esaterako, Sun Sparc PSO konputagailuan. 5.3.3. Eredu malguenak Partekatzen diren aldagaietan baino ez da ageri ordenaren arazoa, ez besteetan. Are gehiago; bi adibide hauetan, esaterako, ez litzateke beharrezkoa izango memoria-atzipen guztien ordena hertsia ziurtatzea:                   P1         P2                P1 / P2 / ... / Pn                                              ...                 X = X + 1; ...               lock(sar);                 Y = B + 1; while(adi==0){};  nik = i;                 adi = 1;   A = X / 2;        i = i + N;                 ...        B = Y;            j = j - 1;                                              unlock(sar);                                              ... Izan ere, nahikoa da sinkronizazio-eragiketarekiko ordena ziurtatzea; hori eginda, berdin zaigu beste aginduak zein ordenatan betetzen diren (adibidez, sekzio kritikoan prozesadore bakar bat izango da). Programazio sinkronizatua egiten dela esaten da, baldin eta aldagai partekatuen erabilera bi sinkronizazio-eragiketen bidez babesten bada (adibidez, aurreko adibideetan ageri den moduan). Dakigunez, aldagai partekatuetako atzipenak sinkronizatuta ez badaude, datu-lasterketak (data-races) ager daitezke: emaitzak ezin dira aurreikusi, eta aldatu egiten dira exekuziotik exekuziora. Hori dela eta, programa paralelo gehienek sinkronizazio motaren bat erabiltzen dute datu partekatuen erabilera "ordenatzeko" (beharrezkoa denean): lock eta unlock funtzioak, adierazleak eta abar. Ondorioz, programa baten kontsistentzia (esanahi intuitiboa) mantentzeko, nahikoa izango litzateke sinkronizazio-eragiketen ordena ziurtatzea, bai eta beste memoria-eragiketena sinkronizazioekikoere. Hurrengo kontsistentzia-ereduak definitzeko, memoria-eragiketa arruntak (rd, wr) eta sinkronizaziokoak (s) bereiztea komeni zaigu. Beraz, rd eta wr eragiketen arteko ordenaz gain, ordena-erlazio hauek ere kontuan hartu beharko ditugu: rd, wr >> ss >> rd, wrs >> s   Ordenazioa sinkronizazio-eragiketetara mugatu nahi bada, memoria-atzipenak egoki identifikatu beharko dira (hardwareaz zein softwareaz), bakoitzari dagozkion ordena-murriztapenak kontuan hartu ahal izateko. 5.3.3.1. Weak Ordering (WO) Weak Ordering kontsistentzia-ereduan, memoria-aginduen arteko edozein ordena onartzen da, baldin eta aginduak sinkronizazio motakoak ez badira; azken horien ordena, aldiz, zorrotz mantendu behar da (eta, ondorioz, fence edo hesi-agindu gisa funtzionatuko dute). Laburbilduz: sinkronizazio-eragiketak exekutatu baino lehen, itxaron egin behar da aurreko memoria-eragiketa guztiak bukatuta izan arte; sinkronizazio ondoko memoria-atzipenek ere itxaron beharko dute sinkronizazioa bukatu arte. Hori dela eta, hauek dira ereduak ziurtatzen dituen ordena-erlazioak: rd / wr >> s s >> rd / wr; s >> s   Aurreko bi ereduetan bezala, programaren esanahia zehazteko aginduen ordenari eutsi behar zaionean, bi aukera daude: hesi-aginduak (fence) sartzea ordena ezartzeko; edo, aukera hori ez badago, ordena mantendu behar den puntuan LD edo ST agindu arruntak sinkronizazio-eragiketa gisa identifikatzea (ordena ezarri, beraz). 5.3.3.2. Release Consistency (RC) Kontsistentzia-eredurik malguena da. Aurrekoan bezala, sinkronizazio-eragiketek markatuko dituzte ordenazio-puntuak; haien artean, LD eta ST aginduen arteko desordena onartzen da. Gainera, bi multzotan banatzen dira sinkronizazio- eragiketak: eskuratzeak (acquire, sa) eta askatzeak (release, sr). sa eragiketak irakurketak (edo RMW eragiketak) dira, eta sr eragiketak idazketak (edo RMW eragiketak). Adibidez, lock funtzioa acquire motako sinkronizazio- eragiketa da, eta unlock, aldiz, release motakoa (gauza bera hesi bat irekitzeko eragiketa). Sinkronizazio-eragiketen arteko ordenaz gain (s >> s), hauek dira eredu horretan bete beharreko baldintzak:   ‚Ä¢ eskuratze (acquire) motako sinkronizazio-eragiketaren ondorengo memoria- atzipenek ere itxaron behar dute sinkronizazioa bukatu arte; hau da, sa >> rd / wr ordena mantentzen da.   ‚Ä¢ askatze (release) motako sinkronizazio-eragiketa bat exekutatu baino lehen, prozesadoreak itxaron egin behar du aurreko memoria-eragiketa guztiak bukatu arte; beraz, rd / wr >> sr ordena mantentzen da.             Azken bi kontsistentzia-ereduak egokiak dira aginduen planifikazio dinamikoa (desordena/desordena) erabiltzen duten prozesadoreetan, LD aginduak desordenan bukatzea onartzen baita, bai eta idazketa bat aurreko irakurketa bat baino lehen betetzea ere. Alpha, IBM PowerPC, MIPS prozesadoreetan erabili da mota horretako kontsistentzia-ereduren bat (izan ere, hainbat kasutan ez da eredu jakin bat erabiltzen, eta erabiltzaileak erabaki behar du zer eredu nahi duen, fence motako eragiketen bidez). Taula honetan, kontsistentzia-ereduen ezaugarri nagusiak laburbildu dira.                     Memoria-eragiketen ordena            Ordenaezartzekoaginduak Eredua  wr>>rd   wr>>wr   rd>>rd/wr  sink.    wratom.   SC       ÔÅê      ÔÅê       ÔÅê    denak       ÔÅê   TSO               ÔÅê       ÔÅê    denak       ÔÅê         MEMBAR, RMW   PC                ÔÅê       ÔÅê    denak                   MEMBAR, RMW   PSO                         ÔÅê    denak       ÔÅê         STBAR, RMW   WO                                 denak       ÔÅê            SYNC                                     sa>>w/r   RC                                w/r>>sr                 REL, ACQ, RMW                                       s>>s   Irudi honetako adibidean, eredu bakoitzean inposatzen diren aginduen arteko ordenak (geziak) ageri dira.                    SC           TSO/PC          PSO      WO           wr,rd,s>>wr,rd,s   ‚Äì wr>>rd    ‚Äì wr>>wr  RC                                                             ‚Äì rd>>wr,rd      rd     = A              = A           = A           = A      = A    wr     B =              B =           B =           B =      B =  sink_a   sink_acq         sink_acq      sink_acq      sink_acq sink_acq    wr     C =              C =           C =           C =      C =    rd     = D              = D           = D           = D      = D  sink_r   sink_rel         sink_rel      sink_rel      sink_rel sink_rel    wr     E =              E =           E =           E =      E =    wr     F =              F =           F =           F =      F = 5.4. LABURPENA ETA PERSPEKTIBAK Programa paraleloek semantika argia eta ondo definitua izan dezaten, hardwareak zein programatzaileek multiprozesadoreko memoriaren "irudi" ondo definitua behar dute. Memoria partekatuko multiprozesadorearen memoria-irudi edo - interfaze horri kontsistentzia-eredua deritzo. Bi motako kontsistentzia-ereduak daude: sekuentziala eta malguak. Aurrenak, SC ereduak, memoria-aginduen ordena lokala eta globala mantentzera behartzen du, bai eta agindu horien exekuzio atomikoa egitera ere. Bestalde, eredu malguek agindu batzuen arteko desordena onartzen dute; esaterako, LD aginduak aurreratu daitezke (TSO), edo LD/ST aginduak (PSO), edo edozein exekuzio-ordena onartzen da, baina sinkronizazio-aginduekiko ordena errespetatuz (WO). Kontsistentzia- eredu malguak erabiltzen direnean, zenbait kasutan debekatu egin behar da aginduak desordenatzea ordena hertsia berrezartzeko, eta horretarako fence motako agindu bereziak erabiltzen dira. Eraginkortasuna kontuan harturik, eredu malguak SC eredua baino egokiagoak lirateke. Izan ere, SC eredua erabiltzen denean, ezin dira erabili prozesadore bakarreko sistemetan ohikoak diren hainbat hobekuntza, eta, ondorioz, eraginkortasuna txikiagoa dateke. Baina, beti bezala, eredu horien alde positiboak eta negatiboak aztertu behar dira, merezi duten ala ez jakiteko; hain zuzen ere, eredu malguak erabili ahal izateko, hardwarearen eta softwarearen laguntza behar da (agindu berriak; programatzaileek ondo identifikatu behar dituzte ordenazio-puntuak; eta abar.) Mark Hill izan da gai hauek guztiak aztertu dituen ikertzaile nagusietako bat. Haren iritziz, multiprozesadoreek SC eredua erabili behar dute oinarrizko eredu gisa, eta, agian, eredu malguren bat eskaini behar dute aukera moduan. Zer dela eta? Oraingo prozesadoreetan, ohikoa da aginduen exekuzio espekulatiboa egitea. Aginduak espekulatiboki exekutatzen dira, hots, seguru izan gabe exekutatu behar direnetz. Exekuzioa seguru bihurtzen denean, emaitzak idazten dira eta aginduak bukatutzat (commit) ematen dira; bestela, ez zirela exekutatu behar detektatzen bada, agindu horien eragina deuseztatu egiten da (batzuetan, roll- back prozedurak exekutatu behar dira), eta programaren exekuzio-puntu "seguru" batera itzultzen da. Hori dela eta, SC eredua erabili arren, eredu malguen hobekuntzak ere erabil daitezke, aginduak espekulatiboki exekutatzen diren neurrian; desegokiak suertatzen badira, aukera izango da haien eragina desegiteko. Zertan bereizten dira, beraz, bi eredu motak? Bada, eredu malguak erabiliz, aginduak lehenago erretira daitezke prozesadoretik, ez baita desordena egokia den edo ez jakin arte itxaron behar. Hobekuntzen balizko onurak neurtu behar dira beti, programa errealak zein proba-bankuak erabiliz. Egin diren zenbait esperimentutan, programen exekuzio- denbora % 10-20 txikiagoa da kontsistentzia-eredu malguak erabiltzen direnean, SC ereduarekin alderatuta. Merezi du hobekuntza horrek? Prest daude middleware (sistemako softwarea, behe-mailako aplikazioak...) programatzaileak eredu malguak erabiltzeko behar den konplexutasuna onartzeko? Esaterako: konpiladoreak egiten dituzten programatzaileei dagokie fence aginduak noiz sartu behar diren erabakitzea (behar direnak bakarrik, ez gehiago, eraginkortasuna ez galtzeko); softwarearen eramangarritasuna bermatzeko, hardware-plataforma desberdinak kontuan hartu behar dira; eta abar. Paraleloan programatzea zaila da berez, eta kontsistentzia-eredu malguak kontuan hartu behar badira, zailagoa. Laburbilduz; SC eredua multiprozesadore guztietan erabiltzen da (estandar gisa): kontsistentziako arazoak hardwarean konpontzen dira eta gardenak dira programatzailearentzat. Bigarren aukera gisa, TSO eredua egokia izan daiteke optimizazio arruntak erabili ahal izateko (LD aurreratu), eta txikia da eragina programatzaileengan. Memoria-eragiketen ordena guztiak erlaxatzen dituzten ereduak, aldiz, zailagoak dira justifikatzen.   1 Prozesadorea supereskalarra bada, agian zikloko agindu bat baino gehiago exekutatuko da; exekuzio-denbora, beraz, txikiagoa izan daiteke.  2 Ohiko exekuzio faseak: BD, agindua bilatzea eta deskodetzea; Ir, eragigaiak irakurtzea; AM, memoriako helbideen kalkulua; A, eragiketa bat unitate funtzional batean; M, eragiketa bat memorian; Id, emaitzak erregistroetan idaztea. Behar dituen faseak baino ez ditu erabiltzen agindu bakoitzak.  3 Jauzi-aginduen exekuzioari dagozkio kontrol-dependentziak. Eskuarki, i helbideko aginduaren ondoren i+1 helbideko agindua exekutatzen da, jauzi- aginduen kasuan izan ezik. Jauzi bat exekutatu behar denean, ez dugu jakingo zein den hurrengo aginduaren helbidea jauziaren exekuzioa bukatu arte. Beraz, prozesadorea gelditu egin beharko da (hala ere, badago hainbat teknika ziklo horiek ez galtzeko, eta programaren exekuzioarekin jarraitu ahal izateko).  4 Oharra: memoriako busak LV zein SV aginduetarako erabil daitezke; zenbait makinatan, ordea, bus "banatuak" erabiltzen dira, batzuk irakurtzeko eta beste batzuk idazteko.  5 Erregistroak idazten ari diren bitartean irakurri ezin badira, itxaron egin beharko da idazketa erabat bukatu arte.  6 Lehen aipatu dugun moduan, onena mk zenbaki lehena izatea da. Esaterako, mk = 5 bada, matrizeko errenkadak, zutabeak eta bi diagonalak gatazkarik gabe atzi daitezke, tartean hutsuneak utzita (ariketa gisa uzten dugu hori frogatzea).  7 Bektore-erregistroen tamaina kontuan hartu gabe.  8 Kalkulu-abiadura dela eta, ez da gauza bera batuketa bakar bat egitea denbora jakin batean, edo bi batuketa eta biderketa bat.  9 Nahi izanez gero, exekuzio-denbora eta kalkulu-abiadura N1/2 eta R‚àû parametroen funtzio gisa eman daitezke, honela:  T B = (N + N1/2) / R‚àû RB = R‚àû √ó (1 / (1 + N1/2/N))  10 Bektore guztiak N (edo N√óN) tamainakoak dira. A helbideak lehenengo osagaia, A0, erakusten du, A+1-ek bigarrena, eta abar (makinaren helbideratze-unitatea eta aldagaien tamaina kontuan hartu gabe). Izen desberdineko bektoreek memoria- posizio desberdinak erabiltzen dituzte, hau da, ez dira teilakatzen (ez dago aliasing-ik). Era berean, helbideak adierazteko erabiltzen den erregistroaren hasierako edukia 0 da (adibideetan, R1).  11 Oharra: aurreko adibideetan, matrizeak errenkadaka daude gordeta memorian, C- k egiten duen bezala. Fortran-ek, aldiz, zutabeka gordetzen ditu matrizeak.  12 Erabakia konplexua da, kontuan hartu behar baitira bektoreen pausoak (a eta c) eta teilakatzen den tartearen luzera, gutxienez bektore-osagai batean bat egiten dutela ziurtatzeko.  13 Zenbait kasutan, azelerazio-faktore superlinealak lor daitezke, hau da, P baino handiagoak. Hori ulertzeko, kontuan hartu behar dugu memoria, S/I-rako ahalmena eta abar ere gehitzen dela sistema paraleloetan. Esaterako, prozesadore bakar baten memorian kabitzen ez diren programa edo datuak, agian Pprozesadoreetako memorian sartuko dira, eta, jakina, horrek ere exekuzio azkarragoak lortzeko laguntzen du.  14 Blokea memoria nagusiaren eta cachearen arteko transferentzia-unitatea da, eskuarki memoria nagusiaren tartekatze-mailarekin erlazionatua. Beraz, ez da hitz bakar bat, ondoz ondoko memoria-posizioetako hitz multzo bat baizik; ohikoak dira, esaterako, 64 byteko blokeak (32 biteko 16 hitz edo 64 biteko 8 hitz). Ingelesez line (lerro) ere deitzen zaio.  15 Oraingo prozesadoreetan, cache memoria ere bi (edo hiru) mailatan dago banatuta; beraz, datu-bloke baten kopiak hiru (edo lau) izan daitezke.  16 Bus baten eredu sinpleena erabiliko dugu: busa erabiltzeko eskaerak banan-banan prozesatzen dira, eta ez zaio hurrengoari ekiten aurrekoa bukatu arte. Multiprozesadoreen busak, ordea, konplexuagoak izan ohi dira.  17 Adi. Adibidean hitz bakar bat ageri bada ere, bloke batean hainbat hitz dago.  18 S egoeran izateak ez du ziurtatzen datu-bloke horren kopia gehiago dagoenik sisteman, blokeak cacheetatik desager daitezkeelako, ordezkapenak direla medio (beste bloke batzuk kargatu ahal izateko); gainera, protokolo honetan, aldagai baten lehen kopia irakurtzen denean, S egoeran kargatzen da cachean beti, ez baitira bereizten E (kopia bat) eta S (kopia asko) egoerak.  19 Prozesadore azkarrenetan aurrekoa ez da egia, busaren erabilera optimizatu egiten baita latentziak txikiagotzeko.  20 Edo, bestela: bi prozesadorek batera idatzi nahi dute datu-bloke beraren gainean, baina datu-bloke hori ez dago ez baten cachean ez bestearenean. Biek ekarri behar dute blokea eta, une horretan blokea inork erreklamatzen ez duenez ‚Äìsh = 0‚Äì, biek jarriko dute blokea M egoeran.  21 Kodea argiagoa izan dadin, helbideratze absolutua erabiliko dugu kapitulu honen adibideetan; nahi izanez gero, ez dago batere arazorik beste bat erabiltzeko, indizeduna edo erlatiboa esaterako. Ohikoa den moduan, R0 erregistroaren edukia beti 0 da.  22 Prozesu kopuru maximoa P bada, egokia litzateke TXARTELA eta TXANDA aldagaien gehikuntza modulu P egitea, balizko gainezkatzeak saihesteko.  23 >> ikurrarekin ordena adierazten dugu. A >> B adierazpenak hau esan nahi du: A B baino lehen. exekutatu da. ‚Üí ikurrarekin, aldiz, datu-dependentzia bat adierazten dugu: A ‚Üí B, A-k sortzen duena B-k erabili behar du.  24 Prozesadore batetik bestera bidalitako ‚Äúmezuak/kontrol-seinaleak‚Äù desordenan hel daitezke helburura, komunikazio-sarearen eta -protokoloen arabera. Argia da aukera hori memoria banatutako sistemetan, baina bus batean oinarritzen diren SMP sistemetan ere gerta daiteke, bus motaren eta komunikazio-protokoloaren arabera.  25 Kontuan hartu hutsegiteetan blokeatzen ez diren cacheak.  26 Kontuz hiru kasu hauekin: helbide berean badira, datu-dependentziaren bat izango da. 
